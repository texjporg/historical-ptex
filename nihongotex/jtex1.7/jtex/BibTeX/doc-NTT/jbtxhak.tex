\documentstyle{j-article}
\postkinsoku ``
\parindent=\jspaceskip
\voffset=0cm
\hoffset=-0.2cm
\textwidth=16.2cm
\textheight=25cm
\jintercharskip=0pt plus 0.5pt minus 0.5pt

\def\JTeX{\leavevmode\lower .5ex\hbox{J}\kern-.17em\TeX}
\def\JLaTeX{\leavevmode\lower.5ex\hbox{J}\kern-.17em\LaTeX}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\def\JBibTeX{\leavevmode\lower .5ex\hbox{{\rm J}}\kern-0.15em\BibTeX}
\def\trnote#1{\footnote{\parindent=16pt\hskip-15pt\hang\indent 訳注：#1\parindent=10pt}}

\title{Designing B\kern-.05em{\large I}\kern-.025em{\large B}\kern-.08em\TeX\
 Styles\\
B\kern-.05em{\large I}\kern-.025em{\large B}\kern-.08em\TeX スタイル
の作り方
\footnote{翻訳の部分は原著者の許可を得て配布するものであり,翻訳について,
\JBibTeX に関する記述については松井に問い合わせられたい．}
$^,$\footnote{\JBibTeX (version 0.30)\cite{jbibtex}の説明も含む．}
}

\author{Oren Patashnik(訳：松井正一)}
\date{January 31, 1988(翻訳版：1991年1月1日)}
\def\orig#1{}
\begin{document}

\maketitle

\setcounter{section}{4}
\section{参考文献スタイルをハックする}
\label{style}
本稿は，実際には
\BibTeX の一般的なドキュメントである``\BibTeX ing''~\cite{btxdoc}の最終節
であり，
第\ref{style} 節からはじまる(そしてこの節だけで終る)．
しかし先のドキュメントは\BibTeX の利用者向けであり，本稿はスタイル
作成者向けであるので，物理的に分離したものとなっている．
とはいえ，この文書の読者は``\BibTeX ing''に精通している必要があり，本稿で
参照している節，節番号は2つの文書が1つのものと仮定している．

本節と標準スタイルファイルのドキュメントである{\tt btxbst.doc}で\trnote{日本
語対応版は{\tt jbtxbst.doc}である．}
既存のスタイルファイルの修正方法，新たなスタイルファイルの作成
方法を説明する．
もしちゃんとしたスタイルファイルを作ろうと思っているのであれば，
スタイルに関してvan~Leunen~\cite{van-leunen}に，
タイプセットに関してLamport~\cite{latex}とKnuth~\cite{texbook}に，
さらに場合によっては，
細かな互換性の問題から{\em Scribe\/}~\cite{scribe}に精通していなければ
ならない．
せっせと仕事をする合間に，Strunk and Whiteによる名小冊子
\cite{strunk-and-white}を読むことを薦めるが，読まないのであれば，
少なくてもデータベース中のエントリと参考文献リストを見て，\BibTeX が複数の
名前をどう扱っているかを調べること\trnote{日本語対応版での漢字コード著者名の
扱い方についても調べること．}．

新たなスタイルを作る場合には，望みのものに近い既存のスタイルを修正する
のがよい\trnote{新たなスタイルを作る時だけでなく，既存のスタイルを
修正する時でも，直接{\tt .bst}ファイルを修正するのではなく{\tt btxbst.doc,
jbtxbst.doc}を修正する方が，再利用可能性が高くなる，運が良ければ1つの修正で
複数のスタイルを修正できる，などの利点がある．}．
これは古いスタイルを\BibTeX\ version 0.99用に修正する場合にもあてはまる．
(私自身が4つの非標準スタイルを修正した経験からの忠告である)．
古い(version 0.98i)スタイルのために作った関数を新しいスタイルファイルに
入れる時には，代入関数({\tt :=})の引数の順番が変更されたことに注意
しないといけない．
スタイルファイルが完成したら，{\tt XAMPL.BIB}データベースの全てを
使って\trnote{{\tt \char"5Cnocite\{*\}}で行える．}，標準エントリの全ての
型に対して望みの結果になることを確認すればよい．

標準スタイルの虫，やりたいことができない場合にはOren Patashnikに
文句を言うこと\trnote{日本語用のものについては
松井正一{\tt (matsui@denken.or.jp)}に知らせること．}．

\subsection{概要}

参考文献スタイルはスタックマシンに対する命令を後置演算子形式で記述する．
標準スタイルのドキュメントを見れば，どう書くかを知るのは難しいことでは
ないが，本稿ではもっと詳しく説明する(希望があればさらに詳しくする)．

基本的にはスタイルファイルは，
名前のない言語で，プログラムを記述することにより，
どのようにしてデータベースのエントリ
から参考文献リストを作るかを\BibTeX に教えるものである(日本語対応スタイル
では\JBibTeX に教えることである．以下\BibTeX に当てはまることは\JBibTeX にも
当てはまるので，いちいちことわらない)．
(以下では「エントリ」は「エントリ・リスト」のことであり，文脈から明らかな
場合には単に「リスト」とする)．
このプログラム言語には，次の細節(subsection)で説明する10個のコマンドがある．
これらのコマンドは言語のオブジェクト：定数，変数，関数，スタック，
エントリ・リストを操作するものである．
(注意：この文書中の用語は説明を簡単にするために選んだものであり，
\BibTeX 本来の用語とは若干異なる．例えばこの文書中の「変数」，「関数」
はどちらも\BibTeX にとっては関数である．\BibTeX のエラーメッセージを
解釈する時にはこのことを念頭におくこと)．

\BibTeX の関数には{\dg 組み込み}のもの(第\ref{built-in-fns}節で説明する)
と{\tt MACRO}か{\tt FUNCTION}で定義するものの2種類がある．

スタイル作成で最も時間のかかる作業は{\tt FUNCTION}コマンドを使って
関数を作成する，あるいは既存のものを変更することである．
(実際には，前述の参考文献に精通するのに要する時間の方が長いが，
それが終った後の話しである)．

例として関数の一部を取り出したものを見てみよう．
文字列型変数{\tt label}，整数型変数{\tt lab.width}があり，
{\tt label}の後ろにに`{\tt a}'を連結し，{\tt lab.width}を1増やしたいとしよう．
\begin{verbatim}
    .  .  .
    label "a" * 'label :=          % label := label * "a"
    lab.width #1 + 'lab.width :=   % lab.width := lab.width + 1
    .  .  .
\end{verbatim}
1行目で先ず{\tt label}はその値をスタックにプッシュする．
次に {\tt "a"} が文字列定数 `{\tt a}' をスタックに置く．
続いて組み込み関数 {\tt *} がスタックトップの2つの文字列をポップし，
それらを連結したものをプッシュする．
{\tt 'label}はその変数名をプッシュする．
最後に組み込み関数 {\tt :=} が変数名と連結結果をポップし，代入を
実行する．
\BibTeX はスタイルファイル中の {\tt \%} 以降はコメントとして扱う．
2行目も同様であるが，プッシュする整数定数
として`{\tt \#}'と`{\tt 1}'の間にスペースのない {\tt \#1} を使っている．

スペースの数はいくつでもよく，スペース，タブ，改行はいくつあっても
1つとみなされる(後で簡単に説明するように，
コマンドの途中では改行しないほうがよい)．

文字列定数としては，ダブルクォートで囲った中には印字可能文字なら
何を書いてもよい\trnote{日本語対応版では漢字コードでもよい．}．
文字列定数に限って\BibTeX は大文字と小文字の
区別をする．さらに文字列定数の中のスペースの数は意味が{\dg ある}．
また文字列定数は行をまたがってはならない(すなわち文字列の
始めと終りのダブルクォートは同じ行になければならない)．

変数，関数の名前は数字で始まってはならず，\LaTeX~bookの143ページに
ある10個の禁止文字を含んではならないが，それ以外の印字可能文字なら
何を使ってもよい\trnote{日本語対応版では漢字コードでもよい．日本語
プログラミングできる{\tt :-)}．}．
さらに(ASCIIコードの)大文字と小文字の区別はしない．

変数，定数の型としては整数型と文字列型しかない
(論理値は整数の0(偽)と1(真)として実現している)．
変数の種類としては3種類ある．
\begin{description}

\item[大域変数\hfill] {\tt INTEGERS}あるいは{\tt STRINGS}コマンドで宣言
された整数型あるいは文字列型の変数．

\item[エントリ変数\hfill] {\tt ENTRY}コマンドで宣言
された整数型あるいは文字列型の変数．エントリリストのエントリ毎に
別々の値を持つ(例えば{\tt label}にエントリのラベルを持たせることが
できる)．

\item[フィールド\hfill] 読みだし専用の文字列型の変数であり，データベースの
情報が格納される．値は{\tt READ}コマンドでデータベースが読み込まれる
ことで設定される．
エントリ変数同様に各々のエントリ毎に別々の値を持つ．
\end{description}


\subsection{コマンド}

10個のコマンドがある．
\hbox{\tt ENTRY}, \hbox{\tt FUNCTION}, \hbox{\tt INTEGERS},
\hbox{\tt MACRO}, \hbox{\tt STRINGS}の5個は変数の宣言，
関数の定義のためであり，
\hbox{\tt READ}はデータベースの情報を読み込み，
\hbox{\tt EXECUTE}, \hbox{\tt ITERATE}, \hbox{\tt REVERSE},
\hbox{\tt SORT})の4個はエントリを操作し，出力を作り出す．
すべてのコマンドを大文字で示したが，
\BibTeX はコマンド名の大文字と小文字の区別をしない．

いくつかの制限：{\tt ENTRY}と{\tt READ}の数は1つでなければらない．
{\tt ENTRY}コマンド, すべての{\tt MACRO}コマンド，{\tt FUNCTION}コマンド
のいくつか(次節{\tt call.type\$} 参照)は{\tt READ}コマンドの前に
なければならない．また{\tt READ}コマンドはエントリ操作，出力の
4つのコマンドより前になければならない．

(本質的ではないが)コマンドの間には1つ以上のブランク行を置き，
関数定義の中にはブランク行を置かないようにするとよい．
これによって\BibTeX の構文エラーからの回復を助けることができる．

コマンドの引数は中括弧(\verb|{ }|)に入れる．
本節で述べられていない構文に関する事項は標準ファイルのドキュメント\trnote{
{\tt btxbst.doc, jbtxbst.doc}のこと．}を参照されたい．
以下で10個のコマンドの説明を行う．

\begin{description}

\item[\hbox{\tt ENTRY}\hfill]
フィールドとエントリ変数を宣言する．
3引数であり，各々の引数は(空かもしれないが)変数名のリストである．
それらはフィールド，整数型のエントリ変数，文字列型のエントリ変数である．
また\BibTeX が相互参照で使うために自動的に宣言する
{\tt crossref}フィールドと，
{\tt SORT}コマンドで使うソートキーとして{\tt sort.key\$} が，文字列型の
エントリ変数として自動的に宣言される．
以上の変数はエントリ・リストのエントリ毎に別々の値を持つ．

\item[\hbox{\tt EXECUTE}\hfill]
関数を1つ実行する．引数は関数名1つである．

\item[\hbox{\tt FUNCTION}\hfill]
新たな関数を定義する．
2引数であり，最初が名前で2番目が定義である．
関数は使う前に定義しなければならない．したがって再帰関数は許されない．

\item[\hbox{\tt INTEGERS}\hfill]
整数型の大域変数を宣言する．
引数は変数名のリスト1つである．
文字列変数の長さを制限する大域的変数として{\tt entry.max\$} と
{\tt global.max\$} が自動的に宣言される．
このコマンドはスタイルファイル中にいくつあってもよいが，変数は使う前に
宣言しなければならない．

\item[\hbox{\tt ITERATE}\hfill]
現在のリストの順番にリストのエントリに対して1つの関数を実行する
(最初はリストは引用順に並んでいるが，{\tt SORT}によって順番は変わる)．
引数は関数名1つである．

\item[\hbox{\tt MACRO}\hfill]
文字列マクロを定義する．
引数は2つで，最初が変数名，関数名と同じように扱われるマクロ名で，
次がダブルクォートで囲まれた文字列であり，その定義である．
月名の3文字の省略形とよく使われる論文誌の省略形を定義しておくこと．
この定義は利用者のデータベース中の定義で置き換えることができるから，
利用者に変更してもらいたくないものは，同じ構文の{\tt FUNCTION}を
使って定義すればよい．

\item[\hbox{\tt READ}\hfill]
エントリ・リスト中のエントリのフィールドの値をデータベース
から探索して設定する．
引数はない．
データベース中のエントリに，対応するフィールドの値がない場合には
(必ずしもデータベース中にすべてのフィールドが書かれているわけではない)
そのフィールドの値には欠測値のマークが付く．

\item[\hbox{\tt REVERSE}\hfill]
{\tt ITERATE}コマンドとまったく同じことをエントリリストの逆順に実行する．

\item[\hbox{\tt SORT}\hfill]
文字列型のエントリ変数{\tt sort.key\$} を使ってエントリリストを
ソートする．
引数はない．

\item[\hbox{\tt STRINGS}\hfill]
文字列型の大域変数を宣言する．
引数は変数名のリスト1つである．
このコマンドはスタイルファイル中にいくつあってもよいが，変数は使う前に
宣言しなければならない．
\end{description}

\subsection{組み込み関数}
\label{built-in-fns}

組み込み関数の説明の前に，組み込みオブジェクトついて少し説明しておく．
組み込みのエントリ文字列変数として{\tt sort.key\$} があり，
ソートを行うスタイルでは値を設定しなければならない．
組み込みのフィールドとして，第4節で述べた相互参照機能のための
{\tt crossref}がある．
さらに整数型の大域変数
{\tt entry.max\$} と{\tt global.max\$} があり，その値は\BibTeX の内部定数
に設定されている．
\BibTeX から警告メッセージが出ないよう，
文字列への代入の前に，代入する文字列長をこれらの値より短くして
おかねばならない．

現在組み込み関数は37個ある\trnote{日本語対応版では，組み込み関数を1つ
追加しているので，38個ある．}．
すべての組み込み関数の名前は最後が `{\tt \$}' で終る．
以下では「1番目」，「2番目」というのはスタックからポップされた順番を意味する．
「リテラル」はスタックの要素であり，整数値，文字列，変数名，
関数名，あるいは欠測フィールドを表す特別の値のいずれかである．
ポップされたリテラルの型が誤っていると\BibTeX は文句をいった後，
関数の返す値の型に対応して，整数値の0あるいは空文字列をプッシュする．

\begin{description}

\item[\hbox{\tt >}\hfill]
2つの(整数)リテラルをポップし，比較を行い，2番目が1番目より大きければ1を
そうでなければ0をプッシュする．

\item[\hbox{\tt <}\hfill]
上と同様(小さければ)．

\item[\hbox{\tt =}\hfill]
スタックトップの(ともに整数あるいは文字列の) 2つのリテラルを
ポップして比較し，等しければ1を，そうでなければ0をプッシュする．

\item[\hbox{\tt +}\hfill]
(整数の)2つのリテラルをポップしその和をプッシュする．

\item[\hbox{\tt -}\hfill]
(整数の)2つのリテラルをポップしその差をプッシュする．
(2番目から1番目を引く)．

\item[\hbox{\tt *}\hfill]
2つの(文字列)リテラルをポップし，それらを連結したものをプッシュする
(逆順，2番目の後に1番目を連結する)．

\item[\hbox{\tt :=}\hfill]
2つのリテラルをポップし1番目(大域変数かエントリ変数)に2番目のリテラルの
値を代入する．

\item[\hbox{\tt add.period\$}\hfill]
スタックトップの(文字列)リテラルをポップし，`{\tt \}}' でない最後の文字が
`{\tt .}'$\!$, `{\tt ?}'$\!$, `{\tt !}'のいずれでもなければ
`{\tt .}'を最後に加えた結果をプッシュする．いずれかであれば元の文字列を
プッシュする．

{\dg \JBibTeX での注意}：
全角の`．'，`。'，`？'，`！'の後にも `{\tt .}' は加えない．

\item[\hbox{\tt call.type\$}\hfill]
その名前がエントリのエントリ型の名前である関数を実行する．
例えば，エントリの型が{\tt book}であれば{\tt book}という関数が実行される．
{\tt ITERATE}コマンドの引数として指定された場合には，{\tt call.type\$} は
エントリの情報を{\tt .bbl}ファイルに出力する．
不明なエントリ型(未定義の型)に対しては{\tt default.type}を実行する．
したがって各々の標準エントリ型に対応するもの以外に{\tt default.type}という型に
対応する関数を{\tt READ}コマンドの前に定義しておかねばならない．

\item[\hbox{\tt change.case\$}\hfill]
2つの(文字列)リテラルをポップし，1番目のリテラルの指定にしたがって，
以下に説明する形式で，2番目の文字列の大文字/小文字変換を行う
(注意：次文で「文字」とは中括弧のレベル0，最も外側の中括弧のレベルの文字の
ことであり，第4節で説明した「特殊文字」を除くそれ以外の文字は変換されない)．
1番目のリテラルが`{\tt t}'であれば，文字列の1番始めの文字およびコロンの後に
スペースが1個以上続く文字列の最初の文字はそのままで，それ以外を小文字に
変換する．
1番目のリテラルが`{\tt l}'であれば，すべての文字を小文字に変換する．
1番目のリテラルが`{\tt u}'であれば，すべての文字を大文字に変換する．
そして変換結果の文字列をプッシュする．
2つのリテラルの型が文字列型でない場合には文句を言い，空文字列をプッシュする．
リテラルの型は合っているが，変換指定が上記の何れでもない場合には，文句を
付けた後，単に2番目の文字列をそのままの形でプッシュする
(もう1つの注意：変換指定文字の大文字/小文字は区別されない．すなわち
{\tt t}と{\tt T}は同じものとされる)．

\item[\hbox{\tt chr.to.int\$}\hfill]
スタックトップの(文字列)リテラルをポップし，その長さが1文字であること
を確認した後，そのASCIIコードの整数をプッシュする．

{\dg \JBibTeX での注意}：
漢字コード文字に対応するために，リテラルが漢字コード文字の場合には
2バイトを1文字と数え，値としては1バイト目のコード値(EUCコード値)を
プッシュする．ただし
これは\JBibTeX\ version 0.10との互換性のために残したものであり，仕様変更
される可能性が高い．

\item[\hbox{\tt cite\$}\hfill]
エントリに対応する{\verb|\cite|}コマンドの引数の文字列をプッシュする．

\item[\hbox{\tt duplicate\$}\hfill]
スタックトップのリテラルをポップしそのコピーを2つプッシュする．

\item[\hbox{\tt empty\$}\hfill]
スタックトップのリテラルをポップし，それが欠測フィールドであるか，あるいは
文字列中に空白文字以外が無い場合に，整数の1をプッシュし，それ以外の場合には
0をプッシュする．

\item[\hbox{\tt format.name\$}\hfill]
スタックトップの3つのリテラル(順に文字列，整数，文字列)をポップする．
最後の文字列リテラルが名前リスト(要素が個人名に対応)であり，整数リテラルが
リストの何番目を取り出すのかの指定であり，最初の文字列リテラルが名前を
どの様にフォーマットするのか(次節で説明する)の指定である．
フォーマットされた名前の文字列をプッシュする．

{\dg \JBibTeX での注意}：
この関数では全角のスペースは半角のスペースと同じとみなす(より正確に
いうと全角のスペースは半角のスペースに変換されて処理される)．また，全角の
句点 ``，'' と ``、'' も ``\verb*| and |'' と同様に扱うので，
漢字コード氏名は句点で区切って並べることができる．


\item[\hbox{\tt if\$}\hfill]
3つのリテラル(順に2つの関数リテラル，整数リテラル)をポップし，
最後のリテラル値の整数値が0より大きい時には2番目のリテラルを実行し，
そうでなければ1番目のリテラルを実行する．

\item[\hbox{\tt int.to.chr\$}\hfill]
スタックトップの(整数)リテラルをポップし，それをASCIIコードとして，
対応する文字を1文字の文字列に変換したものをプッシュする．

\item[\hbox{\tt int.to.str\$}\hfill]
スタックトップの(整数)リテラルをポップし，それを(一意に定まる)文字列に
変換してプッシュする．

\item[\hbox{\tt missing\$}\hfill]
スタックトップをポップし，それが欠測フィールドであれば整数の1を，そうで
なければ0をプッシュする．

\item[\hbox{\tt newline\$}\hfill]
出力バッファに蓄積されている情報を{\tt bbl}ファイルに書き出す．
出力バッファが空である場合に限り空行を書き出す．
{\tt write\$} は適当に改行を行なうから，空行を書き出す時，あるいは
明示的に改行したい時だけに，この関数を使うのがよい．

\item[\hbox{\tt num.names\$}\hfill]
スタックトップの(文字列)リテラルをポップし文字列中の名前の数，
すなわち，大文字/小文字を無視して，中括弧のレベル0の位置にあり，前後が
空白文字である``and''部分文字列の数に1を加えた値，
をプッシュする．

{\dg \JBibTeX での注意}：
この関数では全角のスペースは半角のスペースと同じとみなす(より正確に
いうと全角のスペースは半角のスペースに変換されて処理される)．また，全角の
句点 ``，'' と ``、'' も ``\verb*| and |'' と同様に扱うので，
漢字コード氏名は句点で区切って並べることができる．

\item[\hbox{\tt pop\$}\hfill]
スタックトップをポップするがプリントはしない．不必要なリテラルを
取り除くのに使う．

\item[\hbox{\tt preamble\$}\hfill]
データベースファイルから読み込んだ{\tt @PREAMBLE}すべてを連結した文字列を
プッシュする．

\item[\hbox{\tt purify\$}\hfill]
スタックトップの(文字列)リテラルをポップし，
空白文字，ハイフン`\verb|-|'とタイ`\verb|~|'
(これらはスペースに変換される)のいずれでもないアルファベット
以外の文字，「特殊文字」に付随した制御文字列(コマンド; control sequence)に
含まれるアルファベット文字を除去した文字列をプッシュする\trnote{漢字コード
文字列なら変化しない．}．

\item[\hbox{\tt quote\$}\hfill]
ダブルクォート文字(`\verb|"|')1文字からなる文字列をプッシュする．

\item[\hbox{\tt skip\$}\hfill]
何もしない．

\item[\hbox{\tt stack\$}\hfill]
スタックの内容を全部ポップしてプリントする．スタイル作成時のデバッグ用．

\item[\hbox{\tt substring\$}\hfill]
スタックトップの3つのリテラル(順に長さ{\it len}，開始位置{\it start}の
2つの整数リテラル，文字列リテラル)をポップする．
{\it start}が正ならば文字列の先頭から数えて，
(最初が1文字目として){\it start}文字目からの，
{\it start}が負ならば文字列の終りから数えて(最後の文字が1文字目として)，
$-${\it start}文字目からの，
連続する(高々){\it len}文字の部分文字列をプッシュする．

{\dg \JBibTeX での注意}：
この関数は1文字は1バイトからなるものとして処理するので，漢字コード
文字列では指定した
文字数の半分の数の漢字コード
が得られる．また漢字コードの1文字の間で切られないように
開始位置，文字数(バイト数)の調整を行なう．調整は開始位置が漢字コードの1バイト目
に一致していれば．開始位置はそのまま，2バイト目であれば1バイト目から取り出す
ように調整する．終了位置が漢字コードの1バイト目であれば2バイト目まで取り出す
ように調整する．したがって指定した長さより最大2バイト長い文字列となる．
これは日本語用でないスタイルファイルを使った場合でもそれなりの出力が得られる
ようにするためである．

\item[\hbox{\tt swap\$}\hfill]
スタックトップの2つのリテラルの順序を入れ替える．

\item[\hbox{\tt text.length\$}\hfill]
スタックトップの(文字列)リテラルをポップし，
アクセント付き文字(正確には第4節で定義されている「特殊文字」)は，
(対応する右中括弧が欠けていても)，
1文字として数えた時の文字数をプッシュする．

{\dg \JBibTeX での注意}：
漢字コード1文字は2文字と数える．

\item[\hbox{\tt text.prefix\$}\hfill]
2つのリテラル(順に整数リテラル{\it len}，文字列リテラル)をポップし，
文字列の先頭から(高々){\it len}文字の連続した文字列をプッシュする．
{\tt substring\$} に似ているが，この関数では，「特殊文字」は
対応する右中括弧が欠けていても，複数のASCII文字から構成されていても，
1文字として数える．

{\dg \JBibTeX での注意}：
この関数では特殊文字以外の文字は，1文字は1バイトからなるものとして
処理するので，漢字コード文字列では指定した文字数の半分の数の漢字からなる
文字列が得られる．
また漢字コードの1文字の間で切られないように，終了位置が漢字コードの
1バイト目であれば2バイト目まで取り出すように調整する．
したがって指定した長さより最大1バイト長い文字列となる．
これは日本語用でないスタイルファイルを使った場合でもそれなりの出力が得られる
ようにするためである(例えば{\tt alpha}ではラベルを著者名の姓の先頭3文字
を用いて作成するが，漢字コードの中間で終らないように2文字にしてしまうと
情報量が少なくなる，また漢字コードは特殊文字と考えて処理するとラベルが長く
なり過ぎるのでこのような仕様とした)．

\item[\hbox{\tt top\$}\hfill]
スタックトップをポップしその内容を端末とログファイル{\tt blg}にプリントする．
デバッグに役立つ．

\item[\hbox{\tt type\$}\hfill]
現在のエントリの型({\tt book, article}など)の文字列をプッシュする．
知らない型あるいは未定義の型であれば空文字列をプッシュする．

\item[\hbox{\tt warning\$}\hfill]
スタックトップの(文字列型)リテラルをポップし，
警告メッセージであることを示してプリントする．
また，出力した警告メッセージの数を1増やす．

\item[\hbox{\tt while\$}\hfill]
2つの(関数)リテラルをポップし，最初の関数を実行した結果であるスタックトップ
の値が0より大きい間，2番目の関数を繰返し実行する．

\item[\hbox{\tt width\$}\hfill]
スタックトップの(文字列型)リテラルをポップし，その印字幅をある相対単位に
基づいて計算した整数値をプッシュする
(現在は1987年6月バージョンの$cmr10$フォントに基づいて，1/100ポイントを
1として計算する\trnote{漢字コードの幅情報は正確でないので注意が必要．})．
この関数は文字列を文字通りに扱う，すなわち，(対応する右中括弧が欠けていても)
「特殊文字」は特別に扱う以外は，
たとえある文字が\TeX で特別な意味を持っていても，
文字はそのままの形でプリントされるものとして幅を計算する．
ラベル文字列の幅を比較するためのものである．

\item[\hbox{\tt write\$}\hfill]
スタックトップの(文字列)リテラルをポップし，出力バッファに書き出す(その結果，
バッファが一杯になれば{\tt bbl}ファイルにも書き出される)．

\item[\hbox{\tt is.kanji.str\$}\hfill]
\JBibTeX のみで定義されている組込み関数であり，
スタックトップの(文字列)リテラルをポップし，文字列中に日本語文字(全角文字)が
含まれていれば(整数の)1を，そうでなければ0をプッシュする．

\end{description}

組込み関数{\tt while\$} と{\tt if\$} ではスタック上に2つの関数リテラルが
必要である．
これらは関数名の前にシングルクォートを付けるか，
{\tt FUNCTION}コマンドを使って関数を定義したくなければ，その定義を
({\tt FUNCTION}コマンドの2番目の引数を中括弧で囲んで)そのまま書けばよい．
例えば次に示す関数の一部分は，{\tt label}が空文字列でなければ，
その最後に文字`{\tt a}'を付け加える．

\begin{verbatim}
    .  .  .
    label "" =
      'skip$
      { label "a" * 'label := }
    if$
    .  .  .
\end{verbatim}

名前をクォートする関数は，{\tt skip\$} のような組込み関数である必要はなく，
例えば，フィールドでも，自分で定義した関数でもよい．


\subsection{名前のフォーマット}

名前には何が入っているのか? これについては第4節で少し詳しく説明した．
名前は「名(first)」パート, vonパート, 「姓(last)」パートとJrパートから
なり，それぞれは名前トークンのリストからなり，それぞれのパートは
空かもしれないが，名前が空でなければ姓パートは必ず空ではない．
この小節では組込み関数の{\tt format.name\$} に指定するフォーマット指定文字
を説明する．

例として，非常に長い名前を考えてみよう．
データベースのエントリ~\cite{prime-number-theorem}に次のフィールドが
あるとしよう．
\begin{verbatim}
  author = "Charles Louis Xavier Joseph de la Vall{\'e}e Poussin"
\end{verbatim}
また「姓 カンマ イニシャル」(``last name comma initials'')の順で名前を
フォーマットしたいとしよう．
次のようなフォーマット指定文字列を使うと，
\begin{verbatim}
    "{vv~}{ll}{, jj}{, f}?"
\end{verbatim}
\BibTeX はフォーマットされた文字列として次を作り出す．
\begin{verbatim}
    de~la Vall{\'e}e~Poussin, C.~L. X.~J?
\end{verbatim}

この例をもっと詳しく見てみよう．
このフォーマット指定文字列には，名前のそれぞれの構成要素に
対応する，中括弧レベルが1の4つの{\dg 断片}({\em pieces\/})がある．
対応する構成要素がなければ(この名前ではJr要素)，その断片の中のすべてが
無視される．
中括弧のレベル0にあるものは(この例では，たぶんタイプミスであろうが，
`{\tt ?}'の文字は)そのままの形で出力されるが，
この機能はあまり使わないであろう．

フォーマット指定の部分中では二重文字(double letter)は
構成要素のすべてを使うことを，
単文字(single letter)は省略形にしたものを使うことを\BibTeX に指定する．
これらの指定文字は中括弧のレベル1になければならず，それ以外の文字は(
後で説明してある文字以外のほとんどすべての文字は)そのままの形で使われる．
vonパートの最後にあるタイ(\verb|~|)は任意タイであり，\BibTeX が必要と判断
した場合にのみ出力され，そうでなければスペースとして出力される．
本当にタイを出力したいのであれば2つ書いておけば，つまり{\verb|{vv~~}|}と
しておけば(1つだけ)出力される．
断片の最後の文字であるタイは任意タイとされるが，それ以外は通常の
文字として扱われる．

\BibTeX は名前トークンの{\dg 間に}デフォールトの区切り文字列を書き出す．
これはスペースかタイのどちらか適した方，あるいは省略形トークンでは
ピリオドの後にスペースかタイの適した方を付けたものである．
しかしフォーマット指定の最後のトークンの後には
デフォールト区切り文字列を書き出さないから，
先の例で言えば`J'の後にはピリオドは付かない．
したがって次のように指定して，
\begin{verbatim}
    "{vv~}{ll}{, jj}{, f.}"
\end{verbatim}
前の出力例の疑問符をピリオドに置き換えたフォーマット結果を得ることができる．
名前に「名」パートがない場合に対応するように，ピリオドは
疑問符の位置でなく「名」断片の中に置かねばならないことに注意しよう．

\BibTeX のデフォールトの区切り文字を置き換えたいのなら，明示的に指定
する必要がある．
例えばvonパートと姓パートのすべてのトークンの先頭文字を，間にスペースを
置かずに連結したラベルを作りたいのであれば，
次のように指定しなければならない．
\begin{verbatim}
    "{v{}}{l{}}"
\end{verbatim}
こうすればフォーマット結果の文字列として`{\tt dlVP}'が得られる．
置き換えたいすべての部分毎に指定が必要であり(この例では両方に空文字列が
指定されている)，指定は単文字，二重文字のすぐ後になければならない．
フォーマット指定文字列の中括弧のレベル1の中では，
以上で述べた文字以外を書くことはできない．

{\dg\noindent\JBibTeX での注意点}：

\begin{itemize}
\item  漢字コード表記された名前では，姓と名の間に
スペース(半角でも全角でも)を入れておけば，`{\tt f}'はFamily name(姓)に，
`{\tt l}'はLast-token(名)に対応することになるので，通常の
表記順に名前が書ける．しかしスタイルの作成では注意が必要である．
これは{\tt format.name\$} を完全な日本語対応版としていないからであるが，
実際に日本語対応のスタイルファイルを作成した経験からいうと，漢字コード表記
された名前とそれ以外の名前に対して，同じフォーマット指定で
{\tt format.name\$} を呼び出すことは殆どないので，あえてこのままに
してある．しかし混乱の種かもしれない．

\item {\tt jabbrv}で姓のみを出力できるようになどの目的で，
\JBibTeX\ ver. 0.20以降では
姓と名の間にスペース(半角でも全角でも)を置くことを標準としている．
しかしスペースがない場合にも結果がおかしくならないように，フォーマット指定
には注意が必要である．例えば日本語スタイルの中では次のようなコーディングを
行なっている．

{\baselineskip=11pt
\begin{verbatim}
editor is.kanji.str$                            % 漢字コードの編集者?
     {editor #1 "{ff}" format.name$ duplicate$  % 姓を取り出す
       empty$                                   % 空?(姓と名の間に空白がない)
          {pop$ editor #1 "{ll}" format.name$}  % Last tokenを取り出す
          'skip$                                % noop
       if$
     }
     {editor #1 "{vv~}{ll}" format.name$}       % 英文編集者
if$
\end{verbatim}
}
\end{itemize}

\subsection{\JBibTeX の標準スタイル}

\JBibTeX の標準スタイルとしては{\tt plain, alpha, abbrv, unsrt}に対応して
{\tt jplain, jalpha,jabbrv,\linebreak junsrt}が作成されている．
さらに情報処理学会論文誌{\tt tipsj}，情報処理学会欧文論文誌{\tt jipsj}，
電子通信学会論文誌{\tt tieic}，日本オペレーションズリサーチ学会論文誌
{\tt jorsj}，人工知能学会誌{\tt jsai}，ソフトウェア科学会誌{\tt jssst}用の
スタイルも作成されている．これらのスタイルで
行なっている日本語対応の主な変更は以下の通りである．詳しくは{\tt jbtxbst.doc}
を参照されたい．

\begin{enumerate}
\item 著者名が日本語かどうかを{\tt is.kanji.str\$} を使って判定し，
名前のフォーマットの方法を変える．

\item 著作名に日本語が含まれる場合には強調指定を付けない．

\item ページ範囲指定を{\tt Pages}から{\tt pp.\ }に変更した．

\item {\tt yomi}フィールドがあれば，その情報をソーティングキーを作る時に
著者名，編集者名の代りに使う．
\end{enumerate}

\baselineskip=16pt
\bibliography{jbtxdoc}
\bibliographystyle{jalpha}
\end{document}
