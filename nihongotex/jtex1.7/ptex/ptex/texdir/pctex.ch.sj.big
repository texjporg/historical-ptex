% pTeX change file for ASCII Kanji UNIX. (Shift JIS code only)
%	by Ryoichi Kurasawa   (ryoi-k@ascii.co.jp)
%	   Hisato  Hamano   (hisato-h@ascii.co.jp), ASCII corporation.

% Change file for TeX in C, derived from various other change files
% by Tim Morgan, UC Irvine ICS Department, and many others

% Modification History:
%
% (5 /28/86) ETM Started with TeX 2.0
% (7 /3/87)  ETM Brought up to TeX 2.2
% (9 /26/87) ETM Brought up to TeX 2.3
% (10/1/87)  ETM Brought up to TeX 2.5
% (12/21/87) ETM Brought up to TeX 2.7
% (1 /14/88) ETM Brought up to TeX 2.9
%	> (??/??/87) RKS jTeX 2.9 -- j1.0
% (2 /20/88) PAM Revised format and module numbers
% (3 /1 /88) ETM Eliminated some unused variables and unnecesary tests
% (5 /9 /88) ETM Added yet another casting bug fix
% (6 /21/88) ETM Brought up to TeX version 2.93
%	> (??/??/89) RKS jTeX 2.93 -- j1.3
%	>> (12/ 9/89) H_2 pTeX 2.93 j1.3 p1.0.1
% (12/11/88) ETM Brought up to TeX version 2.94
% (1 /12/89) PAM Brought up to TeX version 2.95
%	> (12/??/89) RKS jTeX 2.95 -- j1.5
% (2 /14/89) ETM Brought up to TeX version 2.96
% (3 /10/89) ETM Brought up to TeX version 2.98
% (6 /22/89) PAM Brought up to TeX version 2.99
%	> (12/??/89) RKS jTeX 2.99 -- j1.5
%	> ( 2/ 2/90) RKS jTeX 2.99 -- j1.6
%	>> ( 4/16/90) H_2 pTeX 2.99 j1.6 p1.0.3
%	>> ( 9/14/90) H_2 pTeX 2.99 j1.6 p1.0.9 -- pre-release
%	>> (10/29/90) H_2 Bug fix (p1.0.9a)
%	> ( 1/21/92) H_2 jTeX 2.99 - j1.7
%	>> ( 1/21/92) H_2 pTeX 2.99 j1.7 p1.0.9F

% NOTE: the module numbers in this change file refer to the published
%	text in TeX, the Program, Volume B. 1986

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [0] WEAVE: only print changes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x Tell WEAVE to print only the changes:
  \def\?##1]{\hbox to 1in{\hfil##1.\ }}
  }
@y
  \def\?##1]{\hbox{Changes to \hbox to 1em{\hfil##1}.\ }}
  }
\let\maybe=\iffalse
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.2] banner line
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d banner=='This is TeX, Version 2.99' {printed when \TeX\ starts}
@y
@d banner=='This is PTeX, C Version 2.99 j1.7 p1.0.9F'
	{printed when \TeX\ starts}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.4] program header
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
Actually the heading shown here is not quite normal: The |program| line
does not mention any |output| file, because \ph\ would ask the \TeX\ user
to specify a file name if |output| were specified here.
@^system dependencies@>

@d mtype==t@&y@&p@&e {this is a \.{WEB} coding trick:}
@f mtype==type {`\&{mtype}' will be equivalent to `\&{type}'}
@f type==true {but `|type|' will not be treated as a reserved word}

@p @t\4@>@<Compiler directives@>@/
program TEX; {all file names are defined dynamically}
label @<Labels in the outer block@>@/
@y

@d mtype==t@&y@&p@&e {this is a \.{WEB} coding trick:}
@f mtype==type {`\&{mtype}' will be equivalent to `\&{type}'}
@f type==true {but `|type|' will not be treated as a reserved word}

@p @t\4@>@<Compiler directives@>@/
program TEX; {all file names are defined dynamically}
@z

@x
@<Labels in the out...@>=
start_of_TEX@t\hskip-2pt@>, end_of_TEX@t\hskip-2pt@>,@,final_end;
  {key control points}
@y
@<Labels in the outer block@>=
start_of_TEX@t\hskip-2pt@>, end_of_TEX@t\hskip-2pt@>,@,final_end;
  {key control points}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.7] debug..gubed, stat..tats
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Here we change these WEB symbols, which are used much as #ifdef's
% in C, into something which will get translated into actual #ifdef's.
@x
@d debug==@{ {change this to `$\\{debug}\equiv\null$' when debugging}
@d gubed==@t@>@} {change this to `$\\{gubed}\equiv\null$' when debugging}
@y
@d debug==ifdef('DEBUG')
@d gubed==endif('DEBUG')
@z
@x
@d stat==@{ {change this to `$\\{stat}\equiv\null$' when gathering
  usage statistics}
@d tats==@t@>@} {change this to `$\\{tats}\equiv\null$' when gathering
  usage statistics}
@y
@d stat==ifdef('STAT')
@d tats==endif('STAT')
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.8] init..tini
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d init== {change this to `$\\{init}\equiv\.{@@\{}$' in the production version}
@d tini== {change this to `$\\{tini}\equiv\.{@@\}}$' in the production version}
@y
@d init==ifdef('INITEX')
@d tini==endif('INITEX')
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.9] compiler directives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@{@&$C-,A+,D-@} {no range check, catch arithmetic overflow, no debug overhead}
@!debug @{@&$C+,D+@}@+ gubed {but turn everything on when debugging}
@y
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%l[1.11] compile-time constants, use logical names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% doubled mem_max for C since UCI people are memory hogs
% made dvi_buf_size=2*8192 for better BSD Unix I/O performance
% enlarged various other datastructures
@x
@!mem_max=30000; {greatest index in \TeX's internal |mem| array;
  must be strictly less than |max_halfword|;
  must be equal to |mem_top| in \.{INITEX}, otherwise |>=mem_top|}
@!mem_min=0; {smallest index in \TeX's internal |mem| array;
  must be |min_halfword| or more;
  must be equal to |mem_bot| in \.{INITEX}, otherwise |<=mem_bot|}
@!buf_size=500; {maximum number of characters simultaneously present in
  current lines of open files and in control sequences between
  \.{\\csname} and \.{\\endcsname}; must not exceed |max_halfword|}
@!error_line=72; {width of context lines on terminal error messages}
@!half_error_line=42; {width of first lines of contexts in terminal
  error messages; should be between 30 and |error_line-15|}
@!max_print_line=79; {width of longest text lines output; should be at least 60}
@!stack_size=200; {maximum number of simultaneous input sources}
@!max_in_open=6; {maximum number of input files and error insertions that
  can be going on simultaneously}
@!font_max=75; {maximum internal font number; must not exceed |max_quarterword|
  and must be at most |font_base+256|}
@!font_mem_size=20000; {number of words of |font_info| for all fonts}
@!param_size=60; {maximum number of simultaneous macro parameters}
@!nest_size=40; {maximum number of semantic levels simultaneously active}
@!max_strings=3000; {maximum number of strings; must not exceed |max_halfword|}
@!string_vacancies=8000; {the minimum number of characters that should be
  available for the user's control sequences and font names,
  after \TeX's own error messages are stored}
@!pool_size=32000; {maximum number of characters in strings, including all
  error messages and help texts, and the names of all fonts and
  control sequences; must exceed |string_vacancies| by the total
  length of \TeX's own strings, which is currently about 23000}
@!save_size=600; {space for saving values outside of current group; must be
  at most |max_halfword|}
@!trie_size=8000; {space for hyphenation patterns; should be larger for
  \.{INITEX} than it is in production versions of \TeX}
@!dvi_buf_size=800; {size of the output buffer; must be a multiple of 8}
@!file_name_size=40; {file names shouldn't be longer than this}
@!pool_name='TeXformats:TEX.POOL                     ';
  {string of length |file_name_size|; tells where the string pool appears}
@y
@!mem_max=262140; {greatest index in \TeX's internal |mem| array;
  must be strictly less than |max_halfword|;
  must be equal to |mem_top| in \.{INITEX}, otherwise |>=mem_top|}
@!mem_min=0; {smallest index in \TeX's internal |mem| array;
  must be |min_halfword| or more;
  must be equal to |mem_bot| in \.{INITEX}, otherwise |<=mem_bot|}
@!buf_size=4096; {maximum number of characters simultaneously present in
  current lines of open files and in control sequences between
  \.{\\csname} and \.{\\endcsname}; must not exceed |max_halfword|}
@!error_line=79; {width of context lines on terminal error messages}
@!half_error_line=50; {width of first lines of contexts in terminal
  error messages; should be between 30 and |error_line-15|}
@!max_print_line=79; {width of longest text lines output; should be at least 60}
@!stack_size=300; {maximum number of simultaneous input sources}
@!max_in_open=15; {maximum number of input files and error insertions that
  can be going on simultaneously}
@!font_max=255; {maximum internal font number; must not exceed |max_quarterword|
  and must be at most |font_base+256|}
@!font_mem_size=72000; {number of words of |font_info| for all fonts}
@!param_size=60; {maximum number of simultaneous macro parameters}
@!nest_size=40; {maximum number of semantic levels simultaneously active}
@!max_strings=7500; {maximum number of strings; must not exceed |max_halfword|}
@!string_vacancies=75000; {the minimum number of characters that should be
  available for the user's control sequences and font names,
  after \TeX's own error messages are stored}
@!pool_size=100000; {maximum number of characters in strings, including all
  error messages and help texts, and the names of all fonts and
  control sequences; must exceed |string_vacancies| by the total
  length of \TeX's own strings, which is currently about 23000}
@!save_size=4000; {space for saving values outside of current group; must be
  at most |max_halfword|}
@!trie_size=8000; {space for hyphenation patterns; should be larger for
  \.{INITEX} than it is in production versions of \TeX}
@!dvi_buf_size=16384; {size of the output buffer; must be a multiple of 8}
@!file_name_size=1024; {file names shouldn't be longer than this}
@!pool_name='ptex.pool';
  {string of length |file_name_size|; tells where the string pool appears}
@!mem_top=262140; {largest index in the |mem| array dumped by \.{INITEX};
  must be substantially larger than |mem_bot|
  and not greater than |mem_max|}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%l[1.12] sensitive compile-time constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% For C we change mem_base and hi_mem_base to reflect our use of
% 0-origin vs pc's use of negative-origin.  Despite the fact that
% these are "sensitive" constants, we're going to make mem_top a
% #define in the C code for readability and ease of modification
% (it's up above).  Beware!
@x
@d mem_bot=0 {smallest index in the |mem| array dumped by \.{INITEX};
  must not be less than |mem_min|}
@d mem_top==30000 {largest index in the |mem| array dumped by \.{INITEX};
  must be substantially larger than |mem_bot|
  and not greater than |mem_max|}
@d font_base=0 {smallest internal font number; must not be less
  than |min_quarterword|}
@d hash_size=2100 {maximum number of control sequences; it should be at most
  about |(mem_max-mem_min)/10|, but 2100 is already quite generous}
@d hash_prime=1777 {a prime number equal to about 85\% of |hash_size|}
@d hyph_size=307 {another prime; the number of \.{\\hyphenation} exceptions}
@y
@d mem_bot=0 {smallest index in the |mem| array dumped by \.{INITEX};
  must not be less than |mem_min|}
@d font_base=0 {smallest internal font number; must not be less
  than |min_quarterword|}
@d hash_size=9500 {maximum number of control sequences; it should be at most
  about |(mem_max-mem_min)/10|, so we can be really generous}
@d hash_prime=7919 {The thousandth in a list of 1000 primes.  Run the primes
  program in LiterateProgramming to find out.  It is reasonably close to
  85\% of a |hash_size| of 9500}
@d hyph_size=607 {another prime; the number of \.{\\hyphenation} exceptions}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [1.16] Use C macros for incr()/decr()
%j[1.16] incr2()/decr2()
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% By not defining these, they slip through into the C code, where we
% may be able to generate more efficient code.
% ‘ã‚è‚ÉAincr2/decr2 ‚ð’è‹`‚·‚éB
@x
@d incr(#) == #:=#+1 {increase a variable by unity}
@d decr(#) == #:=#-1 {decrease a variable by unity}
@y
@d incr2(#) == #:=#+2
@d decr2(#) == #:=#-2
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [2.18] ASCII code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Unix really deals in 8-bit characters
@x
@ Characters of text that have been converted to \TeX's internal form
are said to be of type |ASCII_code|, which is a subrange of the integers.

@<Types...@>=
@!ASCII_code=0..127; {seven-bit numbers}

@ The original \PASCAL\ compiler was designed in the late 60s, when six-bit
@y
@ Characters of text that have been converted to \TeX's internal form
are said to be of type |ASCII_code|, which is a subrange of the integers.

@<Types...@>=
@!ASCII_code=0..255; {eight-bit numbers}
@!xchar=ASCII_code;

@ The original \PASCAL\ compiler was designed in the late 60s, when six-bit
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [2.19] first and last text char
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d text_char == char {the data type of characters in text files}
@d first_text_char=0 {ordinal number of the smallest element of |text_char|}
@d last_text_char=127 {ordinal number of the largest element of |text_char|}
@y
@d text_char == xchar {the data type of characters in text files}
@d first_text_char=0 {ordinal number of the smallest element of |text_char|}
@d last_text_char=255 {ordinal number of the largest element of |text_char|}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [2.20][2.21] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Glob...@>=
@!xord: array [text_char] of ASCII_code;
  {specifies conversion of input characters}
@!xchr: array [ASCII_code] of text_char;
  {specifies conversion of output characters}
@y
@<Glob...@>=
@z

@x
@<Set init...@>=
xchr[@'40]:=' ';
xchr[@'41]:='!';
xchr[@'42]:='"';
xchr[@'43]:='#';
xchr[@'44]:='$';
xchr[@'45]:='%';
xchr[@'46]:='&';
xchr[@'47]:='''';@/
xchr[@'50]:='(';
xchr[@'51]:=')';
xchr[@'52]:='*';
xchr[@'53]:='+';
xchr[@'54]:=',';
xchr[@'55]:='-';
xchr[@'56]:='.';
xchr[@'57]:='/';@/
xchr[@'60]:='0';
xchr[@'61]:='1';
xchr[@'62]:='2';
xchr[@'63]:='3';
xchr[@'64]:='4';
xchr[@'65]:='5';
xchr[@'66]:='6';
xchr[@'67]:='7';@/
xchr[@'70]:='8';
xchr[@'71]:='9';
xchr[@'72]:=':';
xchr[@'73]:=';';
xchr[@'74]:='<';
xchr[@'75]:='=';
xchr[@'76]:='>';
xchr[@'77]:='?';@/
xchr[@'100]:='@@';
xchr[@'101]:='A';
xchr[@'102]:='B';
xchr[@'103]:='C';
xchr[@'104]:='D';
xchr[@'105]:='E';
xchr[@'106]:='F';
xchr[@'107]:='G';@/
xchr[@'110]:='H';
xchr[@'111]:='I';
xchr[@'112]:='J';
xchr[@'113]:='K';
xchr[@'114]:='L';
xchr[@'115]:='M';
xchr[@'116]:='N';
xchr[@'117]:='O';@/
xchr[@'120]:='P';
xchr[@'121]:='Q';
xchr[@'122]:='R';
xchr[@'123]:='S';
xchr[@'124]:='T';
xchr[@'125]:='U';
xchr[@'126]:='V';
xchr[@'127]:='W';@/
xchr[@'130]:='X';
xchr[@'131]:='Y';
xchr[@'132]:='Z';
xchr[@'133]:='[';
xchr[@'134]:='\';
xchr[@'135]:=']';
xchr[@'136]:='^';
xchr[@'137]:='_';@/
xchr[@'140]:='`';
xchr[@'141]:='a';
xchr[@'142]:='b';
xchr[@'143]:='c';
xchr[@'144]:='d';
xchr[@'145]:='e';
xchr[@'146]:='f';
xchr[@'147]:='g';@/
xchr[@'150]:='h';
xchr[@'151]:='i';
xchr[@'152]:='j';
xchr[@'153]:='k';
xchr[@'154]:='l';
xchr[@'155]:='m';
xchr[@'156]:='n';
xchr[@'157]:='o';@/
xchr[@'160]:='p';
xchr[@'161]:='q';
xchr[@'162]:='r';
xchr[@'163]:='s';
xchr[@'164]:='t';
xchr[@'165]:='u';
xchr[@'166]:='v';
xchr[@'167]:='w';@/
xchr[@'170]:='x';
xchr[@'171]:='y';
xchr[@'172]:='z';
xchr[@'173]:='{';
xchr[@'174]:='|';
xchr[@'175]:='}';
xchr[@'176]:='~';@/
xchr[0]:=' '; xchr[@'177]:=' ';
  {ASCII codes 0 and |@'177| do not appear in text}
@y
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [2.23][2.24] form-feed and tab are legal characters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@^character set dependencies@>
@^system dependencies@>

@<Set init...@>=
for i:=1 to @'37 do xchr[i]:=' ';
@y
@^character set dependencies@>
@^system dependencies@>

@<Set init...@>=
@z

@x
@<Set init...@>=
for i:=first_text_char to last_text_char do xord[chr(i)]:=invalid_code;
for i:=1 to @'176 do xord[xchr[i]]:=i;
@y
@<Set init...@>=
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.25] file types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
The program actually makes use also of a third kind of file, called a
|word_file|, when dumping and reloading base information for its own
initialization.  We shall define a word file later; but it will be possible
for us to specify simple operations on word files before they are defined.

@y
I/O in C is done using standard I/O.  We will define the path numbers
in an include file for C which are used in searching for files to be
read.  We'll define all the file types in C also.
@z

@x
@!alpha_file=packed file of text_char; {files that contain textual data}
@!byte_file=packed file of eight_bits; {files that contain binary data}
@y
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.23] add real_name_of_file array
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
is crucial for our purposes. We shall assume that |name_of_file| is a variable
of an appropriate type such that the \PASCAL\ run-time system being used to
implement \TeX\ can open a file whose external name is specified by
|name_of_file|.
@^system dependencies@>

@<Glob...@>=
@!name_of_file:packed array[1..file_name_size] of char;@;@/
  {on some systems this may be a \&{record} variable}
@!name_length:0..file_name_size;@/{this many characters are actually
  relevant in |name_of_file| (the rest are blank)}
@y
is crucial for our purposes. We shall assume that |name_of_file| is a variable
of an appropriate type such that the \PASCAL\ run-time system being used to
implement \TeX\ can open a file whose external name is specified by
|name_of_file|.
The Berkeley {\mc UNIX} version uses search paths to look for files to open.
We use |real_name_of_file| to hold the |name_of_file| with a directory
name from the path in front of it.
@^system dependencies@>

@<Glob...@>=
@!name_of_file,@!real_name_of_file:packed array[1..file_name_size] of char;
@;@/
@!name_length:0..file_name_size;@/{this many characters are actually
  relevant in |name_of_file| (the rest are blank)}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.27] file opening
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The \ph\ compiler with which the present version of \TeX\ was prepared has
extended the rules of \PASCAL\ in a very convenient way. To open file~|f|,
we can write
$$\vbox{\halign{#\hfil\qquad&#\hfil\cr
|reset(f,@t\\{name}@>,'/O')|&for input;\cr
|rewrite(f,@t\\{name}@>,'/O')|&for output.\cr}}$$
The `\\{name}' parameter, which is of type `{\bf packed array
$[\langle\\{any}\rangle]$ of \\{char}}', stands for the name of
the external file that is being opened for input or output.
Blank spaces that might appear in \\{name} are ignored.

The `\.{/O}' parameter tells the operating system not to issue its own
error messages if something goes wrong. If a file of the specified name
cannot be found, or if such a file cannot be opened for some other reason
(e.g., someone may already be trying to write the same file), we will have
|@!erstat(f)<>0| after an unsuccessful |reset| or |rewrite|.  This allows
\TeX\ to undertake appropriate corrective action.
@:PASCAL H}{\ph@>
@^system dependencies@>

\TeX's file-opening procedures return |false| if no file identified by
|name_of_file| could be opened.

@d reset_OK(#)==erstat(#)=0
@d rewrite_OK(#)==erstat(#)=0

@p function a_open_in(var f:alpha_file):boolean;
  {open a text file for input}
begin reset(f,name_of_file,'/O'); a_open_in:=reset_OK(f);
end;
@#
function a_open_out(var f:alpha_file):boolean;
  {open a text file for output}
begin rewrite(f,name_of_file,'/O'); a_open_out:=rewrite_OK(f);
end;
@#
function b_open_in(var f:byte_file):boolean;
  {open a binary file for input}
begin reset(f,name_of_file,'/O'); b_open_in:=reset_OK(f);
end;
@#
function b_open_out(var f:byte_file):boolean;
  {open a binary file for output}
begin rewrite(f,name_of_file,'/O'); b_open_out:=rewrite_OK(f);
end;
@#
function w_open_in(var f:word_file):boolean;
  {open a word file for input}
begin reset(f,name_of_file,'/O'); w_open_in:=reset_OK(f);
end;
@#
function w_open_out(var f:word_file):boolean;
  {open a word file for output}
begin rewrite(f,name_of_file,'/O'); w_open_out:=rewrite_OK(f);
end;
@y
{All of these functions will be defined as macros in C.}
@z

@x
@p procedure a_close(var f:alpha_file); {close a text file}
begin close(f);
end;
@#
procedure b_close(var f:byte_file); {close a binary file}
begin close(f);
end;
@#
procedure w_close(var f:word_file); {close a word file}
begin close(f);
end;
@y
{And all of these as well.}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.31] Make input_ln an external C routine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function input_ln(var f:alpha_file;@!bypass_eoln:boolean):boolean;
  {inputs the next line or returns |false|}
var last_nonblank:0..buf_size; {|last| with trailing blanks removed}
begin if bypass_eoln then if not eof(f) then get(f);
  {input the first character of the line into |f^|}
last:=first; {cf.\ Matthew 19\thinspace:\thinspace30}
if eof(f) then input_ln:=false
else  begin last_nonblank:=first;
  while not eoln(f) do
    begin if last>=max_buf_stack then
      begin max_buf_stack:=last+1;
      if max_buf_stack=buf_size then
        overflow("buffer size",buf_size);
@:TeX capacity exceeded buffer size}{\quad buffer size@>
      end;
    buffer[last]:=xord[f^]; get(f); incr(last);
    if buffer[last-1]<>" " then last_nonblank:=last;
    end;
  last:=last_nonblank; input_ln:=true;
  end;
end;
@y
We'll get inputln from an external C module, coded for efficiency
directly in C.
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.32] term_in/out are input,output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The user's terminal acts essentially like other files of text, except
that it is used both for input and for output. When the terminal is
considered an input file, the file variable is called |term_in|, and when it
is considered an output file the file variable is |term_out|.
@^system dependencies@>

@<Glob...@>=
@!term_in:alpha_file; {the terminal as an input file}
@!term_out:alpha_file; {the terminal as an output file}
@y
@ The user's terminal acts essentially like other files of text, except
that it is used both for input and for output. When the terminal is
considered an input file, the file is called |term_in|, and when it
is considered an output file the file is |term_out|.  In C, these
files will be defined as ``stdin'' and ``stdout,'' respectively.

@d term_in==stdin {the terminal as an input file}
@d term_out==stdout {the terminal as an output file}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.33] don't need to open terminal files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ Here is how to open the terminal files
in \ph. The `\.{/I}' switch suppresses the first |get|.
@^system dependencies@>

@d t_open_in==reset(term_in,'TTY:','/O/I') {open the terminal for text input}
@d t_open_out==rewrite(term_out,'TTY:','/O') {open the terminal for text output}
@y
@ Here is how to open the terminal files.  t_open_out does nothing.
t_open_in, on the other hand, does the work of "rescanning", or getting
any command line arguments the user has provided.  It's coded in C
externally.

@d t_open_out == {output already open for text output}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.34] flushing output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
these operations can be specified in \ph:
@^system dependencies@>

@d update_terminal == break(term_out) {empty the terminal output buffer}
@d clear_terminal == break_in(term_in,true) {clear the terminal input buffer}
@d wake_up_terminal == do_nothing {cancel the user's cancellation of output}
@y
these operations can be specified with {\mc UNIX}.  Update_terminal
does an fflush, since that's easy.  wake_up_terminal and clear_terminal
are specified in external C routines, if desired.  We call fflush()
termflush() here, and fix it with a macro in C, so we can cast it to (void)
to keep lint quiet.
@^system dependencies@>

@d update_terminal == termflush(term_out)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [3.37] rescanning the command line 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The following program does the required initialization
without retrieving a possible command line.
It should be clear how to modify this routine to deal with command lines,
if the system permits them.
@^system dependencies@>

@p function init_terminal:boolean; {gets the terminal input started}
label exit;
begin t_open_in;
loop@+begin wake_up_terminal; write(term_out,'**'); update_terminal;
@.**@>
  if not input_ln(term_in,true) then {this shouldn't happen}
    begin write_ln(term_out);
    write(term_out,'! End of file on the terminal... why?');
@.End of file on the terminal@>
    init_terminal:=false; return;
    end;
  loc:=first;
  while (loc<last)and(buffer[loc]=" ") do incr(loc);
  if loc<last then
    begin init_terminal:=true;
    return; {return unless the line was all blank}
    end;
  write_ln(term_out,'Please type the name of your input file.');
  end;
exit:end;
@y
@ The following program does the required initialization.
Iff anything has been specified on the command line, then t_open_in
will return with last > first.
@^system dependencies@>

@p
function init_terminal:boolean; {gets the terminal input started}
label exit;

begin
  t_open_in;
  if last > first then begin
    loc := first;
    while (loc < last) and (buffer[loc]=' ') do
      incr(loc);
    if loc < last then begin
      init_terminal := true;
        goto exit;
    end;
  end;
  loop@+begin
    wake_up_terminal; write(term_out, '**'); update_terminal;
@.**@>
    if not input_ln(term_in,true) then begin {this shouldn't happen}
      write_ln(term_out);
      write(term_out, '! End of file on the terminal... why?');
@.End of file on the terminal@>
      init_terminal:=false;
    return;
        end;

        loc:=first;
        while (loc<last)and(buffer[loc]=" ") do
            incr(loc);

        if loc<last then begin
           init_terminal:=true;
           return; {return unless the line was all blank}
        end;
        write_ln(term_out, 'Please type the name of your input file.');
    end;
exit:
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [4.47][4.48][4.49]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
label done,exit;
var k,@!l:0..127; {small indices or counters}
@y
label done,exit;
var k,@!l:halfword; {small indices or counters}
@z

@x
@<Make the first 128 strings@>;
@y
@<Make the first 256 strings@>;
@z


@x
@ @<Make the first 128...@>=
for k:=0 to 127 do
@y
@ @<Make the first 256...@>=
for k:=0 to 255 do
@z

@x
@<Character |k| cannot be printed@>=
  (k<" ")or(k>"~")
@y
@<Character |k| cannot be printed@>=
  (k<" ")or(k>252)or(k=127)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [4.51] a_open_in of pool file needs path specifier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
name_of_file:=pool_name; {we needn't set |name_length|}
if a_open_in(pool_file) then
@y
vstrcpy(name_of_file+1, pool_name); {this is how you copy strings in C}
if a_open_in(pool_file,pool_path_spec) then
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [4.51,52,53] make TEX.POOL lowercase in messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else  bad_pool('! I can''t read TEX.POOL.')
@y
else begin
   {Like"bad_pool, but must not close file if we never opened it}
   wake_up_terminal; write_ln(term_out, '! I can''t read ptex.pool.');
   get_strings_started:= false; return;
end
@z

@x
@ @<Read one string...@>=
begin if eof(pool_file) then bad_pool('! TEX.POOL has no check sum.');
@.TEX.POOL has no check sum@>
read(pool_file,m,n); {read two digits of string length}
if m='*' then @<Check the pool check sum@>
else  begin if (xord[m]<"0")or(xord[m]>"9")or@|
      (xord[n]<"0")or(xord[n]>"9") then
    bad_pool('! TEX.POOL line doesn''t begin with two digits.');
@.TEX.POOL line doesn't...@>
  l:=xord[m]*10+xord[n]-"0"*11; {compute the length}
  if pool_ptr+l+string_vacancies>pool_size then
    bad_pool('! You have to increase POOLSIZE.');
@.You have to increase POOLSIZE@>
  for k:=1 to l do
    begin if eoln(pool_file) then m:=' '@+else read(pool_file,m);
    append_char(xord[m]);
    end;
  read_ln(pool_file); g:=make_string;
  end;
end

@ The \.{WEB} operation \.{@@\$} denotes the value that should be at the
end of this \.{TEX.POOL} file; any other value means that the wrong pool
file has been loaded.
@^check sum@>

@<Check the pool check sum@>=
begin a:=0; k:=1;
loop@+  begin if (xord[n]<"0")or(xord[n]>"9") then
  bad_pool('! TEX.POOL check sum doesn''t have nine digits.');
@.TEX.POOL check sum...@>
  a:=10*a+xord[n]-"0";
  if k=9 then goto done;
  incr(k); read(pool_file,n);
  end;
done: if a<>@$ then bad_pool('! TEX.POOL doesn''t match; TANGLE me again.');
@.TEX.POOL doesn't match@>
c:=true;
end
@y
@ @<Read one string...@>=
begin if eof(pool_file) then bad_pool('! ptex.pool has no check sum.');
@.TEX.POOL has no check sum@>
read(pool_file,m); read(pool_file,n); {read two digits of string length}
if m='*' then @<Check the pool check sum@>
else  begin if (xord(m)<"0")or(xord(m)>"9")or@|
      (xord(n)<"0")or(xord(n)>"9") then
    bad_pool('! ptex.pool line doesn''t begin with two digits.');
@.TEX.POOL line doesn't...@>
  l:=xord(m)*10+xord(n)-"0"*11; {compute the length}
  if pool_ptr+l+string_vacancies>pool_size then
    bad_pool('! You have to increase POOLSIZE.');
@.You have to increase POOLSIZE@>
  for k:=1 to l do
    begin if eoln(pool_file) then m:=' '@+else read(pool_file,m);
    append_char(xord(m));
    end;
  read_ln(pool_file); g:=make_string;
  end;
end

@ The \.{WEB} operation \.{@@\$} denotes the value that should be at the
end of this \.{TEX.POOL} file; any other value means that the wrong pool
file has been loaded.
@^check sum@>

@<Check the pool check sum@>=
begin a:=0; k:=1;
loop@+  begin if (xord(n)<"0")or(xord(n)>"9") then
  bad_pool('! ptex.pool check sum doesn''t have nine digits.');
@.TEX.POOL check sum...@>
  a:=10*a+xord(n)-"0";
  if k=9 then goto done;
  incr(k); read(pool_file,n);
  end;
done: if a<>@$ then bad_pool('! ptex.pool doesn''t match; TANGLE me again.');
@.TEX.POOL doesn't match@>
c:=true;
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[5.54][5.55] trick_buf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!trick_count: integer; {threshold for pseudoprinting, explained later}
@!first_count: integer; {another variable for pseudoprinting}

@ @<Initialize the output routines@>=
selector:=term_only; tally:=0; term_offset:=0; file_offset:=0;
@y
@!trick_count: integer; {threshold for pseudoprinting, explained later}
@!first_count: integer; {another variable for pseudoprinting}
@!trick_buf2: array[0..error_line] of 0..2;
@!kcode_pos: 0..2;

@ @<Initialize the output routines@>=
selector:=term_only; tally:=0; term_offset:=0; file_offset:=0;
kcode_pos:=0;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[5.57] kcode_pos
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure print_ln; {prints an end-of-line}
begin case selector of
term_and_log: begin wterm_cr; wlog_cr;
  term_offset:=0; file_offset:=0;
  end;
log_only: begin wlog_cr; file_offset:=0;
  end;
term_only: begin wterm_cr; term_offset:=0;
  end;
no_print,pseudo,new_string: do_nothing;
othercases write_ln(write_file[selector])
endcases;@/
end; {|tally| is not affected}
@y
procedure print_ln; {prints an end-of-line}
begin
  case selector of
  term_and_log: begin
      if kcode_pos=1 then begin wterm(' '); wlog(' '); end;
      wterm_cr; wlog_cr; term_offset:=0; file_offset:=0;
    end;
  log_only: begin
      if kcode_pos=1 then wlog(' ');
      wlog_cr; file_offset:=0;
    end;
  term_only: begin
      if kcode_pos=1 then wterm(' ');
      wterm_cr; term_offset:=0;
    end;
  no_print,pseudo,new_string: do_nothing;
  othercases write_ln(write_file[selector])
  endcases;@/
  kcode_pos:=0;
end; {|tally| is not affected}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[5.58] pseudo print
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
case selector of
term_and_log: begin wterm(xchr[s]); wlog(xchr[s]);
  incr(term_offset); incr(file_offset);
  if term_offset=max_print_line then
    begin wterm_cr; term_offset:=0;
    end;
  if file_offset=max_print_line then
    begin wlog_cr; file_offset:=0;
    end;
  end;
log_only: begin wlog(xchr[s]); incr(file_offset);
  if file_offset=max_print_line then print_ln;
  end;
term_only: begin wterm(xchr[s]); incr(term_offset);
  if term_offset=max_print_line then print_ln;
  end;
no_print: do_nothing;
pseudo: if tally<trick_count then trick_buf[tally mod error_line]:=s;
new_string: begin if pool_ptr<pool_size then append_char(s);
  end; {we drop characters if the string space is full}
othercases write(write_file[selector],xchr[s])
endcases;@/
@y
if kcode_pos=1 then kcode_pos:=2
 else if iskanji(s) then kcode_pos:=1
 else kcode_pos:=0;
case selector of
term_and_log: begin
    if kcode_pos=1 then begin
      if term_offset>=max_print_line-1 then begin wterm_cr; term_offset:=0; end;
      if file_offset>=max_print_line-1 then begin wlog_cr; file_offset:=0; end;
    end;
    wterm(xchr(s)); incr(term_offset);
    if term_offset=max_print_line then begin wterm_cr; term_offset:=0; end;
    wlog(xchr(s)); incr(file_offset);
    if file_offset=max_print_line then begin wlog_cr; file_offset:=0; end;
  end;
log_only: begin
    if (kcode_pos=1)and(file_offset>=max_print_line-1) then begin
      wlog_cr; file_offset:=0;
    end;
    wlog(xchr(s)); incr(file_offset);
    if file_offset=max_print_line then print_ln;
  end;
term_only: begin
    if (kcode_pos=1)and(term_offset>=max_print_line-1) then begin
      wterm_cr; term_offset:=0;
    end;
    wterm(xchr(s)); incr(term_offset);
    if term_offset=max_print_line then print_ln;
  end;
no_print: do_nothing;
pseudo:
  if tally<trick_count then begin
    trick_buf[tally mod error_line]:=s;
    trick_buf2[tally mod error_line]:=kcode_pos;
  end;
new_string: begin
    if pool_ptr<pool_size then append_char(s);
  end; {we drop characters if the string space is full}
othercases
  write(write_file[selector],xchr(s))
endcases;@/
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [5.59][5.60] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else if s<128 then
  if s<0 then s:="???" {can't happen}
  else if (@<Character |s| is the current new-line character@>) then
    if selector<pseudo then
@y
else if s<256 then
  if s<0 then s:="???" {can't happen}
  else if (@<Character |s| is the current new-line character@>) then
    if selector<pseudo then
@z

@x
else if s<128 then
  if s<0 then s:="???" {can't happen}
  else if (@<Character |s| is the current new-line character@>) then
    if selector<pseudo then
      begin print_ln; return;
@y
else if s<256 then
  if s<0 then s:="???" {can't happen}
  else if (@<Character |s| is the current new-line character@>) then
    if selector<pseudo then
      begin print_ln; return;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [6.81] Eliminate nonlocal goto
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% C cannot do non-local goto's.
% Plus, it's nicer just to do an exit with the appropriate status code
% under Unix.  We call it "uexit" because there's a WEB symbol called
% "exit" already.  We use a C macro to change uexit() back to exit().
@x
@<Error hand...@>=
procedure jump_out;
begin goto end_of_TEX;
end;
@y
@d do_final_end==begin
   update_terminal;
   ready_already:=0;
   if (history <> spotless) and (history <> warning_issued) then
       uexit(1)
   else
       uexit(0);
   end
@<Error hand...@>=
procedure jump_out;
begin
close_files_and_terminate;
do_final_end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [6.84] switch-to-editor option
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
line ready to be edited. But such an extension requires some system
wizardry, so the present implementation simply types out what file should be
edited and the relevant line number.
@^system dependencies@>

There is a secret `\.D' option available when the debugging routines have
not been commented out.
@^debugging@>
@y
line ready to be edited.
We do this by calling the external procedure |calledit| with a pointer to
the filename, its length, and the line number.
However, here we just set up the variables that will be used as arguments,
since we don't want to do the switch-to-editor until after TeX has closed
its files.
@^system dependencies@>

There is a secret `\.D' option available when the debugging routines have
not been commented out.
@^debugging@>
@d edit_file==input_stack[base_ptr]
@z

@x
"E": if base_ptr>0 then
  begin print_nl("You want to edit file ");
@.You want to edit file x@>
  print(input_stack[base_ptr].name_field);
  print(" at line "); print_int(line);
  interaction:=scroll_mode; jump_out;
@y
"E": if base_ptr>0 then
    begin
    edit_name_start:=str_start[edit_file.name_field];
    edit_name_length:=str_start[edit_file.name_field+1] -
                      str_start[edit_file.name_field];
    edit_line:=line;
    jump_out;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [7.109] Handle definition of glue_ratio in an include file as a typedef
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!glue_ratio=real; {one-word representation of a glue expansion factor}
@y
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%l[8.110] Make it easy to build a bigger TeX.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Actually, we change nothing in this basic version of the file,
% but having this here makes it easier to change max_halfword later.

@x
@d min_quarterword=0 {smallest allowable value in a |quarterword|}
@d max_quarterword=255 {largest allowable value in a |quarterword|}
@d min_halfword==0 {smallest allowable value in a |halfword|}
@d max_halfword==65535 {largest allowable value in a |halfword|}
@y
@d min_quarterword=0 {smallest allowable value in a |quarterword|}
@d max_quarterword=511 {largest allowable value in a |quarterword|}
@d min_halfword==0 {smallest allowable value in a |halfword|}
@d max_halfword==262143 {largest allowable value in a |halfword|}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [8.112] Efficiency!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d qi(#)==#+min_quarterword
  {to put an |eight_bits| item into a quarterword}
@d qo(#)==#-min_quarterword
  {to take an |eight_bits| item out of a quarterword}
@d hi(#)==#+min_halfword
  {to put a sixteen-bit item into a halfword}
@d ho(#)==#-min_halfword
  {to take a sixteen-bit item from a halfword}
@y
@d qi(#)==#
@d qo(#)==#
@d hi(#)==#
@d ho(#)==#
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [8.113] Hand-code some more things in C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!quarterword = min_quarterword..max_quarterword; {1/4 of a word}
@!halfword=min_halfword..max_halfword; {1/2 of a word}
@!two_choices = 1..2; {used when there are two variants in a record}
@!four_choices = 1..4; {used when there are four variants in a record}
@!two_halves = packed record@;@/
  @!rh:halfword;
  case two_choices of
  1: (@!lh:halfword);
  2: (@!b0:quarterword; @!b1:quarterword);
  end;
@!four_quarters = packed record@;@/
  @!b0:quarterword;
  @!b1:quarterword;
  @!b2:quarterword;
  @!b3:quarterword;
  end;
@!memory_word = record@;@/
  case four_choices of
  1: (@!int:integer);
  2: (@!gr:glue_ratio);
  3: (@!hh:two_halves);
  4: (@!qqqq:four_quarters);
  end;
@!word_file = file of memory_word;
@y
@!quarterword=min_quarterword..max_quarterword;
@!halfword=min_halfword..max_halfword;
@!two_choices = 1..2; {used when there are two variants in a record}
@!four_choices = 1..4; {used when there are four variants in a record}
@!KANJI_code=halfword;
@=#include "memory.h";@>

@ KANJI_code handling

@d @!KANJI(#)==#
@d @!hbyte==Hi(cur_jchr)
@d @!lbyte==Lo(cur_jchr)
@d @!Hi_code(#)==mem[#].hh.b0
@d @!Lo_code(#)==mem[#].hh.b1
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [9.116] Change mem to zmem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% We do this so that we can define mem to be a register pointer to the
% memory array for speed.
@x
@!mem : array[mem_min..mem_max] of memory_word; {the big dynamic storage area}
@y
@!zmem : array[mem_min..mem_max] of memory_word; {the big dynamic storage area}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [9.127] Fix casting problem in C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% There are several of these.  They come from the rules C uses for
% comparing signed and unsigned quantities.  Just doing the comparison
% can result in incorrect evaluation wrt the way Pascal would do it.
@x
if r>p+1 then @<Allocate from the top of node |p| and |goto found|@>;
@y
if r>toint(p+1) then @<Allocate from the top of node |p| and |goto found|@>;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[10.135] box node: space_ptr, xspace_ptr
%p[10.135] box node: box_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d hlist_node=0 {|type| of hlist nodes}
@d box_node_size=7 {number of words to allocate for a box node}
@d width_offset=1 {position of |width| field in a box node}
@d depth_offset=2 {position of |depth| field in a box node}
@d height_offset=3 {position of |height| field in a box node}
@d width(#) == mem[#+width_offset].sc {width of the box, in sp}
@d depth(#) == mem[#+depth_offset].sc {depth of the box, in sp}
@d height(#) == mem[#+height_offset].sc {height of the box, in sp}
@d shift_amount(#) == mem[#+4].sc {repositioning distance, in sp}
@d list_offset=5 {position of |list_ptr| field in a box node}
@d list_ptr(#) == link(#+list_offset) {beginning of the list inside the box}
@d glue_order(#) == subtype(#+list_offset) {applicable order of infinity}
@d glue_sign(#) == type(#+list_offset) {stretching or shrinking}
@d normal=0 {the most common case when several cases are named}
@d stretching = 1 {glue setting applies to the stretch components}
@d shrinking = 2 {glue setting applies to the shrink components}
@d glue_offset = 6 {position of |glue_set| in a box node}
@d glue_set(#) == mem[#+glue_offset].gr
  {a word of type |glue_ratio| for glue setting}
@y
@d hlist_node=0 {|type| of hlist nodes}
@d box_node_size=8 {number of words to allocate for a box node}
@d box_dir(#) == subtype(#) {direction mode of a box}

@d dir_default == qi(0)
@d dir_dtou == qi(1)
@d dir_tate == qi(3)
@d dir_yoko == qi(4)
@d any_dir == dir_yoko,dir_tate,dir_dtou

@d width_offset=1 {position of |width| field in a box node}
@d depth_offset=2 {position of |depth| field in a box node}
@d height_offset=3 {position of |height| field in a box node}
@d width(#) == mem[#+width_offset].sc {width of the box, in sp}
@d depth(#) == mem[#+depth_offset].sc {depth of the box, in sp}
@d height(#) == mem[#+height_offset].sc {height of the box, in sp}
@d shift_amount(#) == mem[#+4].sc {repositioning distance, in sp}
@d list_offset=5 {position of |list_ptr| field in a box node}
@d list_ptr(#) == link(#+list_offset) {beginning of the list inside the box}
@d glue_order(#) == subtype(#+list_offset) {applicable order of infinity}
@d glue_sign(#) == type(#+list_offset) {stretching or shrinking}
@d normal=0 {the most common case when several cases are named}
@d stretching = 1 {glue setting applies to the stretch components}
@d shrinking = 2 {glue setting applies to the shrink components}
@d glue_offset = 6 {position of |glue_set| in a box node}
@d glue_set(#) == mem[#+glue_offset].gr
  {a word of type |glue_ratio| for glue setting}
@d space_offset = 7 {position of |glue_set| in a box node}
@d space_ptr(#) == link(#+space_offset)
@d xspace_ptr(#) == info(#+space_offset)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[10.136] new box: space_ptr, xspace_ptr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function new_null_box:pointer; {creates a new box node}
var p:pointer; {the new node}
begin p:=get_node(box_node_size); type(p):=hlist_node;
subtype(p):=min_quarterword;
width(p):=0; depth(p):=0; height(p):=0; shift_amount(p):=0; list_ptr(p):=null;
glue_sign(p):=normal; glue_order(p):=normal; set_glue_ratio_zero(glue_set(p));
new_null_box:=p;
@y
@p function new_null_box:pointer; {creates a new box node}
var p:pointer; {the new node}
begin p:=get_node(box_node_size); type(p):=hlist_node;
subtype(p):=min_quarterword;
width(p):=0; depth(p):=0; height(p):=0; shift_amount(p):=0; list_ptr(p):=null;
glue_sign(p):=normal; glue_order(p):=normal; set_glue_ratio_zero(glue_set(p));
@<set zero glue@>; new_null_box:=p;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[10.137] direction change node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ A |vlist_node| is like an |hlist_node| in all respects except that it
was made from a vertical list.

@d vlist_node=1 {|type| of vlist nodes}
@y
@ A |vlist_node| is like an |hlist_node| in all respects except that it
was made from a vertical list.

@d vlist_node=1 {|type| of vlist nodes}

@ A |dir_node| stands for direction change.

@d dir_node=2

@p
function new_dir_node(b:pointer; dir:eight_bits):pointer;
  var p:pointer; {the new node}
begin
  if type(b)>vlist_node then
    confusion("new_dir_node:not box");
  p:=new_null_box; type(p):=dir_node; box_dir(p):=dir;
  case box_dir(b) of
  dir_yoko: @<Yoko to other direction@>;
  dir_tate: @<Tate to other direction@>;
  dir_dtou: @<DtoU to other direction@>;
  othercases
    confusion("new_dir_node:illegal dir");
  endcases;
  link(b):=null; list_ptr(p):=b;
  new_dir_node:=p;
end;

@ @<Yoko to other direction@>=
  case dir of
  dir_tate:
    begin
      width(p):=height(b)+depth(b);
      depth(p):=width(b)/2; height(p):=width(b)-depth(p);
    end;
  dir_dtou:
    begin
      width(p):=height(b)+depth(b);
      depth(p):=0; height(p):=width(b);
    end;
  othercases
    confusion("new_dir_node:y->?");
  endcases

@ @<Tate to other direction@>=
  case dir of
  dir_yoko:
    begin
      width(p):=height(b)+depth(b);
      depth(p):=0; height(p):=width(b);
    end;
  dir_dtou:
    begin
      width(p):=width(b);
      depth(p):=height(b); height(p):=depth(b);
    end;
  othercases
    confusion("new_dir_node:t->?");
  endcases

@ @<DtoU to other direction@>=
  case dir of
  dir_yoko:
    begin
      width(p):=height(b)+depth(b);
      depth(p):=0; height(p):=width(b);
    end;
  dir_tate:
    begin
      width(p):=width(b);
      depth(p):=height(b); height(p):=depth(b);
    end;
  othercases
    confusion("new_dir_node:d->?");
  endcases
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[10.138] renumber rule_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d rule_node=2 {|type| of rule nodes}
@y
@d rule_node=3 {|type| of rule nodes}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[10.140] renumber ins_node, add ins_dir field
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d ins_node=3 {|type| of insertion nodes}
@d ins_node_size=5 {number of words to allocate for an insertion}
@d float_cost(#)==mem[#+1].int {the |floating_penalty| to be used}
@d ins_ptr(#)==info(#+4) {the vertical list to be inserted}
@d split_top_ptr(#)==link(#+4) {the |split_top_skip| to be used}
@y
@d ins_node=4 {|type| of insertion nodes}
@d ins_node_size=6 {number of words to allocate for an insertion}
@d float_cost(#)==mem[#+1].int {the |floating_penalty| to be used}
@d ins_ptr(#)==info(#+4) {the vertical list to be inserted}
@d split_top_ptr(#)==link(#+4) {the |split_top_skip| to be used}
@d ins_dir(#)==subtype(#+5) {direction of ins_node}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[10.141] disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ A |mark_node| has a |mark_ptr| field that points to the reference count
@y
@ A |disp_node| has a |disp_dimen| field.

@d disp_node=5
@d disp_dimen(#) == mem[#+1].sc

@ A |mark_node| has a |mark_ptr| field that points to the reference count
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[10.140]..[10.149] renumber nodes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d mark_node=4 {|type| of a mark node}
@y
@d mark_node=6 {|type| of a mark node}
@z

@x
@d adjust_node=5 {|type| of an adjust node}
@y
@d adjust_node=7 {|type| of an adjust node}
@z

@x
@d ligature_node=6 {|type| of a ligature node}
@y
@d ligature_node=8 {|type| of a ligature node}
@z

@x
@d disc_node=7 {|type| of a discretionary node}
@y
@d disc_node=9 {|type| of a discretionary node}
@z

@x
@d whatsit_node=8 {|type| of special extension nodes}
@y
@d whatsit_node=10 {|type| of special extension nodes}
@z

@x
@d math_node=9 {|type| of a math node}
@y
@d math_node=11 {|type| of a math node}
@z

@x
@d glue_node=10 {|type| of node that points to a glue specification}
@y
@d glue_node=12 {|type| of node that points to a glue specification}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[10.155]..[10.160] renumber nodes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d kern_node=11 {|type| of a kern node}
@y
@d kern_node=13 {|type| of a kern node}
@z

@x
@d penalty_node=12 {|type| of a penalty node}
@y
@d penalty_node=14 {|type| of a penalty node}
@d widow_pena=1 {|subtype| of penalty nodes from \chrwidowpenalty}
@d kinsoku_pena=2 {|subtype| of penalty nodes from kinsoku}
@z

@x
@d unset_node=13 {|type| for an unset node}
@y
@d unset_node=15 {|type| for an unset node}
@z

@x
@ In fact, there are still more types coming. When we get to math formula
processing we will see that a |style_node| has |type=14|; and a number
of larger type codes will also be defined, for use in math mode only.
@y
@ In fact, there are still more types coming. When we get to math formula
processing we will see that a |style_node| has |type=15|; and a number
of larger type codes will also be defined, for use in math mode only.
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [11.165] fix the word "free" so that it doesn't conflict with the C routine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
been included. (You may want to decrease the size of |mem| while you
@^debugging@>
are debugging.)
@y
been included. (You may want to decrease the size of |mem| while you
@^debugging@>
are debugging.)

@d free==free_arr
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.174] Eliminate some unsigned comparisons to zero
%p[12.174] display box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure short_display(@!p:integer); {prints highlights of list |p|}
var n:integer; {for replacement counts}
begin while p>mem_min do
  begin if is_char_node(p) then
    begin if p<=mem_end then
      begin if font(p)<>font_in_short_display then
        begin if (font(p)<font_base)or(font(p)>font_max) then
          print_char("*")
@.*\relax@>
        else @<Print the font identifier for |font(p)|@>;
        print_char(" "); font_in_short_display:=font(p);
        end;
      print_ASCII(qo(character(p)));
      end;
    end
  else @<Print a short indication of the contents of node |p|@>;
  p:=link(p);
  end;
end;
@y
@p
procedure short_display(@!p:integer); {prints highlights of list |p|}
var n:integer; {for replacement counts}
  f:internal_font_number;
  jc:KANJI_code;
begin
  while p>mem_min do begin
    if is_char_node(p) then begin
      if p<=mem_end then begin
        f:=font(p);
        if f<>font_in_short_display then begin
          if (font(p)>font_max) then print_char("*")
@.*\relax@>
          else @<Print the font identifier for |font(p)|@>;
          print_char(" "); font_in_short_display:=f;
        end;
        if font_dir[f]<>dir_default then begin
          p:=link(p); jc:=info(p);
          print_char(Hi(jc)); print_char(Lo(jc));
        end else print_ASCII(qo(character(p)));
      end;
    end else @<Print a short indication of the contents of node |p|@>;
    p:=link(p);
  end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[12.175] Print a short indication of dir_nodes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
hlist_node,vlist_node,ins_node,whatsit_node,mark_node,adjust_node,
  unset_node: print("[]");
@y
hlist_node,vlist_node,dir_node,ins_node,whatsit_node,
  mark_node,adjust_node,unset_node: print("[]");
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.176] Eliminate some unsigned comparisons to zero (continued)
%p[12.176] print dir
%j[12.176] print font and char
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure print_font_and_char(@!p:integer); {prints |char_node| data}
begin if p>mem_end then print_esc("CLOBBERED.")
else  begin if (font(p)<font_base)or(font(p)>font_max) then print_char("*")
@.*\relax@>
  else @<Print the font identifier for |font(p)|@>;
  print_char(" "); print_ASCII(qo(character(p)));
  end;
end;
@y
@p procedure print_dir(@!dir:eight_bits); {prints |dir| data}
begin
  if dir=dir_yoko then print_char("Y")
  else if dir=dir_tate then print_char("T")
  else if dir=dir_dtou then print_char("D")
end;

procedure print_direction(@!d:integer);
	{print the direction represented by d}
begin
  case abs(d) of
  dir_yoko: print("yoko");
  dir_tate: print("tate");
  dir_dtou: print("dtou");
  end;
  if d < 0 then print("(math)");
  print(" direction");
end;

procedure print_font_and_char(@!p:integer); {prints |char_node| data}
var f:internal_font_number;
  jc:KANJI_code;
begin
  if p>mem_end then print_esc("CLOBBERED.")
  else begin
    f:=font(p);
    if (f>font_max) then print_char("*")
@.*\relax@>
    else @<Print the font identifier for |font(p)|@>;
    print_char(" ");
    if font_dir[f]<>dir_default then begin
      p:=link(p);jc:=info(p);
      print_char(Hi(jc)); print_char(Lo(jc));
    end else
      print_ASCII(qo(character(p)));
  end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[12.183] display char_node
%p[12.183] display disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@x
@ @<Display node |p|@>=
if is_char_node(p) then print_font_and_char(p)
else  case type(p) of
  hlist_node,vlist_node,unset_node: @<Display box |p|@>;
  rule_node: @<Display rule |p|@>;
  ins_node: @<Display insertion |p|@>;
  whatsit_node: @<Display the whatsit node |p|@>;
@y
@ @<Display node |p|@>=
  if is_char_node(p) then begin
    print_font_and_char(p);
    if font_dir[font(p)]<>dir_default then p:=link(p)
  end else case type(p) of
  hlist_node,vlist_node,dir_node,unset_node: @<Display box |p|@>;
  rule_node: @<Display rule |p|@>;
  ins_node: @<Display insertion |p|@>;
  whatsit_node: @<Display the whatsit node |p|@>;
  disp_node:
    begin
      print_esc("displace ");
      print_scaled(disp_dimen(p));
    end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[12.184] display dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Display box |p|@>=
begin if type(p)=hlist_node then print_esc("h")
else if type(p)=vlist_node then print_esc("v")
else print_esc("unset");
print("box("); print_scaled(height(p)); print_char("+");
print_scaled(depth(p)); print(")x"); print_scaled(width(p));
if type(p)=unset_node then
  @<Display special fields of the unset node |p|@>
else  begin @<Display the value of |glue_set(p)|@>;
  if shift_amount(p)<>0 then
    begin print(", shifted "); print_scaled(shift_amount(p));
    end;
  end;
node_list_display(list_ptr(p)); {recursive call}
end
@y
@ @<Display box |p|@>=
begin
  if type(p)=hlist_node then print_esc("h")
  else if type(p)=vlist_node then print_esc("v")
  else if type(p)=dir_node then print_esc("dir")
  else print_esc("unset");
  print("box"); print_char("(");
  print_scaled(height(p)); print_char("+");
  print_scaled(depth(p)); print(")x"); print_scaled(width(p));
  if type(p)=unset_node then
    @<Display special fields of the unset node |p|@>
  else  begin
    @<Display the value of |glue_set(p)|@>;
    if shift_amount(p)<>0 then begin
      print(", shifted "); print_scaled(shift_amount(p));
    end;
    if box_dir(p)<>dir_default then begin
      print(", ");
      print_direction(box_dir(p));
    end
  end;
 {if type(p)=hlist_node then begin

  end;}
  node_list_display(list_ptr(p)); {recursive call}
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [12.186] glue_ratio fix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
floating point underflow on the author's computer.
@^system dependencies@>
@^dirty \PASCAL@>

@<Display the value of |glue_set(p)|@>=
g:=float(glue_set(p));
if (g<>float_constant(0))and(glue_sign(p)<>normal) then
  begin print(", glue set ");
  if glue_sign(p)=shrinking then print("- ");
  if abs(mem[p+glue_offset].int)<@'4000000 then print("?.?")
  else if abs(g)>float_constant(20000) then
    begin if g>float_constant(0) then print_char(">")
    else print("< -");
    print_glue(20000*unity,glue_order(p),0);
    end
  else print_glue(round(unity*g),glue_order(p),0);
@^real multiplication@>
  end
@y
floating point underflow on the author's computer.
@^system dependencies@>
@^dirty \PASCAL@>

@<Display the value of |glue_set(p)|@>=
g:=float(glue_set(p));
if (g<>float_constant(0))and(glue_sign(p)<>normal) then
  begin print(", glue set ");
  if glue_sign(p)=shrinking then print("- ");
  { The Unix "pc" folks removed this restriction with a remark that
    invalid bit patterns were vanishingly improbable, so we follow
    their example without really understanding it.
  if abs(mem[p+glue_offset].int)<@'4000000 then print('?.?')
  else }
  if fabs(g)>float_constant(20000) then
    begin if g>float_constant(0) then print_char(">")
    else print("< -");
    print_glue(20000*unity,glue_order(p),0);
    end
  else print_glue(round(unity*g),glue_order(p),0);
@^real multiplication@>
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[12.188] Display insertion, ins_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Display insertion |p|@>=
begin print_esc("insert"); print_int(qo(subtype(p)));
print(", natural size "); print_scaled(height(p));
print("; split("); print_spec(split_top_ptr(p),0);
print_char(","); print_scaled(depth(p));
print("); float cost "); print_int(float_cost(p));
node_list_display(ins_ptr(p)); {recursive call}
end
@y
@ @<Display insertion |p|@>=
  begin
    print_esc("insert"); print_int(qo(subtype(p))); print_dir(ins_dir(p));
    print(", natural size "); print_scaled(height(p));
    print("; split("); print_spec(split_top_ptr(p),0);
    print_char(","); print_scaled(depth(p));
    print("); float cost "); print_int(float_cost(p));
    node_list_display(ins_ptr(p)); {recursive call}
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[12.194] Display penalty usage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Display penalty |p|@>=
begin print_esc("penalty "); print_int(penalty(p));
end
@y
@ @<Display penalty |p|@>=
  begin
    print_esc("penalty "); print_int(penalty(p));
    if subtype(p)=widow_pena then print("(for \chrwidowpenalty)")
    else if subtype(p)=kinsoku_pena then print("(for kinsoku)");
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[13.202] free box: dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
    hlist_node,vlist_node,unset_node: begin flush_node_list(list_ptr(p));
      free_node(p,box_node_size); goto done;
      end;
@y
    hlist_node,vlist_node,dir_node,unset_node: begin
      flush_node_list(list_ptr(p));
      fast_delete_glue_ref(space_ptr(p));
      fast_delete_glue_ref(xspace_ptr(p));
      free_node(p,box_node_size); goto done;
    end;
@z

@x
    kern_node,math_node,penalty_node: do_nothing;
@y
    kern_node,disp_node,math_node,penalty_node: do_nothing;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[14.206] copy box: space_ptr, xspace_ptr
%p[14.206] copy box: dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
hlist_node,vlist_node,unset_node: begin r:=get_node(box_node_size);
  mem[r+6]:=mem[p+6]; mem[r+5]:=mem[p+5]; {copy the last two words}
  list_ptr(r):=copy_node_list(list_ptr(p)); {this affects |mem[r+5]|}
  words:=5;
  end;
rule_node: begin r:=get_node(rule_node_size); words:=rule_node_size;
  end;
ins_node: begin r:=get_node(ins_node_size); mem[r+4]:=mem[p+4];
  add_glue_ref(split_top_ptr(p));
  ins_ptr(r):=copy_node_list(ins_ptr(p)); {this affects |mem[r+4]|}
  words:=ins_node_size-1;
  end;
@y
hlist_node,vlist_node,dir_node,unset_node:
  begin
    r:=get_node(box_node_size);
    mem[r+7]:=mem[p+7];
    mem[r+6]:=mem[p+6]; mem[r+5]:=mem[p+5]; {copy the last three words}
    add_glue_ref(space_ptr(r)); add_glue_ref(xspace_ptr(r));
    list_ptr(r):=copy_node_list(list_ptr(p)); {this affects |mem[r+5]|}
    words:=5;
  end;
rule_node:
  begin r:=get_node(rule_node_size); words:=rule_node_size; end;
ins_node:
  begin
    r:=get_node(ins_node_size); mem[r+4]:=mem[p+4]; mem[r+5]:=mem[p+5];
    add_glue_ref(split_top_ptr(p));
    ins_ptr(r):=copy_node_list(ins_ptr(p)); {this affects |mem[r+4]|}
    words:=ins_node_size-2;
  end;
@z

@x
kern_node,math_node,penalty_node: begin r:=get_node(small_node_size);
  words:=small_node_size;
  end;
@y
kern_node,disp_node,math_node,penalty_node:
  begin
    r:=get_node(small_node_size); words:=small_node_size;
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[15.207][15.208][15.209] inhibit_glue
%p[15.207][15.208][15.209] chg_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d escape=0 {escape delimiter (called \.\\ in {\sl The \TeX book\/})}
@:TeXbook}{\sl The \TeX book@>
@d relax=0 {do nothing ( \.{\\relax} )}
@d left_brace=1 {beginning of a group ( \.\{ )}
@d right_brace=2 {ending of a group ( \.\} )}
@d math_shift=3 {mathematics shift character ( \.\$ )}
@d tab_mark=4 {alignment delimiter ( \.\&, \.{\\span} )}
@d car_ret=5 {end of line ( |carriage_return|, \.{\\cr}, \.{\\crcr} )}
@d out_param=5 {output a macro parameter}
@d mac_param=6 {macro parameter symbol ( \.\# )}
@d sup_mark=7 {superscript ( \.{\char'136} )}
@d sub_mark=8 {subscript ( \.{\char'137} )}
@d ignore=9 {characters to ignore ( \.{\^\^J} )}
@d endv=9 {end of \<v_j> list in alignment template}
@d spacer=10 {characters equivalent to blank space ( \.{\ } )}
@d letter=11 {characters regarded as letters ( \.{A..Z}, \.{a..z} )}
@d other_char=12 {none of the special character types}
@d active_char=13 {characters that invoke macros ( \.{\^\^[} )}
@d par_end=13 {end of paragraph ( \.{\\par} )}
@d match=13 {match a macro parameter}
@d comment=14 {characters that introduce comments ( \.\% )}
@d end_match=14 {end of parameters to macro}
@d stop=14 {end of job ( \.{\\end}, \.{\\dump} )}
@d invalid_char=15 {characters that shouldn't appear ( \.{\^\^?} )}
@d delim_num=15 {specify delimiter numerically ( \.{\\delimiter} )}
@d max_char_code=15 {largest catcode for individual characters}

@ Next are the ordinary run-of-the-mill command codes.  Codes that are
|min_internal| or more represent internal quantities that might be
expanded by `\.{\\the}'.

@d char_num=16 {character specified numerically ( \.{\\char} )}
@d math_char_num=17 {explicit math code ( \.{\\mathchar} )}
@d mark=18 {mark definition ( \.{\\mark} )}
@d xray=19 {peek inside of \TeX\ ( \.{\\show}, \.{\\showbox}, etc.~)}
@d make_box=20 {make a box ( \.{\\box}, \.{\\copy}, \.{\\hbox}, etc.~)}
@d hmove=21 {horizontal motion ( \.{\\moveleft}, \.{\\moveright} )}
@d vmove=22 {vertical motion ( \.{\\raise}, \.{\\lower} )}
@d un_hbox=23 {unglue a box ( \.{\\unhbox}, \.{\\unhcopy} )}
@d un_vbox=24 {unglue a box ( \.{\\unvbox}, \.{\\unvcopy} )}
@d remove_item=25 {nullify last item ( \.{\\unpenalty},
  \.{\\unkern}, \.{\\unskip} )}
@d hskip=26 {horizontal glue ( \.{\\hskip}, \.{\\hfil}, etc.~)}
@d vskip=27 {vertical glue ( \.{\\vskip}, \.{\\vfil}, etc.~)}
@d mskip=28 {math glue ( \.{\\mskip} )}
@d kern=29 {fixed space ( \.{\\kern})}
@d mkern=30 {math kern ( \.{\\mkern} )}
@d leader_ship=31 {use a box ( \.{\\shipout}, \.{\\leaders}, etc.~)}
@d halign=32 {horizontal table alignment ( \.{\\halign} )}
@d valign=33 {vertical table alignment ( \.{\\valign} )}
@d no_align=34 {temporary escape from alignment ( \.{\\noalign} )}
@d vrule=35 {vertical rule ( \.{\\vrule} )}
@d hrule=36 {horizontal rule ( \.{\\hrule} )}
@d insert=37 {vlist inserted in box ( \.{\\insert} )}
@d vadjust=38 {vlist inserted in enclosing paragraph ( \.{\\vadjust} )}
@d ignore_spaces=39 {gobble |spacer| tokens ( \.{\\ignorespaces} )}
@d after_assignment=40 {save till assignment is done ( \.{\\afterassignment} )}
@d after_group=41 {save till group is done ( \.{\\aftergroup} )}
@d break_penalty=42 {additional badness ( \.{\\penalty} )}
@d start_par=43 {begin paragraph ( \.{\\indent}, \.{\\noindent} )}
@d ital_corr=44 {italic correction ( \.{\\/} )}
@d accent=45 {attach accent in text ( \.{\\accent} )}
@d math_accent=46 {attach accent in math ( \.{\\mathaccent} )}
@d discretionary=47 {discretionary texts ( \.{\\-}, \.{\\discretionary} )}
@d eq_no=48 {equation number ( \.{\\eqno}, \.{\\leqno} )}
@d left_right=49 {variable delimiter ( \.{\\left}, \.{\\right} )}
@d math_comp=50 {component of formula ( \.{\\mathbin}, etc.~)}
@d limit_switch=51 {diddle limit conventions ( \.{\\displaylimits}, etc.~)}
@d above=52 {generalized fraction ( \.{\\above}, \.{\\atop}, etc.~)}
@d math_style=53 {style specification ( \.{\\displaystyle}, etc.~)}
@d math_choice=54 {choice specification ( \.{\\mathchoice} )}
@d non_script=55 {conditional math glue ( \.{\\nonscript} )}
@d vcenter=56 {vertically center a vbox ( \.{\\vcenter} )}
@d case_shift=57 {force specific case ( \.{\\lowercase}, \.{\\uppercase}~)}
@d message=58 {send to user ( \.{\\message}, \.{\\errmessage} )}
@d extension=59 {extensions to \TeX\ ( \.{\\write}, \.{\\special}, etc.~)}
@d in_stream=60 {files for reading ( \.{\\openin}, \.{\\closein} )}
@d begin_group=61 {begin local grouping ( \.{\\begingroup} )}
@d end_group=62 {end local grouping ( \.{\\endgroup} )}
@d omit=63 {omit alignment template ( \.{\\omit} )}
@d ex_space=64 {explicit space ( \.{\\\ } )}
@d radical=65 {square root and similar signs ( \.{\\radical} )}
@d end_cs_name=66 {end control sequence ( \.{\\endcsname} )}
@d min_internal=67 {the smallest code that can follow \.{\\the}}
@d char_given=67 {character code defined by \.{\\chardef}}
@d math_given=68 {math code defined by \.{\\mathchardef}}
@d last_item=69 {most recent item ( \.{\\lastpenalty},
  \.{\\lastkern}, \.{\\lastskip} )}
@d max_non_prefixed_command=69 {largest command code that can't be \.{\\global}}

@ The next codes are special; they all relate to mode-independent
assignment of values to \TeX's internal registers or tables.
Codes that are |max_internal| or less represent internal quantities
that might be expanded by `\.{\\the}'.

@d toks_register=70 {token list register ( \.{\\toks} )}
@d assign_toks=71 {special token list ( \.{\\output}, \.{\\everypar}, etc.~)}
@d assign_int=72 {user-defined integer ( \.{\\tolerance}, \.{\\day}, etc.~)}
@d assign_dimen=73 {user-defined length ( \.{\\hsize}, etc.~)}
@d assign_glue=74 {user-defined glue ( \.{\\baselineskip}, etc.~)}
@d assign_mu_glue=75 {user-defined muglue ( \.{\\thinmuskip}, etc.~)}
@d assign_font_dimen=76 {user-defined font dimension ( \.{\\fontdimen} )}
@d assign_font_int=77 {user-defined font integer ( \.{\\hyphenchar},
  \.{\\skewchar} )}
@d set_aux=78 {specify state info ( \.{\\spacefactor}, \.{\\prevdepth} )}
@d set_prev_graf=79 {specify state info ( \.{\\prevgraf} )}
@d set_page_dimen=80 {specify state info ( \.{\\pagegoal}, etc.~)}
@d set_page_int=81 {specify state info ( \.{\\deadcycles},
  \.{\\insertpenalties} )}
@d set_box_dimen=82 {change dimension of box ( \.{\\wd}, \.{\\ht}, \.{\\dp} )}
@d set_shape=83 {specify fancy paragraph shape ( \.{\\parshape} )}
@d def_code=84 {define a character code ( \.{\\catcode}, etc.~)}
@d def_family=85 {declare math fonts ( \.{\\textfont}, etc.~)}
@d set_font=86 {set current font ( font identifiers )}
@d def_font=87 {define a font file ( \.{\\font} )}
@d register=88 {internal register ( \.{\\count}, \.{\\dimen}, etc.~)}
@d max_internal=88 {the largest code that can follow \.{\\the}}
@d advance=89 {advance a register or parameter ( \.{\\advance} )}
@d multiply=90 {multiply a register or parameter ( \.{\\multiply} )}
@d divide=91 {divide a register or parameter ( \.{\\divide} )}
@d prefix=92 {qualify a definition ( \.{\\global}, \.{\\long}, \.{\\outer} )}
@d let=93 {assign a command code ( \.{\\let}, \.{\\futurelet} )}
@d shorthand_def=94 {code definition ( \.{\\chardef}, \.{\\countdef}, etc.~)}
@d read_to_cs=95 {read into a control sequence ( \.{\\read} )}
@d def=96 {macro definition ( \.{\\def}, \.{\\gdef}, \.{\\xdef}, \.{\\edef} )}
@d set_box=97 {set a box ( \.{\\setbox} )}
@d hyph_data=98 {hyphenation data ( \.{\\hyphenation}, \.{\\patterns} )}
@d set_interaction=99 {define level of interaction ( \.{\\batchmode}, etc.~)}
@d max_command=99 {the largest command code seen at |big_switch|}
@y
@d escape=0 {escape delimiter (called \.\\ in {\sl The \TeX book\/})}
@:TeXbook}{\sl The \TeX book@>
@d relax=0 {do nothing ( \.{\\relax} )}
@d left_brace=1 {beginning of a group ( \.\{ )}
@d right_brace=2 {ending of a group ( \.\} )}
@d math_shift=3 {mathematics shift character ( \.\$ )}
@d tab_mark=4 {alignment delimiter ( \.\&, \.{\\span} )}
@d car_ret=5 {end of line ( |carriage_return|, \.{\\cr}, \.{\\crcr} )}
@d out_param=5 {output a macro parameter}
@d mac_param=6 {macro parameter symbol ( \.\# )}
@d sup_mark=7 {superscript ( \.{\char'136} )}
@d sub_mark=8 {subscript ( \.{\char'137} )}
@d ignore=9 {characters to ignore ( \.{\^\^J} )}
@d endv=9 {end of \<v_j> list in alignment template}
@d spacer=10 {characters equivalent to blank space ( \.{\ } )}
@d letter=11 {characters regarded as letters ( \.{A..Z}, \.{a..z} )}
@d other_char=12 {none of the special character types}
@d active_char=13 {characters that invoke macros ( \.{\^\^[} )}
@d par_end=13 {end of paragraph ( \.{\\par} )}
@d match=13 {match a macro parameter}
@d comment=14 {characters that introduce comments ( \.\% )}
@d end_match=14 {end of parameters to macro}
@d stop=14 {end of job ( \.{\\end}, \.{\\dump} )}
@d invalid_char=15 {characters that shouldn't appear ( \.{\^\^?} )}
@d delim_num=15 {specify delimiter numerically ( \.{\\delimiter} )}
@d kanji=16 {kanji}
@d kana=17 {hiragana, katakana, alphabet}
@d other_kchar=18 {kanji codes}
@d max_char_code=18 {largest catcode for individual characters}

@ Next are the ordinary run-of-the-mill command codes.  Codes that are
|min_internal| or more represent internal quantities that might be
expanded by `\.{\\the}'.

@d char_num=max_char_code+1 {character specified numerically ( \.{\\char} )}
@d math_char_num=max_char_code+2 {explicit math code ( \.{\\mathchar} )}
@d mark=max_char_code+3 {mark definition ( \.{\\mark} )}
@d xray=max_char_code+4 {peek inside of \TeX\ ( \.{\\show}, \.{\\showbox}, etc.~)}
@d make_box=max_char_code+5 {make a box ( \.{\\box}, \.{\\copy}, \.{\\hbox}, etc.~)}
@d hmove=max_char_code+6 {horizontal motion ( \.{\\moveleft}, \.{\\moveright} )}
@d vmove=max_char_code+7 {vertical motion ( \.{\\raise}, \.{\\lower} )}
@d un_hbox=max_char_code+8 {unglue a box ( \.{\\unhbox}, \.{\\unhcopy} )}
@d un_vbox=max_char_code+9 {unglue a box ( \.{\\unvbox}, \.{\\unvcopy} )}
@d remove_item=max_char_code+10 {nullify last item ( \.{\\unpenalty},
  \.{\\unkern}, \.{\\unskip} )}
@d hskip=max_char_code+11 {horizontal glue ( \.{\\hskip}, \.{\\hfil}, etc.~)}
@d vskip=max_char_code+12 {vertical glue ( \.{\\vskip}, \.{\\vfil}, etc.~)}
@d mskip=max_char_code+13 {math glue ( \.{\\mskip} )}
@d kern=max_char_code+14 {fixed space ( \.{\\kern})}
@d mkern=max_char_code+15 {math kern ( \.{\\mkern} )}
@d leader_ship=max_char_code+16 {use a box ( \.{\\shipout}, \.{\\leaders}, etc.~)}
@d halign=max_char_code+17 {horizontal table alignment ( \.{\\halign} )}
@d valign=max_char_code+18 {vertical table alignment ( \.{\\valign} )}
@d no_align=max_char_code+19 {temporary escape from alignment ( \.{\\noalign} )}
@d vrule=max_char_code+20 {vertical rule ( \.{\\vrule} )}
@d hrule=max_char_code+21 {horizontal rule ( \.{\\hrule} )}
@d insert=max_char_code+22 {vlist inserted in box ( \.{\\insert} )}
@d vadjust=max_char_code+23 {vlist inserted in enclosing paragraph ( \.{\\vadjust} )}
@d ignore_spaces=max_char_code+24 {gobble |spacer| tokens ( \.{\\ignorespaces} )}
@d after_assignment=max_char_code+25 {save till assignment is done ( \.{\\afterassignment} )}
@d after_group=max_char_code+26 {save till group is done ( \.{\\aftergroup} )}
@d break_penalty=max_char_code+27 {additional badness ( \.{\\penalty} )}
@d start_par=max_char_code+28 {begin paragraph ( \.{\\indent}, \.{\\noindent} )}
@d ital_corr=max_char_code+29 {italic correction ( \.{\\/} )}
@d accent=max_char_code+30 {attach accent in text ( \.{\\accent} )}
@d math_accent=max_char_code+31 {attach accent in math ( \.{\\mathaccent} )}
@d discretionary=max_char_code+32 {discretionary texts ( \.{\\-}, \.{\\discretionary} )}
@d eq_no=max_char_code+33 {equation number ( \.{\\eqno}, \.{\\leqno} )}
@d left_right=max_char_code+34 {variable delimiter ( \.{\\left}, \.{\\right} )}
@d math_comp=max_char_code+35 {component of formula ( \.{\\mathbin}, etc.~)}
@d limit_switch=max_char_code+36 {diddle limit conventions ( \.{\\displaylimits}, etc.~)}
@d above=max_char_code+37 {generalized fraction ( \.{\\above}, \.{\\atop}, etc.~)}
@d math_style=max_char_code+38 {style specification ( \.{\\displaystyle}, etc.~)}
@d math_choice=max_char_code+39 {choice specification ( \.{\\mathchoice} )}
@d non_script=max_char_code+40 {conditional math glue ( \.{\\nonscript} )}
@d vcenter=max_char_code+41 {vertically center a vbox ( \.{\\vcenter} )}
@d case_shift=max_char_code+42 {force specific case ( \.{\\lowercase}, \.{\\uppercase}~)}
@d message=max_char_code+43 {send to user ( \.{\\message}, \.{\\errmessage} )}
@d extension=max_char_code+44 {extensions to \TeX\ ( \.{\\write}, \.{\\special}, etc.~)}
@d in_stream=max_char_code+45 {files for reading ( \.{\\openin}, \.{\\closein} )}
@d begin_group=max_char_code+46 {begin local grouping ( \.{\\begingroup} )}
@d end_group=max_char_code+47 {end local grouping ( \.{\\endgroup} )}
@d omit=max_char_code+48 {omit alignment template ( \.{\\omit} )}
@d ex_space=max_char_code+49 {explicit space ( \.{\\\ } )}
@d radical=max_char_code+50 {square root and similar signs ( \.{\\radical} )}
@d end_cs_name=max_char_code+51 {end control sequence ( \.{\\endcsname} )}
@d min_internal=max_char_code+52 {the smallest code that can follow \.{\\the}}
@d char_given=max_char_code+52 {character code defined by \.{\\chardef}}
@d math_given=max_char_code+53 {math code defined by \.{\\mathchardef}}
@d last_item=max_char_code+54 {most recent item ( \.{\\lastpenalty},
  \.{\\lastkern}, \.{\\lastskip} )}
@d inhibit_glue=max_char_code+55 {inhibit adjust glue ( \.{\\inhibitglue} )}
@d chg_dir=max_char_code+56 {change dir mode by \.{\\tate}, \.{\\yoko}}
@d max_non_prefixed_command=max_char_code+56 {largest command code that can't be \.{\\global}}

@ The next codes are special; they all relate to mode-independent
assignment of values to \TeX's internal registers or tables.
Codes that are |max_internal| or less represent internal quantities
that might be expanded by `\.{\\the}'.

@d toks_register=max_non_prefixed_command+1 {token list register ( \.{\\toks} )}
@d assign_toks=toks_register+1 {special token list ( \.{\\output}, \.{\\everypar}, etc.~)}
@d assign_int=assign_toks+1 {user-defined integer ( \.{\\tolerance}, \.{\\day}, etc.~)}
@d assign_dimen=assign_int+1 {user-defined length ( \.{\\hsize}, etc.~)}
@d assign_glue=assign_dimen+1 {user-defined glue ( \.{\\baselineskip}, etc.~)}
@d assign_mu_glue=assign_glue+1 {user-defined muglue ( \.{\\thinmuskip}, etc.~)}
@d assign_font_dimen=assign_mu_glue+1 {user-defined font dimension ( \.{\\fontdimen} )}
@d assign_font_int=assign_font_dimen+1
{user-defined font integer ( \.{\\hyphenchar}, \.{\\skewchar} )}
@d assign_kinsoku=assign_font_int+1
{user-defined kinsoku character ( \.{\\prebreakpenalty}, \.{\\postbreakpenalty} )}
@d assign_inhibit_xsp_code=assign_kinsoku+1
{user-defined inhibit xsp character ( \.{\\inhibitxspcode} )}
@d set_aux=assign_inhibit_xsp_code+1 {specify state info ( \.{\\spacefactor}, \.{\\prevdepth} )}
@d set_prev_graf=set_aux+1 {specify state info ( \.{\\prevgraf} )}
@d set_page_dimen=set_prev_graf+1 {specify state info ( \.{\\pagegoal}, etc.~)}
@d set_page_int=set_page_dimen+1 {specify state info ( \.{\\deadcycles},
  \.{\\insertpenalties} )}
@d set_box_dimen=set_page_int+1 {change dimension of box ( \.{\\wd}, \.{\\ht}, \.{\\dp} )}
@d set_shape=set_box_dimen+1 {specify fancy paragraph shape ( \.{\\parshape} )}
@d def_code=set_shape+1 {define a character code ( \.{\\catcode}, etc.~)}
@d def_family=def_code+1 {declare math fonts ( \.{\\textfont}, etc.~)}
@d set_font=def_family+1 {set current font ( font identifiers )}
@d def_font=set_font+1 {define a font file ( \.{\\font} )}
@d def_jfont=def_font+1 {define a font file ( \.{\\jfont} )}
@d def_tfont=def_jfont+1 {define a font file ( \.{\\tfont} )}
@d register=def_tfont+1 {internal register ( \.{\\count}, \.{\\dimen}, etc.~)}
@d max_internal=register {the largest code that can follow \.{\\the}}
@d advance=max_internal+1 {advance a register or parameter ( \.{\\advance} )}
@d multiply=advance+1 {multiply a register or parameter ( \.{\\multiply} )}
@d divide=multiply+1 {divide a register or parameter ( \.{\\divide} )}
@d prefix=divide+1 {qualify a definition ( \.{\\global}, \.{\\long}, \.{\\outer} )}
@d let=prefix+1 {assign a command code ( \.{\\let}, \.{\\futurelet} )}
@d shorthand_def=let+1 {code definition ( \.{\\chardef}, \.{\\countdef}, etc.~)}
@d read_to_cs=shorthand_def+1 {read into a control sequence ( \.{\\read} )}
@d def=read_to_cs+1 {macro definition ( \.{\\def}, \.{\\gdef}, \.{\\xdef}, \.{\\edef} )}
@d set_box=def+1 {set a box ( \.{\\setbox} )}
@d hyph_data=set_box+1 {hyphenation data ( \.{\\hyphenation}, \.{\\patterns} )}
@d set_interaction=hyph_data+1 {define level of interaction ( \.{\\batchmode}, etc.~)}
@d set_auto_spacing=set_interaction+1 {set auto spaceing mode
  ( \.{\\autospacing}, \.{\\noautospacing}, ( \.{\\autospacing}, \.{\\noautospacing} )}
@d max_command=set_auto_spacing {the largest command code seen at |big_switch|}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[16.211] print dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
print(" mode");
end;
@y
  print(" mode");
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[16.212] last_jchr
%p[16.212] direction, adjust direction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!list_state_record=record@!mode_field:-mmode..mmode;
  @!head_field,@!tail_field: pointer;
  @!pg_field,@!aux_field,@!ml_field: integer;
  end;
@y
@!list_state_record=record
    @!mode_field:-mmode..mmode;
    @!dir_field,@!adj_dir_field: -dir_dtou..dir_dtou;
    @!pdisp_field: scaled;
    @!head_field,@!tail_field,@!pnode_field,@!last_jchr_field: pointer;
    @!pg_field,@!aux_field,@!ml_field: integer;
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[16.213] last_jchr
%p[16.213] direction, adjust direction, displacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @d mode==cur_list.mode_field {current mode}
@d head==cur_list.head_field {header node of current list}
@d tail==cur_list.tail_field {final node on current list}
@d prev_graf==cur_list.pg_field {number of paragraph lines accumulated}
@d aux==cur_list.aux_field {auxiliary data about the current list}
@d prev_depth==aux {the name of |aux| in vertical mode}
@d space_factor==aux {the name of |aux| in horizontal mode}
@d incompleat_noad==aux {the name of |aux| in math mode}
@d mode_line==cur_list.ml_field {source file line number at beginning of list}
@y
@ @d mode==cur_list.mode_field {current mode}
@d direction==cur_list.dir_field {current direction}
@d adjust_dir==cur_list.adj_dir_field {current adjust direction}
@d head==cur_list.head_field {header node of current list}
@d tail==cur_list.tail_field {final node on current list}
@d prev_node==cur_list.pnode_field {previous to last disp_node}
@d prev_disp==cur_list.pdisp_field {displacemant at prev_node}
@d last_jchr==cur_list.last_jchr_field {final jchar node on current list}
@d prev_graf==cur_list.pg_field {number of paragraph lines accumulated}
@d aux==cur_list.aux_field {auxiliary data about the current list}
@d prev_depth==aux {the name of |aux| in vertical mode}
@d space_factor==aux {the name of |aux| in horizontal mode}
@d incompleat_noad==aux {the name of |aux| in math mode}
@d mode_line==cur_list.ml_field {source file line number at beginning of list}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[16.214] prev_append: disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d tail_append(#)==begin link(tail):=#; tail:=link(tail);
  end
@y
@d tail_append(#)==
  begin
    link(tail):=#; tail:=link(tail);
  end
@d prev_append(#)==
  begin
    link(prev_node):=#;
    link(link(prev_node)):=tail; prev_node:=link(prev_node);
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[16.215] init nesting: last_jchr
%p[16.215] init nesting: direction, adjust direction, displacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
mode:=vmode; head:=contrib_head; tail:=contrib_head;
@y
mode:=vmode; direction:=dir_yoko; adjust_dir:=dir_yoko;
head:=contrib_head; tail:=contrib_head; prev_node:=contrib_head;
prev_disp:=0;
last_jchr:=null;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[16.216] push_nest: last_jchr
%p[16.216] push_nest: displacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
incr(nest_ptr); head:=get_avail; tail:=head; prev_graf:=0; mode_line:=line;
@y
incr(nest_ptr); head:=new_null_box; tail:=head; prev_node:=head;
prev_graf:=0; mode_line:=line; last_jchr:=null;
prev_disp:=0;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[16.217] pop_nest last_jchr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure pop_nest; {leave a semantic level, re-enter the old}
begin free_avail(head); decr(nest_ptr); cur_list:=nest[nest_ptr];
end;
@y
@p
procedure pop_nest; {leave a semantic level, re-enter the old}
begin
  fast_delete_glue_ref(space_ptr(head));
  fast_delete_glue_ref(xspace_ptr(head));
  free_node(head,box_node_size); decr(nest_ptr); cur_list:=nest[nest_ptr];
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[17.218] show_activities : direction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  print_nl("### "); print_mode(m);
@y
    print_nl("### "); print_direction(nest[p].dir_field);
    print(", "); print_mode(m);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.224] kanji_skip_code xkanji_skip_code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d thin_mu_skip_code=15 {thin space in math formula}
@d med_mu_skip_code=16 {medium space in math formula}
@d thick_mu_skip_code=17 {thick space in math formula}
@d glue_pars=18 {total number of glue parameters}
@y
@d kanji_skip_code=15
@d xkanji_skip_code=16
@d thin_mu_skip_code=17 {thin space in math formula}
@d med_mu_skip_code=18 {medium space in math formula}
@d thick_mu_skip_code=19 {thick space in math formula}
@d glue_pars=20 {total number of glue parameters}
@d jfm_skip=20
@z

@x
@d par_fill_skip==glue_par(par_fill_skip_code)
@d thin_mu_skip==glue_par(thin_mu_skip_code)
@d med_mu_skip==glue_par(med_mu_skip_code)
@d thick_mu_skip==glue_par(thick_mu_skip_code)
@y
@d par_fill_skip==glue_par(par_fill_skip_code)
@d thin_mu_skip==glue_par(thin_mu_skip_code)
@d med_mu_skip==glue_par(med_mu_skip_code)
@d thick_mu_skip==glue_par(thick_mu_skip_code)
@d kanji_skip==glue_par(kanji_skip_code)
@d xkanji_skip==glue_par(xkanji_skip_code)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.225] kanji_skip_code xkanji_skip_code 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
med_mu_skip_code: print_esc("medmuskip");
thick_mu_skip_code: print_esc("thickmuskip");
othercases print("[unknown glue parameter!]")
@y
med_mu_skip_code: print_esc("medmuskip");
thick_mu_skip_code: print_esc("thickmuskip");
kanji_skip_code: print_esc("kanjiskip");
xkanji_skip_code: print_esc("xkanjiskip");
jfm_skip: print("refer from jfm");
othercases print("[unknown glue parameter!]")
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.226] kanji_skip_code xkanji_skip_code 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
primitive("medmuskip",assign_mu_glue,glue_base+med_mu_skip_code);@/
@!@:med_mu_skip_}{\.{\\medmuskip} primitive@>
primitive("thickmuskip",assign_mu_glue,glue_base+thick_mu_skip_code);@/
@!@:thick_mu_skip_}{\.{\\thickmuskip} primitive@>
@y
primitive("medmuskip",assign_mu_glue,glue_base+med_mu_skip_code);@/
@!@:med_mu_skip_}{\.{\\medmuskip} primitive@>
primitive("thickmuskip",assign_mu_glue,glue_base+thick_mu_skip_code);@/
@!@:thick_mu_skip_}{\.{\\thickmuskip} primitive@>
primitive("kanjiskip",assign_glue,glue_base+kanji_skip_code);@/
@!@:kanji_skip_}{\.{\\kanjiskip} primitive@>
primitive("xkanjiskip",assign_glue,glue_base+xkanji_skip_code);@/
@!@:xkanji_skip_}{\.{\\xkanjiskip} primitive@>
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.230] cat_code_size cur_jfont_loc
%j[17.230] auto_spacing auto_xspacing inhibit_xsp_code
%p[17.230] cur_tfont_loc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d cat_code_base=math_font_base+48
  {table of 128 command codes (the ``catcodes'')}
@d lc_code_base=cat_code_base+128 {table of 128 lowercase mappings}
@d uc_code_base=lc_code_base+128 {table of 128 uppercase mappings}
@d sf_code_base=uc_code_base+128 {table of 128 spacefactor mappings}
@d math_code_base=sf_code_base+128 {table of 128 math mode mappings}
@d int_base=math_code_base+128 {beginning of region 5}
@y
@d cur_jfont_loc=math_font_base+48
@d cur_tfont_loc=cur_jfont_loc+1
@d auto_spacing_code=cur_tfont_loc+1
@d auto_xspacing_code=auto_spacing_code+1
@d cat_code_base=auto_xspacing_code+1
  {table of 256 command codes (the ``catcodes'')}
@d auto_xsp_code_base=cat_code_base+256 {table of 128 auto spacer flag}
@d inhibit_xsp_code_base=auto_xsp_code_base+128
@d lc_code_base=inhibit_xsp_code_base+256 {table of 128 lowercase mappings}
@d uc_code_base=lc_code_base+128 {table of 128 uppercase mappings}
@d sf_code_base=uc_code_base+128 {table of 128 spacefactor mappings}
@d math_code_base=sf_code_base+128 {table of 128 math mode mappings}
@d int_base=math_code_base+128 {beginning of region 5}
@d cur_jfont==equiv(cur_jfont_loc)
@d cur_tfont==equiv(cur_tfont_loc)
@d auto_xsp_code(#)==equiv(auto_xsp_code_base+#)
@d inhibit_xsp_type(#)==eq_type(inhibit_xsp_code_base+#)
@d inhibit_xsp_code(#)==equiv(inhibit_xsp_code_base+#)
@d auto_spacing==equiv(auto_spacing_code)
@d auto_xspacing==equiv(auto_xspacing_code)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.232] initialize of cat_code
%p[17.232] KANJI font(cur_jfont) and TATE-kumi font(cur_tfont)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ We initialize most things to null or undefined values. An undefined font
is represented by the internal code |font_base|.

However, the character code tables are given initial values based on the
conventional interpretation of ASCII code. These initial values should
not be changed when \TeX\ is adapted for use with non-English languages;
all changes to the initialization conventions should be made in format
packages, not in \TeX\ itself, so that global interchange of formats is
possible.

@d null_font==font_base
@d var_code==@'70000 {math code meaning ``use the current family''}

@<Initialize table entries...@>=
par_shape_ptr:=null; eq_type(par_shape_loc):=shape_ref;
eq_level(par_shape_loc):=level_one;@/
for k:=output_routine_loc to toks_base+255 do
  eqtb[k]:=eqtb[undefined_control_sequence];
box(0):=null; eq_type(box_base):=box_ref; eq_level(box_base):=level_one;
for k:=box_base+1 to box_base+255 do eqtb[k]:=eqtb[box_base];
cur_font:=null_font; eq_type(cur_font_loc):=data;
eq_level(cur_font_loc):=level_one;@/
for k:=math_font_base to math_font_base+47 do eqtb[k]:=eqtb[cur_font_loc];
equiv(cat_code_base):=0; eq_type(cat_code_base):=data;
eq_level(cat_code_base):=level_one;@/
for k:=cat_code_base+1 to int_base-1 do eqtb[k]:=eqtb[cat_code_base];
for k:=0 to 127 do
  begin cat_code(k):=other_char; math_code(k):=hi(k); sf_code(k):=1000;
  end;
cat_code(carriage_return):=car_ret; cat_code(" "):=spacer;
cat_code("\"):=escape; cat_code("%"):=comment;
cat_code(invalid_code):=invalid_char; cat_code(null_code):=ignore;
for k:="0" to "9" do math_code(k):=hi(k+var_code);
for k:="A" to "Z" do
  begin cat_code(k):=letter; cat_code(k+"a"-"A"):=letter;@/
  math_code(k):=hi(k+var_code+@"100);
  math_code(k+"a"-"A"):=hi(k+"a"-"A"+var_code+@"100);@/
  lc_code(k):=k+"a"-"A"; lc_code(k+"a"-"A"):=k+"a"-"A";@/
  uc_code(k):=k; uc_code(k+"a"-"A"):=k;@/
  sf_code(k):=999;
  end;
@y
@ We initialize most things to null or undefined values. An undefined font
is represented by the internal code |font_base|.

However, the character code tables are given initial values based on the
conventional interpretation of ASCII code. These initial values should
not be changed when \TeX\ is adapted for use with non-English languages;
all changes to the initialization conventions should be made in format
packages, not in \TeX\ itself, so that global interchange of formats is
possible.

@d null_font==font_base
@d var_code==@'70000 {math code meaning ``use the current family''}

@<Initialize table entries...@>=
eq_level(par_shape_loc):=level_one;@/
for k:=output_routine_loc to toks_base+255 do
  eqtb[k]:=eqtb[undefined_control_sequence];
box(0):=null; eq_type(box_base):=box_ref; eq_level(box_base):=level_one;
for k:=box_base+1 to box_base+255 do eqtb[k]:=eqtb[box_base];
cur_font:=null_font; eq_type(cur_font_loc):=data;
eq_level(cur_font_loc):=level_one;@/
cur_jfont:=null_font; eq_type(cur_jfont_loc):=data;
eq_level(cur_jfont_loc):=level_one;@/
cur_tfont:=null_font; eq_type(cur_tfont_loc):=data;
eq_level(cur_tfont_loc):=level_one;@/
for k:=math_font_base to math_font_base+47 do eqtb[k]:=eqtb[cur_font_loc];
equiv(cat_code_base):=0; eq_type(cat_code_base):=data;
eq_level(cat_code_base):=level_one;@/
for k:=cat_code_base+1 to int_base-1 do eqtb[k]:=eqtb[cat_code_base];
eqtb[auto_spacing_code]:=eqtb[cat_code_base];
eqtb[auto_xspacing_code]:=eqtb[cat_code_base];
par_shape_ptr:=null; eq_type(par_shape_loc):=shape_ref;
for k:=0 to 127 do
  begin cat_code(k):=other_char; math_code(k):=hi(k);
  sf_code(k):=1000;
  end;
for k:=0 to 255 do begin inhibit_xsp_code(k):=0; inhibit_xsp_type(k):=0; end;
cat_code(carriage_return):=car_ret; cat_code(" "):=spacer;
cat_code("\"):=escape; cat_code("%"):=comment;
cat_code(invalid_code):=invalid_char; cat_code(null_code):=ignore;
for k:="0" to "9" do 
  begin math_code(k):=hi(k+var_code);
  auto_xsp_code(k):=3;
  end;
for k:="A" to "Z" do
  begin cat_code(k):=letter; cat_code(k+"a"-"A"):=letter;@/
  math_code(k):=hi(k+var_code+@"100);
  math_code(k+"a"-"A"):=hi(k+"a"-"A"+var_code+@"100);@/
  lc_code(k):=k+"a"-"A"; lc_code(k+"a"-"A"):=k+"a"-"A";@/
  uc_code(k):=k; uc_code(k+"a"-"A"):=k;@/
  auto_xsp_code(k):=3; auto_xsp_code(k+"a"-"A"):=3;@/
  sf_code(k):=999;
  end;
for k:=128 to 255 do cat_code(k):=invalid_char;
cat_code(129):=other_kchar; cat_code(130):=kana;
cat_code(131):=kana; cat_code(132):=kana;
for k:=136 to 159 do cat_code(k):=kanji;
for k:=224 to 234 do cat_code(k):=kanji;
jflag:=0;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.236][17.237][17.238] cur_jfam_code jchar_widow_penalty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d cur_fam_code=44 {current family}
@d escape_char_code=45 {escape character for token output}
@d default_hyphen_char_code=46 {value of \.{\\hyphenchar} when a font is loaded}
@d default_skew_char_code=47 {value of \.{\\skewchar} when a font is loaded}
@d end_line_char_code=48 {character placed at the right end of the buffer}
@d new_line_char_code=49 {character that prints as |print_ln|}
@d int_pars=50 {total number of integer parameters}
@d count_base=int_base+int_pars {256 user \.{\\count} registers}
@y
@d cur_fam_code=44 {current family}
@d cur_jfam_code=45 {current kanji family}
@d escape_char_code=46 {escape character for token output}
@d default_hyphen_char_code=47 {value of \.{\\hyphenchar} when a font is loaded}
@d default_skew_char_code=48 {value of \.{\\skewchar} when a font is loaded}
@d end_line_char_code=49 {character placed at the right end of the buffer}
@d new_line_char_code=50 {character that prints as |print_ln|}
@d jchr_widow_penalty_code=51
			{penalty for creating a widow KANJI character line}
@d int_pars=52 {total number of integer parameters}
@d count_base=int_base+int_pars {256 user \.{\\count} registers}
@z

@x
@d global_defs==int_par(global_defs_code)
@d cur_fam==int_par(cur_fam_code)
@d escape_char==int_par(escape_char_code)
@y
@d global_defs==int_par(global_defs_code)
@d cur_fam==int_par(cur_fam_code)
@d cur_jfam==int_par(cur_jfam_code)
@d escape_char==int_par(escape_char_code)
@d jchr_widow_penalty==int_par(jchr_widow_penalty_code)
@z

@x
new_line_char_code:print_esc("newlinechar");
@y
new_line_char_code:print_esc("newlinechar");
cur_jfam_code:print_esc("jfam");
jchr_widow_penalty_code:print_esc("jcharwidowpenalty");
@z

@x
primitive("newlinechar",assign_int,int_base+new_line_char_code);@/
@!@:new_line_char_}{\.{\\newlinechar} primitive@>
@y
primitive("newlinechar",assign_int,int_base+new_line_char_code);@/
@!@:new_line_char_}{\.{\\newlinechar} primitive@>
primitive("jfam",assign_int,int_base+cur_jfam_code);@/
@!@:cur_jfam_}{\.{\\jfam} primitive@>
primitive("jcharwidowpenalty",assign_int,int_base+jchr_widow_penalty_code);@/
@!@:jchr_widow_penalty}{\.{\\jcharwidowpenalty} primitive@>
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [17.241] fix_date_and_time
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The following procedure, which is called just before \TeX\ initializes its
input and output, establishes the initial values of the date and time.
@^system dependencies@>
Since standard \PASCAL\ cannot provide such information, something special
is needed. The program here simply specifies July 4, 1776, at noon; but
users probably want a better approximation to the truth.

@p procedure fix_date_and_time;
begin time:=12*60; {minutes since midnight}
day:=4; {fourth day of the month}
month:=7; {seventh month of the year}
year:=1776; {Anno Domini}
end;
@y
@ The following procedure, which is called just before \TeX\ initializes its
input and output, establishes the initial values of the date and time.
It calls a macro-defined |date_and_time| routine.  Date_and_time
("dateandtime") in turn is a C macro, which calls get_date_and_time, passing
it the addresses of the day, month, etc., so they can be set by the
routine.  Get_date_and_time also sets up interrupt catching if that
is conditionally compiled in the C code.
@^system dependencies@>

@d fix_date_and_time==date_and_time(time,day,month,year)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.247] kinsoku
%p[17.247] t_baseline_shift, y_baseline_shift
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d h_offset_code=18 {amount of horizontal offset when shipping pages out}
@d v_offset_code=19 {amount of vertical offset when shipping pages out}
@d dimen_pars=20 {total number of dimension parameters}
@d scaled_base=dimen_base+dimen_pars
  {table of 256 user-defined \.{\\dimen} registers}
@d eqtb_size=scaled_base+255 {largest subscript of |eqtb|}
@#
@d dimen(#)==eqtb[scaled_base+#].sc
@d dimen_par(#)==eqtb[dimen_base+#].sc {a scaled quantity}
@y
@d h_offset_code=18 {amount of horizontal offset when shipping pages out}
@d v_offset_code=19 {amount of vertical offset when shipping pages out}
@d t_baseline_shift_code=20 {shift amount when mixing TATE-kumi and Alphabet}
@d y_baseline_shift_code=21 {shift amount when mixing YOKO-kumi and Alphabet}
@d dimen_pars=22 {total number of dimension parameters}
@d scaled_base=dimen_base+dimen_pars
  {table of 256 user-defined \.{\\dimen} registers}
@d kinsoku_base=scaled_base+256 {table of 256-2word kinsoku registers}
@d eqtb_size=kinsoku_base+511 {largest subscript of |eqtb|}
@#
@d kinsoku_type(#)==eq_type(kinsoku_base+#)
@d kinsoku_code(#)==equiv(kinsoku_base+#)
@d kinsoku(#)==eqtb[kinsoku_base+1+#].int
@d dimen(#)==eqtb[scaled_base+#].sc
@d dimen_par(#)==eqtb[dimen_base+#].sc {a scaled quantity}
@z

@x
@d h_offset==dimen_par(h_offset_code)
@d v_offset==dimen_par(v_offset_code)
@y
@d h_offset==dimen_par(h_offset_code)
@d v_offset==dimen_par(v_offset_code)
@d t_baseline_shift==dimen_par(t_baseline_shift_code)
@d y_baseline_shift==dimen_par(y_baseline_shift_code)
@z

@x
h_offset_code:print_esc("hoffset");
v_offset_code:print_esc("voffset");
othercases print("[unknown dimen parameter!]")
@y
h_offset_code:print_esc("hoffset");
v_offset_code:print_esc("voffset");
t_baseline_shift_code:print_esc("tbaselineshift");
y_baseline_shift_code:print_esc("ybaselineshift");
othercases print("[unknown dimen parameter!]")
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[17.248] rotate offset
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
primitive("hoffset",assign_dimen,dimen_base+h_offset_code);@/
@!@:h_offset_}{\.{\\hoffset} primitive@>
primitive("voffset",assign_dimen,dimen_base+v_offset_code);@/
@!@:v_offset_}{\.{\\voffset} primitive@>
@y
primitive("hoffset",assign_dimen,dimen_base+h_offset_code);@/
@!@:h_offset_}{\.{\\hoffset} primitive@>
primitive("voffset",assign_dimen,dimen_base+v_offset_code);@/
@!@:v_offset_}{\.{\\voffset} primitive@>
primitive("tbaselineshift",assign_dimen,dimen_base+t_baseline_shift_code);@/
@!@:t_baseline_shift_}{\.{\\tbaselineshift} primitive@>
primitive("ybaselineshift",assign_dimen,dimen_base+y_baseline_shift_code);@/
@!@:y_baseline_shift_}{\.{\\ybaselineshift} primitive@>
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.250] init eqtb
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
for k:=dimen_base to eqtb_size do eqtb[k].sc:=0;
@y
for k:=dimen_base to eqtb_size do eqtb[k].sc:=0;
k:=kinsoku_base;
while k < eqtb_size do begin eq_level(k):=level_one; incr2(k); end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.252] show_eqtb
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else if n<=eqtb_size then @<Show equivalent |n|, in region 6@>
else print_char("?"); {this can't happen either}
end;
tats
@y
else if n<kinsoku_base then @<Show equivalent |n|, in region 6@>
else if n<=eqtb_size then @<Show equivalent |n|, in region 7@>
else print_char("?"); {this can't happen either}
end;
tats

@ @<Show equivalent |n|, in region 7@>=
print("kinsoku")
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[17.253] xeq_level & init eqtb
% Change eqtb to zeqtb
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!eqtb:array[active_base..eqtb_size] of memory_word;
@!xeq_level:array[int_base..eqtb_size] of quarterword;

@ @<Set init...@>=
for k:=int_base to eqtb_size do xeq_level[k]:=level_one;
@y
@!zeqtb:array[active_base..eqtb_size] of memory_word;
@!xeq_level:array[int_base..kinsoku_base-1] of quarterword;

@ @<Set init...@>=
for k:=int_base to kinsoku_base-1 do xeq_level[k]:=level_one;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [18.262] More useless unsigned comparisons to zero
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else if (text(p)<0)or(text(p)>=str_ptr) then print_esc("NONEXISTENT.")
@y
else if (text(p)>=str_ptr) then print_esc("NONEXISTENT.")
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[18.265][18.266] \jfont \tfont
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
primitive("font",def_font,0);@/
@!@:font_}{\.{\\font} primitive@>
@y
primitive("font",def_font,0);@/
@!@:font_}{\.{\\font} primitive@>
primitive("jfont",def_jfont,0);@/
@!@:jfont_}{\.{\\jfont} primitive@>
primitive("tfont",def_tfont,0);@/
@!@:tfont_}{\.{\\tfont} primitive@>
@z

@x
def_font: print_esc("font");
@y
def_font: print_esc("font");
def_jfont: print_esc("jfont");
def_tfont: print_esc("tfont");
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[19.276] save double word registr: kinsoku
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure eq_save(@!p:pointer;@!l:quarterword); {saves |eqtb[p]|}
begin check_full_save_stack;
if l=level_zero then save_type(save_ptr):=restore_zero
else  begin save_stack[save_ptr]:=eqtb[p]; incr(save_ptr);
  save_type(save_ptr):=restore_old_value;
  end;
save_level(save_ptr):=l; save_index(save_ptr):=p; incr(save_ptr);
end;
@y
@p procedure eq_save(@!p:pointer;@!l:quarterword); {saves |eqtb[p]|}
begin check_full_save_stack;
if l=level_zero then save_type(save_ptr):=restore_zero
else  begin save_stack[save_ptr]:=eqtb[p]; incr(save_ptr);
  if p>=kinsoku_base then begin
    save_stack[save_ptr]:=eqtb[p+1]; incr(save_ptr) end;
  save_type(save_ptr):=restore_old_value;
  end;
save_level(save_ptr):=l; save_index(save_ptr):=p; incr(save_ptr);
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[19.278] eq_dword_define
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure eq_word_define(@!p:pointer;@!w:integer);
begin if xeq_level[p]<>cur_level then
  begin eq_save(p,xeq_level[p]); xeq_level[p]:=cur_level;
  end;
eqtb[p].int:=w;
end;
@y
@p procedure eq_word_define(@!p:pointer;@!w:integer);
begin if xeq_level[p]<>cur_level then
  begin eq_save(p,xeq_level[p]); xeq_level[p]:=cur_level;
  end;
eqtb[p].int:=w;
end;
@#
procedure eq_dword_define
     (@!p:pointer;@!t:quarterword;@!e:integer;x:integer); {new data for |eqtb|}
var cx:KANJI_code;
begin if (eq_level(p)<>cur_level) and (cur_level>level_one) then
  eq_save(p,eq_level(p))
else if (cur_level=level_one) and (x=0) then t:=0;
cx:=tokanji(e);
eq_level(p):=cur_level; eq_type(p):=t; equiv(p):=cx; eqtb[p+1].int:=x;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[19.279] geq_dword_define
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure geq_word_define(@!p:pointer;@!w:integer); {global |eq_word_define|}
begin eqtb[p].int:=w; xeq_level[p]:=level_one;
end;
@y
procedure geq_word_define(@!p:pointer;@!w:integer); {global |eq_word_define|}
begin eqtb[p].int:=w; xeq_level[p]:=level_one;
end;

procedure geq_dword_define
     (@!p:pointer;@!t:quarterword;@!e:integer;x:integer); {global |eq_define|}
var cx:KANJI_code;
begin 
cx:=tokanji(e); if x=0 then t:=0;
eq_level(p):=level_one; eq_type(p):=t; equiv(p):=cx; eqtb[p+1].int:=x;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[19.278] restore dword register
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else if xeq_level[p]<>level_one then
  begin eqtb[p]:=save_stack[save_ptr]; xeq_level[p]:=l;
  @!stat if tracing_restores>0 then restore_trace(p,"restoring");@+tats@;@/
  end
else  begin
  @!stat if tracing_restores>0 then restore_trace(p,"retaining");@+tats@;@/
  end
@y
  else if p<kinsoku_base then
    if xeq_level[p]<>level_one then begin
      eqtb[p]:=save_stack[save_ptr]; xeq_level[p]:=l;
      @!stat if tracing_restores>0 then restore_trace(p,"restoring");@+tats@;@/
    end else begin
      @!stat if tracing_restores>0 then restore_trace(p,"retaining");@+tats@;@/
    end
  else if eq_level(p)=level_one then begin
    decr(save_ptr);
    @!stat if tracing_restores>0 then restore_trace(p,"retaining");@+tats@;@/
  end else begin
    eqtb[p+1]:=save_stack[save_ptr]; decr(save_ptr);
    eqtb[p]:=save_stack[save_ptr];
    @!stat if tracing_restores>0 then restore_trace(p,"restoring");@+tats@;@/
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[20.289] cs_token_flag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d cs_token_flag==@'10000 {amount added to the |eqtb| location in a
  token that stands for a control sequence; is a multiple of~256}
@d left_brace_token=@'0400 {$2^8\cdot|left_brace|$}
@d left_brace_limit=@'1000 {$2^8\cdot(|left_brace|+1)$}
@d right_brace_token=@'1000 {$2^8\cdot|right_brace|$}
@d right_brace_limit=@'1400 {$2^8\cdot(|right_brace|+1)$}
@d math_shift_token=@'1400 {$2^8\cdot|math_shift|$}
@d tab_token=@'2000 {$2^8\cdot|tab_mark|$}
@d out_param_token=@'2400 {$2^8\cdot|out_param|$}
@d space_token=@'5040 {$2^8\cdot|spacer|+|" "|$}
@d letter_token=@'5400 {$2^8\cdot|letter|$}
@d other_token=@'6000 {$2^8\cdot|other_char|$}
@d match_token=@'6400 {$2^8\cdot|match|$}
@d end_match_token=@'7000 {$2^8\cdot|end_match|$}
@y
@d cs_token_flag==@'13000 {amount added to the |eqtb| location in a
  token that stands for a control sequence; is a multiple of~256}
@d left_brace_token=@'0400 {$2^8\cdot|left_brace|$}
@d left_brace_limit=@'1000 {$2^8\cdot(|left_brace|+1)$}
@d right_brace_token=@'1000 {$2^8\cdot|right_brace|$}
@d right_brace_limit=@'1400 {$2^8\cdot(|right_brace|+1)$}
@d math_shift_token=@'1400 {$2^8\cdot|math_shift|$}
@d tab_token=@'2000 {$2^8\cdot|tab_mark|$}
@d out_param_token=@'2400 {$2^8\cdot|out_param|$}
@d space_token=@'5040 {$2^8\cdot|spacer|+|" "|$}
@d letter_token=@'5400 {$2^8\cdot|letter|$}
@d other_token=@'6000 {$2^8\cdot|other_char|$}
@d match_token=@'6400 {$2^8\cdot|match|$}
@d end_match_token=@'7000 {$2^8\cdot|end_match|$}
@d kanji_token_base=@'10000 {$2^8\cdot|kanji|$}
@d jother_token=@'11000 {$2^8\cdot|other_kchar|$}
@d kanji_token_end=@'11400 {$2^8\cdot|other_kchar+1|$}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [20.293] More useless unsigned comparisons to zero
%j[20.293][20.294] show_token_list
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if info(p)>=cs_token_flag then print_cs(info(p)-cs_token_flag)
else  begin m:=info(p) div @'400; c:=info(p) mod @'400;
  if (info(p)<0)or(c>127) then print_esc("BAD.")
@.BAD@>
  else @<Display the token $(|m|,|c|)$@>;
  end
@y
if info(p)>=cs_token_flag then print_cs(info(p)-cs_token_flag)
else  begin getcmdx(info(p), m, c);
  if (m<kanji)and(c>127) then print_esc("BAD.")
@.BAD@>
  else @<Display the token $(|m|,|c|)$@>;
  end
@z

@x
left_brace,right_brace,math_shift,tab_mark,sup_mark,sub_mark,spacer,
  letter,other_char: print(c);
mac_param: begin print(c); print(c);
  end;
@y
kanji,kana,other_kchar: begin print(c);p:=link(p);
  getcmdx(info(p), m, c);print(c);end;
left_brace,right_brace,math_shift,tab_mark,sup_mark,sub_mark,spacer,
  letter,other_char: print(c);
mac_param: begin print(c); print(c);
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[21.297] jflag cur_jchr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
To handle these situations, which might all be present simultaneously,
\TeX\ uses various stacks that hold information about the incomplete
activities, and there is a finite state control for each level of the
input mechanism. These stacks record the current state of an implicitly
recursive process, but the |get_next| procedure is not recursive.
Therefore it will not be difficult to translate these algorithms into
low-level languages that do not support recursion.

@<Glob...@>=
@!cur_cmd: eight_bits; {current command set by |get_next|}
@!cur_chr: halfword; {operand of current command}
@!cur_cs: pointer; {control sequence found here, zero if none found}
@!cur_tok: halfword; {packed representative of |cur_cmd| and |cur_chr|}
@y
To handle these situations, which might all be present simultaneously,
\TeX\ uses various stacks that hold information about the incomplete
activities, and there is a finite state control for each level of the
input mechanism. These stacks record the current state of an implicitly
recursive process, but the |get_next| procedure is not recursive.
Therefore it will not be difficult to translate these algorithms into
low-level languages that do not support recursion.

@<Glob...@>=
@!cur_cmd: halfword; {current command set by |get_next|}
@!cur_chr: halfword; {operand of current command}
@!cur_cs: pointer; {control sequence found here, zero if none found}
@!cur_tok: halfword; {packed representative of |cur_cmd| and |cur_chr|}
@!cur_jchr: KANJI_code; {operand of current command}
{@!last_chr: halfword;}
@!jflag: halfword; {kanji flag}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[21.298] print_cmd_chr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
endv: print("end of alignment template");
spacer: chr_cmd("blank space ");
letter: chr_cmd("the letter ");
other_char: chr_cmd("the character ");
@y
endv: print("end of alignment template");
spacer: chr_cmd("blank space ");
letter: chr_cmd("the letter ");
other_char: chr_cmd("the character ");
kanji,kana,other_kchar: print("kanji character");
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[22.303] state: mid_kanji
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
The |state| variable has one of three values, when we are scanning such
files:
$$\baselineskip 15pt\vbox{\halign{#\hfil\cr
1) |state=mid_line| is the normal state.\cr
2) |state=skip_blanks| is like |mid_line|, but blanks are ignored.\cr
3) |state=new_line| is the state at the beginning of a line.\cr}}$$
These state values are assigned numeric codes so that if we add the state
code to the next character's command code, we get distinct values. For
example, `|mid_line+spacer|' stands for the case that a blank
space character occurs in the middle of a line when it is not being
ignored; after this case is processed, the next value of |state| will
be |skip_blanks|.

@d mid_line=1 {|state| code when scanning a line of characters}
@d skip_blanks=2+max_char_code {|state| code when ignoring blanks}
@d new_line=3+max_char_code+max_char_code {|state| code at start of line}
@y
The |state| variable has one of four values, when we are scanning such
files:
$$\baselineskip 15pt\vbox{\halign{#\hfil\cr
1) |state=mid_line| is the normal state.\cr
2) |state=mid_kanji| is like |mid_line|, and internal KANJI string.\cr
3) |state=skip_blanks| is like |mid_line|, but blanks are ignored.\cr
4) |state=new_line| is the state at the beginning of a line.\cr}}$$
These state values are assigned numeric codes so that if we add the state
code to the next character's command code, we get distinct values. For
example, `|mid_line+spacer|' stands for the case that a blank
space character occurs in the middle of a line when it is not being
ignored; after this case is processed, the next value of |state| will
be |skip_blanks|.

@d mid_line=1 {|state| code when scanning a line of characters}
@d mid_kanji=2+max_char_code {|state| code when scanning a line of characters}
@d skip_blanks=3+max_char_code+max_char_code {|state| code when ignoring blanks}
@d new_line=4+max_char_code+max_char_code+max_char_code
					{|state| code at start of line}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[22.311] label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure show_context; {prints where the scanner is}
label done;
@y
@p procedure show_context; {prints where the scanner is}
label done, done1;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[22.315] local vavariable
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!q: integer; {temporary index}
@y
@!q: integer; {temporary index}
@!s: pointer; {temporary pointer}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[22.316] init kcode_pos
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  begin l:=tally; tally:=0; selector:=pseudo;
@y
  begin l:=tally; tally:=0; selector:=pseudo; kcode_pos:=0;
@z

@x
@d set_trick_count==
  begin first_count:=tally;
  trick_count:=tally+1+error_line-half_error_line;
  if trick_count<error_line then trick_count:=error_line;
  end
@y
@d set_trick_count==
  begin
    first_count:=tally;
    if first_count>0 then
      if trick_buf2[(first_count-1)mod error_line]=1 then
        incr(first_count);
    trick_count:=first_count+1+error_line-half_error_line;
    if trick_count<error_line then trick_count:=error_line;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[22.317] adjust kanji code pos
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Print two lines using the tricky pseudoprinted information@>=
if trick_count=1000000 then set_trick_count;
  {|set_trick_count| must be performed}
if tally<trick_count then m:=tally-first_count
else m:=trick_count-first_count; {context on line 2}
if l+first_count<=half_error_line then
  begin p:=0; n:=l+first_count;
  end
else  begin print("..."); p:=l+first_count-half_error_line+3;
  n:=half_error_line;
  end;
for q:=p to first_count-1 do print_char(trick_buf[q mod error_line]);
print_ln;
for q:=1 to n do print_char(" "); {print |n| spaces to begin line~2}
if m+n<=error_line then p:=first_count+m else p:=first_count+(error_line-n-3);
for q:=first_count to p-1 do print_char(trick_buf[q mod error_line]);
if m+n>error_line then print("...")
@y
@<Print two lines using the tricky pseudoprinted information@>=
  if trick_count=1000000 then set_trick_count;
    {|set_trick_count| must be performed}
  if tally<trick_count then m:=tally-first_count
  else m:=trick_count-first_count; {context on line 2}
  if l+first_count<=half_error_line then begin
    p:=0; n:=l+first_count;
  end else begin
    print("..."); p:=l+first_count-half_error_line+3;
    n:=half_error_line;
  end;
  if trick_buf2[p mod error_line]=2 then begin
    p:=p+1; n:=n-1;
  end;
  for q:=p to first_count-1 do
    print_char(trick_buf[q mod error_line]);
  print_ln;
  for q:=1 to n do print_char(" "); {print |n| spaces to begin line~2}
  if m+n<=error_line then p:=first_count+m
  else p:=first_count+(error_line-n-3);
  if trick_buf2[(p-1) mod error_line]=1 then p:=p-1;
  for q:=first_count to p-1 do
    print_char(trick_buf[q mod error_line]);
  if m+n>error_line then print("...")
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[22.319] adjust kanji code token
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if token_type<macro then show_token_list(start,loc,100000)
else show_token_list(link(start),loc,100000) {avoid reference count}
@y
if token_type<macro then begin
  if (token_type=backed_up)and(loc<>null) then begin
    if (link(start)=null)and(info(start)>kanji_token_base)
        and(info(start)<kanji_token_end) then begin
      cur_input:=input_stack[base_ptr-1];
      s:=get_avail; info(s):=mktok(0, buffer[loc]);
      cur_input:=input_stack[base_ptr];
      link(start):=s;
      show_token_list(start,loc,100000);
      free_avail(s);link(start):=null;
      goto done1;
    end;
  end;
  show_token_list(start,loc,100000);
end else show_token_list(link(start),loc,100000); {avoid reference count}
done1:
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [23.331] use a different for loop index, local to tex_body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
first:=buf_size; repeat buffer[first]:=0; decr(first); until first=0;
@y
bufindx:=buf_size; repeat buffer[bufindx]:=0; decr(bufindx); until bufindx=0;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[24.341] set last_chr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!cat:0..15; {|cat_code(cur_chr)|, usually}
begin restart: cur_cs:=0;
if state<>token_list then
@<Input from external file, |goto restart| if no input found@>
else @<Input from token list, |goto restart| if end of list or
  if a parameter needs to be expanded@>;
@<If an alignment entry has just ended, take appropriate action@>;
exit:end;
@y
@!cat:escape..max_char_code; {|cat_code(cur_chr)|, usually}
begin restart: cur_cs:=0;
if state<>token_list then
@<Input from external file, |goto restart| if no input found@>
else @<Input from token list, |goto restart| if end of list or
  if a parameter needs to be expanded@>;
@<If an alignment entry has just ended, take appropriate action@>;
exit:{last_chr:=cur_chr;}
end;

@ @<Initialize table entries...@>=
{last_chr:=0;}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[24.343] input external file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Input from external file, |goto restart| if no input found@>=
@^inner loop@>
begin switch: if loc<=limit then {current line not yet finished}
  begin cur_chr:=buffer[loc]; incr(loc);
  reswitch: cur_cmd:=cat_code(cur_chr);
  @<Change state if necessary, and |goto switch| if the
    current character should be ignored,
    or |goto reswitch| if the current character
    changes to another@>;
  end
else  begin state:=new_line;@/
  @<Move to next line of file,
    or |goto restart| if there is no next line,
    or |return| if a \.{\\read} line has finished@>;
  check_interrupt;
  goto switch;
  end;
end
@y
@ @<Input from external file, |goto restart| if no input found@>=
@^inner loop@>
  begin
switch:
    if loc<=limit then {current line not yet finished} begin
      cur_chr:=buffer[loc]; incr(loc);
      if jflag = 1  then begin
        jflag:=0; goto exit;
      end;
reswitch:
      cur_cmd:=cat_code(cur_chr);
      if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then
        incr(jflag);
      @<Change state if necessary, and |goto switch| if the
        current character should be ignored,
        or |goto reswitch| if the current character
        changes to another@>;
    end else begin
      state:=new_line;@/
      @<Move to next line of file,
        or |goto restart| if there is no next line,
        or |return| if a \.{\\read} line has finished@>;
      check_interrupt;
      goto switch;
    end;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[24.344][24.345] ASCII - KANJI space handling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The following 48-way switch accomplishes the scanning quickly, assuming
that a decent \PASCAL\ compiler has translated the code. Note that the numeric
values for |mid_line|, |skip_blanks|, and |new_line| are spaced
apart from each other by |max_char_code+1|, so we can add a character's
command code to the state to get a single number that characterizes both.

@d any_state_plus(#) == mid_line+#,skip_blanks+#,new_line+#

@<Change state if necessary...@>=
case state+cur_cmd of
@<Cases where character is ignored@>: goto switch;
any_state_plus(escape): @<Scan a control sequence
  and set |state:=skip_blanks| or |mid_line|@>;
any_state_plus(active_char): @<Process an active-character control sequence
  and set |state:=mid_line|@>;
any_state_plus(sup_mark): @<If this |sup_mark| starts a control character
  like~\.{\^\^A}, then |goto reswitch|, otherwise set |state:=mid_line|@>;
any_state_plus(invalid_char): @<Decry the invalid character and
  |goto restart|@>;
@t\4@>@<Handle situations involving spaces, braces, changes of state@>@;
othercases do_nothing
endcases

@ @<Cases where character is ignored@>=
any_state_plus(ignore),skip_blanks+spacer,new_line+spacer
@y
@ The following 88-way switch accomplishes the scanning quickly, assuming
that a decent \PASCAL\ compiler has translated the code. Note that the numeric
values for |mid_line|, |skip_blanks|, and |new_line| are spaced
apart from each other by |max_char_code+1|, so we can add a character's
command code to the state to get a single number that characterizes both.

@d any_state_plus(#) == mid_line+#,mid_kanji+#,skip_blanks+#,new_line+#

@<Change state if necessary...@>=
case state+cur_cmd of
@<Cases where character is ignored@>: goto switch;
any_state_plus(escape): @<Scan a control sequence
  and set |state:=skip_blanks| or |mid_line|@>;
any_state_plus(active_char): @<Process an active-character control sequence
  and set |state:=mid_line|@>;
any_state_plus(sup_mark): @<If this |sup_mark| starts a control character
  like~\.{\^\^A}, then |goto reswitch|, otherwise set |state:=mid_line|@>;
any_state_plus(invalid_char): @<Decry the invalid character and
  |goto restart|@>;
@t\4@>@<Handle situations involving spaces, braces, changes of state@>@;
othercases do_nothing
endcases

@ @<Cases where character is ignored@>=
any_state_plus(ignore),skip_blanks+spacer,new_line+spacer

@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[24.347] scaner
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @d add_delims_to(#)==#+math_shift,#+tab_mark,#+mac_param,
  #+sub_mark,#+letter,#+other_char

@<Handle situations involving spaces, braces, changes of state@>=
mid_line+spacer:@<Enter |skip_blanks| state, emit a space@>;
mid_line+car_ret:@<Finish line, emit a space@>;
skip_blanks+car_ret,any_state_plus(comment):
  @<Finish line, |goto switch|@>;
new_line+car_ret:@<Finish line, emit a \.{\\par}@>;
mid_line+left_brace: incr(align_state);
skip_blanks+left_brace,new_line+left_brace: begin
  state:=mid_line; incr(align_state);
  end;
mid_line+right_brace: decr(align_state);
skip_blanks+right_brace,new_line+right_brace: begin
  state:=mid_line; decr(align_state);
  end;
add_delims_to(skip_blanks),add_delims_to(new_line): state:=mid_line;
@y
@ @d add_delims_to(#)==#+math_shift,#+tab_mark,#+mac_param,
  #+sub_mark,#+letter,#+other_char
@d all_jcode(#)==#+kanji,#+kana,#+other_kchar

@<Handle situations involving spaces, braces, changes of state@>=
mid_kanji+spacer,mid_line+spacer:@<Enter |skip_blanks| state, emit a space@>;
mid_line+car_ret:@<Finish line, emit a space@>;
mid_kanji+car_ret:@<If skip_mode Finish line, |goto switch|@>;
skip_blanks+car_ret,any_state_plus(comment):
  @<Finish line, |goto switch|@>;
new_line+car_ret:@<Finish line, emit a \.{\\par}@>;
mid_line+left_brace,mid_kanji+left_brace: incr(align_state);
skip_blanks+left_brace,new_line+left_brace: begin
  state:=mid_line; incr(align_state);
  end;
mid_line+right_brace,mid_kanji+right_brace: decr(align_state);
skip_blanks+right_brace,new_line+right_brace: begin
  state:=mid_line; decr(align_state);
  end;
add_delims_to(skip_blanks),add_delims_to(new_line),add_delims_to(mid_kanji):
  state:=mid_line;
all_jcode(skip_blanks),all_jcode(new_line),all_jcode(mid_line):state:=mid_kanji;

@ @<If skip_mode Finish line, |goto switch|@>=
if skip_mode then @<Finish line, |goto switch|@>
else @<Finish line, emit a space@>

@ @<Global...@>=
skip_mode:boolean;

@ @<Set init...@>=
skip_mode:=true;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[24.354] scan control sequence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin if loc>limit then cur_cs:=null_cs {|state| is irrelevant in this case}
else  begin start_cs: k:=loc; cur_chr:=buffer[k]; cat:=cat_code(cur_chr);
  incr(k);
  if cat=letter then state:=skip_blanks
  else if cat=spacer then state:=skip_blanks
  else state:=mid_line;
  if (cat=letter)and(k<=limit) then
@y
begin if loc>limit then cur_cs:=null_cs {|state| is irrelevant in this case}
else  begin start_cs: k:=loc; cur_chr:=buffer[k]; cat:=cat_code(cur_chr);
  incr(k);
  if (cat=kanji)or(cat=kana)or(cat=other_kchar) then incr(k);
  if (cat=letter)or(cat=kanji)or(cat=kana) then state:=skip_blanks
  else if cat=spacer then state:=skip_blanks
  else state:=mid_line;
  if (cat=other_kchar)and(k<=limit) then begin
    cur_cs:=id_lookup(loc,k-loc); loc:=k; goto found;
  end else if ((cat=letter)or(cat=kanji)or(cat=kana))and(k<=limit) then
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[24.356] scan control sequence (cont)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin repeat cur_chr:=buffer[k]; cat:=cat_code(cur_chr); incr(k);
until (cat<>letter)or(k>limit);
@<If an expanded...@>;
if cat<>letter then decr(k);
  {now |k| points to first nonletter}
if k>loc+1 then {multiletter control sequence has been scanned}
  begin cur_cs:=id_lookup(loc,k-loc); loc:=k; goto found;
  end;
end
@y
begin
  repeat
    cur_chr:=buffer[k]; cat:=cat_code(cur_chr);
    if (cat=kanji)or(cat=kana)or(cat=other_kchar) then incr2(k) else incr(k);
  until not((cat=letter)or(cat=kanji)or(cat=kana))or(k>limit);
  @<If an expanded...@>;
  if not((cat=letter)or(cat=kanji)or(cat=kana)) then
    if cat=other_kchar then decr2(k) else decr(k);
   {now |k| points to first nonletter}
  if k>loc+1 then begin {multiletter control sequence has been scanned}
    cur_cs:=id_lookup(loc,k-loc); loc:=k; goto found;
  end;
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.357] input from token list
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
      if cur_cmd=dont_expand then
        @<Get the next token, suppressing expansion@>
      else check_outer_validity;
    end
  else  begin cur_cmd:=t div @'400; cur_chr:=t mod @'400;
    case cur_cmd of
    left_brace: incr(align_state);
@y
      if cur_cmd=dont_expand then
        @<Get the next token, suppressing expansion@>
      else check_outer_validity;
    end
  else  begin get_cmd(t); {cur_cmd:=t div @'400; cur_chr:=t mod @'400;}
    case cur_cmd of
    left_brace: incr(align_state);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [24.365] get_token
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if cur_cs=0 then cur_tok:=(cur_cmd*@'400)+cur_chr
else cur_tok:=cs_token_flag+cur_cs;
end;
@y
if cur_cs=0 then set_tok
else cur_tok:=cs_token_flag+cur_cs;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[25.367] inhibit_glue
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%@x
%input:@<Initiate or terminate input from a file@>;
%othercases @<Complain about an undefined macro@>
%@y
%input:@<Initiate or terminate input from a file@>;
%inhibit_glue:inhibit_glue_flag:=true;
%othercases @<Complain about an undefined macro@>
%@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [25.374] get_chr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@:TeX capacity exceeded buffer size}{\quad buffer size@>
    end;
  buffer[j]:=info(p) mod @'400; incr(j); p:=link(p);
@y
@:TeX capacity exceeded buffer size}{\quad buffer size@>
    end;
  buffer[j]:=get_chr(info(p)); {info(p) mod @'400;} incr(j); p:=link(p);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [25.380] get_x_token
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
goto restart;
done: if cur_cs=0 then cur_tok:=(cur_cmd*@'400)+cur_chr
else cur_tok:=cs_token_flag+cur_cs;
end;
@y
goto restart;
done: if cur_cs=0 then set_tok {cur_tok:=(cur_cmd*@'400)+cur_chr}
else cur_tok:=cs_token_flag+cur_cs;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [25.381] x_token
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure x_token; {|get_x_token| without the initial |get_next|}
begin while cur_cmd>max_command do
  begin expand;
  get_next;
  end;
if cur_cs=0 then cur_tok:=(cur_cmd*@'400)+cur_chr
else cur_tok:=cs_token_flag+cur_cs;
end;
@y
@p procedure x_token; {|get_x_token| without the initial |get_next|}
begin while cur_cmd>max_command do
  begin expand;
  get_next;
  end;
if cur_cs=0 then set_tok {cur_tok:=(cur_cmd*@'400)+cur_chr}
else cur_tok:=cs_token_flag+cur_cs;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[25.393] store 2nd KANJI token at macro parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
    if info(r)>=match_token then goto continue;
store_new_token(cur_tok);
end
@y
    if info(r)>=match_token then goto continue;
store_new_token(cur_tok);
if (cur_tok>kanji_token_base)and(cur_tok<kanji_token_end) then
begin get_token; store_new_token(cur_tok); end;
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[26.413] scan_somthing_internal
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure scan_something_internal(@!level:small_number;@!negative:boolean);
  {fetch an internal parameter}
var m:halfword; {|chr_code| part of the operand token}
@!p:0..nest_size; {index into |nest|}
begin m:=cur_chr;
case cur_cmd of
def_code: @<Fetch a character code from some table@>;
toks_register,assign_toks,def_family,set_font,def_font: @<Fetch a token list or
  font identifier, provided that |level=tok_val|@>;
@y
@p @t\4@>@<Declare procedures needed in |scan_something|@>@t@>@/
procedure scan_something_internal(@!level:small_number;@!negative:boolean);
  {fetch an internal parameter}
var m:halfword; {|chr_code| part of the operand token}
@!p:0..nest_size; {index into |nest|}
@!q:pointer;
begin m:=cur_chr;
case cur_cmd of
assign_kinsoku: @<Fetch breaking penalty from some table@>;
assign_inhibit_xsp_code: @<Fetch inhibit type from some table@>;
def_code: @<Fetch a character code from some table@>;
toks_register,assign_toks,def_family,set_font,def_font,def_jfont,def_tfont:
  @<Fetch a token list or font identifier, provided that |level=tok_val|@>;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[26.420] Fetch a box dimension: dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Fetch a box dimension@>=
begin scan_eight_bit_int;
if box(cur_val)=null then cur_val:=0 @+else cur_val:=mem[box(cur_val)+m].sc;
cur_val_level:=dimen_val;
end
@y
@ @<Fetch a box dimension@>=
  begin
    scan_eight_bit_int;
    if box(cur_val)=null then cur_val:=0
    else begin
      q:=box(cur_val);
      while (q<>null)and(box_dir(q)<>abs(direction)) do q:=link(q);
      if q=null then begin
        q:=new_dir_node(box(cur_val),abs(direction));
        cur_val:=mem[q+m].sc;
        delete_glue_ref(space_ptr(q));
        delete_glue_ref(xspace_ptr(q));
        free_node(q,box_node_size);
      end else cur_val:=mem[q+m].sc;
    end;
    cur_val_level:=dimen_val;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[26.435] scan_char_num
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure scan_char_num;
begin scan_int;
if (cur_val<0)or(cur_val>255) then
  begin print_err("Bad character code");
@.Bad character code@>
  help2("A character number must be between 0 and 255.")@/
    ("I changed this one to zero."); int_error(cur_val); cur_val:=0;
  end;
end;
@y
procedure scan_char_num;
var cx:KANJI_code;
begin
  scan_int;
  if not checkkanji(cur_val) then begin
    print_err("Bad character code");
@.Bad character code@>
    help2("A character number must be between 0 and 255, or KANJI code.")@/
      ("I changed this one to zero."); int_error(cur_val); cur_val:=0;
  end else if (cur_val<0)or(cur_val>256) then begin
    cx:=tokanji(cur_val); cur_val:=KANJI(cx);
  end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[26.440] scan_int
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure scan_int; {sets |cur_val| to an integer}
label done;
var negative:boolean; {should the answer be negated?}
@!m:integer; {|@t$2^{31}$@> div radix|, the threshold of danger}
@!d:small_number; {the digit just scanned}
@!vacuous:boolean; {have no digits appeared?}
@!OK_so_far:boolean; {has an error message been issued?}
begin radix:=0; OK_so_far:=true;@/
@y
@p procedure scan_int; {sets |cur_val| to an integer}
label done;
var negative:boolean; {should the answer be negated?}
@!m:integer; {|@t$2^{31}$@> div radix|, the threshold of danger}
@!d:small_number; {the digit just scanned}
@!vacuous:boolean; {have no digits appeared?}
@!OK_so_far:boolean; {has an error message been issued?}
@!cx:KANJI_code;
begin cx:=0; radix:=0; OK_so_far:=true;@/
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[26.442] KANJI caracter scanning
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Scan an alphabetic character code into |cur_val|@>=
begin get_token; {suppress macro expansion}
if cur_tok<cs_token_flag then
  begin cur_val:=cur_chr;
  if cur_cmd<=right_brace then
    if cur_cmd=right_brace then incr(align_state)
    else decr(align_state);
  end
else if cur_tok<cs_token_flag+single_base then
  cur_val:=cur_tok-cs_token_flag-active_base
else cur_val:=cur_tok-cs_token_flag-single_base;
if cur_val>127 then
  begin print_err("Improper alphabetic constant");
@.Improper alphabetic constant@>
  help2("A one-character control sequence belongs after a ` mark.")@/
    ("So I'm essentially inserting \0 here.");
  cur_val:="0"; back_error;
  end
else @<Scan an optional space@>;
end
@y
@<Scan an alphabetic character code into |cur_val|@>=
begin get_token; {suppress macro expansion}
if cur_tok<cs_token_flag then
  if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then begin
      skip_mode:=false;
      PutHi(cx,cur_chr); get_next; PutLo(cx,cur_chr);
      cur_val:=tonum(cx);
    end else begin cur_val:=cur_chr;
      if cur_cmd<=right_brace then
        if cur_cmd=right_brace then incr(align_state)
        else decr(align_state);
    end
else if cur_tok<cs_token_flag+single_base then
  cur_val:=cur_tok-cs_token_flag-active_base
else cur_val:=cur_tok-cs_token_flag-single_base;
if (cur_val>127) and (cx=0) then
  begin print_err("Improper alphabetic or KANJI constant");
@.Improper alphabetic constant@>
  help2("A one-character control sequence belongs after a ` mark.")@/
    ("So I'm essentially inserting \0 here.");
  cur_val:="0"; back_error;
  end
else @<Scan an optional space@>;
skip_mode:=true;
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[26.455] zw, zh: zenkaku width & height
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if scan_keyword("em") then v:=(@<The em width for |cur_font|@>)
@.em@>
else if scan_keyword("ex") then v:=(@<The x-height for |cur_font|@>)
@.ex@>
else goto not_found;
@y
if scan_keyword("em") then v:=(@<The em width for |cur_font|@>)
@.em@>
else if scan_keyword("ex") then v:=(@<The x-height for |cur_font|@>)
@.ex@>
else if scan_keyword("zw") then @<The KANJI width for |cur_jfont|@>
@.ex@>
else if scan_keyword("zh") then @<The KANJI height for |cur_jfont|@>
@.ex@>
else goto not_found;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[26.458] dimension unit: Q, H (1/4 mm)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Scan for \(a)all other units and adjust |cur_val| and |f|...@>=
if scan_keyword("in") then set_conversion(7227)(100)
@.in@>
else if scan_keyword("pc") then set_conversion(12)(1)
@.pc@>
else if scan_keyword("cm") then set_conversion(7227)(254)
@.cm@>
else if scan_keyword("mm") then set_conversion(7227)(2540)
@.mm@>
else if scan_keyword("bp") then set_conversion(7227)(7200)
@.bp@>
else if scan_keyword("dd") then set_conversion(1238)(1157)
@.dd@>
else if scan_keyword("cc") then set_conversion(14856)(1157)
@.cc@>
else if scan_keyword("sp") then goto done
@.sp@>
else @<Complain about unknown unit and |goto done2|@>;
cur_val:=xn_over_d(cur_val,num,denom);
f:=(num*f+@'200000*remainder) div denom;@/
cur_val:=cur_val+(f div @'200000); f:=f mod @'200000;
done2:
@y
@<Scan for \(a)all other units and adjust |cur_val| and |f|...@>=
if scan_keyword("in") then set_conversion(7227)(100)
@.in@>
else if scan_keyword("pc") then set_conversion(12)(1)
@.pc@>
else if scan_keyword("cm") then set_conversion(7227)(254)
@.cm@>
else if scan_keyword("mm") then set_conversion(7227)(2540)
@.mm@>
else if scan_keyword("bp") then set_conversion(7227)(7200)
@.bp@>
else if scan_keyword("dd") then set_conversion(1238)(1157)
@.dd@>
else if scan_keyword("cc") then set_conversion(14856)(1157)
@.cc@>
else if scan_keyword("H") then set_conversion(7227)(10160)
@.H@>
else if scan_keyword("Q") then set_conversion(7227)(10160)
@.Q@>
else if scan_keyword("sp") then goto done
@.sp@>
else @<Complain about unknown unit and |goto done2|@>;
cur_val:=xn_over_d(cur_val,num,denom);
f:=(num*f+@'200000*remainder) div denom;@/
cur_val:=cur_val+(f div @'200000); f:=f mod @'200000;
done2:
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[27.464] str_toks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  if t=" " then t:=space_token
  else t:=other_token+t;
  fast_store_new_token(t);
  incr(k);
  end;
@y
    if (t<0)or(t>127) then begin
      if t<0 then t:=t+256;
      t:=jother_token+t;
      fast_store_new_token(t); incr(k);
      t:=str_pool[k]; if t<0 then t:=t+256; t:=jother_token+t;
    end else if t=" " then
      t:=space_token
    else
      t:=other_token+t;
    fast_store_new_token(t);
    incr(k);
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[27.468][27.469] convert KANJI code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d number_code=0 {command code for \.{\\number}}
@d roman_numeral_code=1 {command code for \.{\\romannumeral}}
@d string_code=2 {command code for \.{\\string}}
@d meaning_code=3 {command code for \.{\\meaning}}
@d font_name_code=4 {command code for \.{\\fontname}}
@d job_name_code=5 {command code for \.{\\jobname}}

@<Put each...@>=
primitive("number",convert,number_code);@/
@!@:number_}{\.{\\number} primitive@>
primitive("romannumeral",convert,roman_numeral_code);@/
@!@:roman_numeral_}{\.{\\romannumeral} primitive@>
primitive("string",convert,string_code);@/
@!@:string_}{\.{\\string} primitive@>
primitive("meaning",convert,meaning_code);@/
@!@:meaning_}{\.{\\meaning} primitive@>
primitive("fontname",convert,font_name_code);@/
@!@:font_name_}{\.{\\fontname} primitive@>
primitive("jobname",convert,job_name_code);@/
@!@:job_name_}{\.{\\jobname} primitive@>

@ @<Cases of |print_cmd_chr|...@>=
convert: case chr_code of
  number_code: print_esc("number");
  roman_numeral_code: print_esc("romannumeral");
  string_code: print_esc("string");
  meaning_code: print_esc("meaning");
  font_name_code: print_esc("fontname");
  othercases print_esc("jobname")
  endcases;
@y
@d number_code=0 {command code for \.{\\number}}
@d roman_numeral_code=1 {command code for \.{\\romannumeral}}
@d string_code=2 {command code for \.{\\string}}
@d meaning_code=3 {command code for \.{\\meaning}}
@d font_name_code=4 {command code for \.{\\fontname}}
@d sjis_code=5 {command code for \.{\\sjis}}
@d jis_code=6 {command code for \.{\\jis}}
@d kuten_code=7 {command code for \.{\\kuten}}
@d job_name_code=8 {command code for \.{\\jobname}}

@<Put each...@>=
primitive("number",convert,number_code);@/
@!@:number_}{\.{\\number} primitive@>
primitive("romannumeral",convert,roman_numeral_code);@/
@!@:roman_numeral_}{\.{\\romannumeral} primitive@>
primitive("string",convert,string_code);@/
@!@:string_}{\.{\\string} primitive@>
primitive("meaning",convert,meaning_code);@/
@!@:meaning_}{\.{\\meaning} primitive@>
primitive("fontname",convert,font_name_code);@/
@!@:font_name_}{\.{\\fontname} primitive@>
primitive("jobname",convert,job_name_code);@/
@!@:job_name_}{\.{\\jobname} primitive@>
primitive("sjis",convert,sjis_code);
@!@:sjis_}{\.{\\sjis} primitive@>
primitive("jis",convert,jis_code);
@!@:jis_}{\.{\\jis} primitive@>
primitive("kuten",convert,kuten_code);
@!@:kuten_}{\.{\\jis} primitive@>

@ @<Cases of |print_cmd_chr|...@>=
convert: case chr_code of
  number_code: print_esc("number");
  roman_numeral_code: print_esc("romannumeral");
  string_code: print_esc("string");
  meaning_code: print_esc("meaning");
  font_name_code: print_esc("fontname");
  sjis_code:print_esc("sjis");
  jis_code:print_esc("jis");
  kuten_code:print_esc("kuten");
  othercases print_esc("jobname")
  endcases;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[27.470][27.471][27.472] convert KANJI code continue
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure conv_toks;
var old_setting:0..max_selector; {holds |selector| setting}
@!c:number_code..job_name_code; {desired type of conversion}
@!save_scanner_status:small_number; {|scanner_status| upon entry}
@y
@p procedure conv_toks;
var old_setting:0..max_selector; {holds |selector| setting}
@!c:number_code..job_name_code; {desired type of conversion}
@!save_scanner_status:small_number; {|scanner_status| upon entry}
@!cx:KANJI_code;
@z

@x
@ @<Scan the argument for command |c|@>=
case c of
number_code,roman_numeral_code: scan_int;
string_code, meaning_code: begin save_scanner_status:=scanner_status;
  scanner_status:=normal; get_token; scanner_status:=save_scanner_status;
  end;
font_name_code: scan_font_ident;
job_name_code: if job_name=0 then open_log_file;
end {there are no other cases}

@ @<Print the result of command |c|@>=
case c of
number_code: print_int(cur_val);
roman_numeral_code: print_roman_int(cur_val);
string_code:if cur_cs<>0 then sprint_cs(cur_cs)
  else print_char(cur_chr);
meaning_code: print_meaning;
font_name_code: begin print(font_name[cur_val]);
  if font_size[cur_val]<>font_dsize[cur_val] then
    begin print(" at "); print_scaled(font_size[cur_val]);
    print("pt");
    end;
  end;
job_name_code: print(job_name);
end {there are no other cases}
@y
@ @<Scan the argument for command |c|@>=
KANJI(cx):=0;
case c of
sjis_code,jis_code,kuten_code,number_code,roman_numeral_code: scan_int;
string_code, meaning_code: begin save_scanner_status:=scanner_status;
  scanner_status:=normal; get_token;
  if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then
    begin PutHi(cx, cur_chr); get_token; end;
   scanner_status:=save_scanner_status;
  end;
font_name_code: scan_font_ident;
job_name_code: if job_name=0 then open_log_file;
end {there are no other cases}

@ @<Print the result of command |c|@>=
case c of
jis_code: begin cur_val:=JIStoSJIS(cur_val); print_int(cur_val); end;
kuten_code: begin cur_val:=KUTENtoSJIS(cur_val); print_int(cur_val); end;
sjis_code,number_code: print_int(cur_val);
roman_numeral_code: print_roman_int(cur_val);
string_code:if cur_cs<>0 then sprint_cs(cur_cs)
  else begin if KANJI(cx) <> 0 then print_char(Hi(cx));
     print_char(cur_chr); end;
meaning_code: print_meaning;
font_name_code: begin print(font_name[cur_val]);
  if font_size[cur_val]<>font_dsize[cur_val] then
    begin print(" at "); print_scaled(font_size[cur_val]);
    print("pt");
    end;
  end;
job_name_code: print(job_name);
end {there are no other cases}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[28.487] iftdir, ifydir, iftbox, ifybox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d if_case_code=16 { `\.{\\ifcase}' }
@y
@d if_case_code=16 { `\.{\\ifcase}' }
@d if_tdir_code=17 { `\.{\\iftdir}' }
@d if_ydir_code=18 { `\.{\\ifydir}' }
@d if_mdir_code=19 { `\.{\\ifmdir}' }
@d if_tbox_code=20 { `\.{\\iftbox}' }
@d if_ybox_code=21 { `\.{\\ifybox}' }
@z

@x
primitive("ifcase",if_test,if_case_code);
@!@:if_case_}{\.{\\ifcase} primitive@>
@y
primitive("ifcase",if_test,if_case_code);
@!@:if_case_}{\.{\\ifcase} primitive@>
primitive("iftdir",if_test,if_tdir_code);
@!@:if_tdir_}{\.{\\iftdir} primitive@>
primitive("ifydir",if_test,if_ydir_code);
@!@:if_ydir_}{\.{\\ifydir} primitive@>
primitive("ifmdir",if_test,if_mdir_code);
@!@:if_mdir_}{\.{\\ifmdir} primitive@>
primitive("iftbox",if_test,if_tbox_code);
@!@:if_tbox_}{\.{\\iftbox} primitive@>
primitive("ifybox",if_test,if_ybox_code);
@!@:if_ybox_}{\.{\\ifybox} primitive@>
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[28.488] iftdir, ifydir, iftbox, ifybox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  if_case_code:print_esc("ifcase");
@y
  if_case_code:print_esc("ifcase");
  if_tdir_code:print_esc("iftdir");
  if_ydir_code:print_esc("ifydir");
  if_mdir_code:print_esc("ifmdir");
  if_tbox_code:print_esc("iftbox");
  if_ybox_code:print_esc("ifybox");
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[28.498] conditional: temp var for ifx
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure conditional;
label exit,common_ending;
var b:boolean; {is the condition true?}
@!r:"<"..">"; {relation to be evaluated}
@!m,@!n:integer; {to be tested against the second operand}
@!p,@!q:pointer; {for traversing token lists in \.{\\ifx} tests}
@!save_scanner_status:small_number; {|scanner_status| upon entry}
@!save_cond_ptr:pointer; {|cond_ptr| corresponding to this conditional}
@!this_if:small_number; {type of this conditional}
begin @<Push the condition stack@>;@+save_cond_ptr:=cond_ptr;this_if:=cur_chr;@/
@y
@p procedure conditional;
label exit,common_ending;
var b:boolean; {is the condition true?}
  @!r:"<"..">"; {relation to be evaluated}
  @!m,@!n:integer; {to be tested against the second operand}
  @!p,@!q:pointer; {for traversing token lists in \.{\\ifx} tests}
  @!z:pointer; {for traversing token lists in \.{\\ifx} tests}
  @!save_scanner_status:small_number; {|scanner_status| upon entry}
  @!save_cond_ptr:pointer; {|cond_ptr| corresponding to this conditional}
  @!this_if:small_number; {type of this conditional}
begin @<Push the condition stack@>;@+save_cond_ptr:=cond_ptr;this_if:=cur_chr;@/
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[28.501] iftdir, ifydir, iftbox, ifybox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Either process \.{\\ifcase} or set |b|...@>=
case this_if of
if_char_code, if_cat_code: @<Test if two characters match@>;
if_int_code, if_dim_code: @<Test relation between integers or dimensions@>;
if_odd_code: @<Test if an integer is odd@>;
if_vmode_code: b:=(abs(mode)=vmode);
if_hmode_code: b:=(abs(mode)=hmode);
if_mmode_code: b:=(abs(mode)=mmode);
if_inner_code: b:=(mode<0);
if_void_code, if_hbox_code, if_vbox_code: @<Test box register status@>;
ifx_code: @<Test if two tokens match@>;
if_eof_code: begin scan_four_bit_int; b:=(read_open[cur_val]=closed);
  end;
if_true_code: b:=true;
if_false_code: b:=false;
if_case_code: @<Select the appropriate case
  and |return| or |goto common_ending|@>;
end {there are no other cases}
@y
@ @<Either process \.{\\ifcase} or set |b|...@>=
case this_if of
if_char_code, if_cat_code: @<Test if two characters match@>;
if_int_code, if_dim_code: @<Test relation between integers or dimensions@>;
if_odd_code: @<Test if an integer is odd@>;
if_vmode_code: b:=(abs(mode)=vmode);
if_hmode_code: b:=(abs(mode)=hmode);
if_mmode_code: b:=(abs(mode)=mmode);
if_inner_code: b:=(mode<0);
if_tdir_code: b:=(abs(direction)=dir_tate);
if_ydir_code: b:=(abs(direction)=dir_yoko);
if_mdir_code: b:=(direction<0);
if_void_code, if_hbox_code, if_vbox_code, if_tbox_code, if_ybox_code:
  @<Test box register status@>;
ifx_code: @<Test if two tokens match@>;
if_eof_code: begin scan_four_bit_int; b:=(read_open[cur_val]=closed);
  end;
if_true_code: b:=true;
if_false_code: b:=false;
if_case_code: @<Select the appropriate case
  and |return| or |goto common_ending|@>;
end {there are no other cases}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[28.505] Test box register status : iftbox, ifybox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Test box register status@>=
begin scan_eight_bit_int; p:=box(cur_val);
if this_if=if_void_code then b:=(p=null)
else if p=null then b:=false
else if this_if=if_hbox_code then b:=(type(p)=hlist_node)
else b:=(type(p)=vlist_node);
end
@y
@ @<Test box register status@>=
begin
  scan_eight_bit_int; p:=box(cur_val);
  if this_if=if_void_code then b:=(p=null)
  else if p=null then b:=false
  else begin
    if type(p)=dir_node then p:=list_ptr(p);
    if this_if=if_hbox_code then b:=(type(p)=hlist_node)
    else if this_if=if_vbox_code then b:=(type(p)=vlist_node)
    else if this_if=if_tbox_code then b:=(box_dir(p)=dir_tate)
    else b:=(box_dir(p)=dir_yoko);
  end
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[28.507] ifx : Test token : kanji token
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Test if two tokens match@>=
begin save_scanner_status:=scanner_status; scanner_status:=normal;
get_next; n:=cur_cs; p:=cur_cmd; q:=cur_chr;
get_next; if cur_cmd<>p then b:=false
else if cur_cmd<call then b:=(cur_chr=q)
else @<Test if two macro texts match@>;
scanner_status:=save_scanner_status;
end
@y
@<Test if two tokens match@>=
  begin
    save_scanner_status:=scanner_status; scanner_status:=normal;
    get_next; n:=cur_cs; p:=cur_cmd; q:=cur_chr;
    if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then begin
      getnext; q:=256*q+cur_chr;
    end;
    get_next; z:=cur_chr;
    if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then begin
      getnext; cur_chr:=256*z+cur_chr;
    end;
    if cur_cmd<>p then b:=false
    else if cur_cmd<call then b:=(cur_chr=q)
    else @<Test if two macro texts match@>;
    scanner_status:=save_scanner_status;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.513] area and extension rules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The file names we shall deal with for illustrative purposes have the
following structure:  If the name contains `\.>' or `\.:', the file area
consists of all characters up to and including the final such character;
otherwise the file area is null.  If the remaining file name contains
`\..', the file extension consists of all such characters from the first
remaining `\..' to the end, otherwise the file extension is null.
@^system dependencies@>

We can scan such file names easily by using two global variables that keep track
of the occurrences of area and extension delimiters:

@<Glob...@>=
@!area_delimiter:pool_pointer; {the most recent `\.>' or `\.:', if any}
@!ext_delimiter:pool_pointer; {the relevant `\..', if any}
@y
@ The file names we shall deal with for illustrative purposes have the
following structure:  If the name contains `\./', the file area
consists of all characters up to and including the final such character;
otherwise the file area is null.  If the remaining file name contains
`\..', the file extension consists of all such characters from the first
remaining `\..' to the end, otherwise the file extension is null.
@^system dependencies@>

We can scan such file names easily by using two global variables that keep
track of the occurrences of area and extension delimiters:

@<Glob...@>=
@!area_delimiter:pool_pointer; {the most recent `\./', if any}
@!ext_delimiter:pool_pointer; {the most recent `\..', if any}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.514] TEX area directories
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d TEX_area=="TeXinputs:"
@.TeXinputs@>
@d TEX_font_area=="TeXfonts:"
@.TeXfonts@>
@y
We'll handle the path stuff in an external C module.
@z


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.516] more_name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else  begin if (c=">")or(c=":") then
@y
else  begin if (c="/") then
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.519] xchr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d append_to_name(#)==begin c:=#; incr(k);
  if k<=file_name_size then name_of_file[k]:=xchr[c];
  end
@y
@d append_to_name(#)==begin c:=#; incr(k);
  if k<=file_name_size then name_of_file[k]:=xchr(c);
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.520] default format
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d format_default_length=20 {length of the |TEX_format_default| string}
@d format_area_length=11 {length of its area part}
@d format_ext_length=4 {length of its `\.{.fmt}' part}
@y
Under Berkeley {\mc UNIX} we don't give the area part, instead depending
on the path searching that will happen during file opening.

@d format_default_length=9 {length of the |TEX_format_default| string}
@d format_area_length=0 {length of its area part}
@d format_ext_length=4 {length of its `\.{.fmt}' part}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.521] plain format location
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!TEX_format_default:packed array[1..format_default_length] of char;

@ @<Set init...@>=
TEX_format_default:='TeXformats:plain.fmt';
@y
@!TEX_format_default:c_char_pointer;

@ @<Set init...@>=
TEX_format_default := ' plain.fmt';
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.523] xord
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure pack_buffered_name(@!n:small_number;@!a,@!b:integer);
var k:integer; {number of positions filled in |name_of_file|}
@!c: ASCII_code; {character being packed}
@!j:integer; {index into |buffer| or |TEX_format_default|}
begin if n+b-a+1+format_ext_length>file_name_size then
  b:=a+file_name_size-n-1-format_ext_length;
k:=0;
for j:=1 to n do append_to_name(xord[TEX_format_default[j]]);
for j:=a to b do append_to_name(buffer[j]);
for j:=format_default_length-format_ext_length+1 to format_default_length do
  append_to_name(xord[TEX_format_default[j]]);
if k<=file_name_size then name_length:=k@+else name_length:=file_name_size;
for k:=name_length+1 to file_name_size do name_of_file[k]:=' ';
end;
@y
@p procedure pack_buffered_name(@!n:small_number;@!a,@!b:integer);
var k:integer; {number of positions filled in |name_of_file|}
@!c: ASCII_code; {character being packed}
@!j:integer; {index into |buffer| or |TEX_format_default|}
begin if n+b-a+1+format_ext_length>file_name_size then
  b:=a+file_name_size-n-1-format_ext_length;
k:=0;
for j:=1 to n do append_to_name(xord(TEX_format_default[j]));
for j:=a to b do append_to_name(buffer[j]);
for j:=format_default_length-format_ext_length+1 to format_default_length do
  append_to_name(xord(TEX_format_default[j]));
if k<=file_name_size then name_length:=k@+else name_length:=file_name_size;
for k:=name_length+1 to file_name_size do name_of_file[k]:=' ';
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.524] format file opening: only try once, with path search
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  pack_buffered_name(0,loc,j-1); {try first without the system file area}
  if w_open_in(fmt_file) then goto found;
  pack_buffered_name(format_area_length,loc,j-1);
    {now try the system format file area}
  if w_open_in(fmt_file) then goto found;
@y
  pack_buffered_name(0,loc,j-1);
  if w_open_in(fmt_file) then goto found;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.525] make_name_string
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
which simply makes a \TeX\ string from the value of |name_of_file|, should
ideally be changed to deduce the full name of file~|f|, which is the file
most recently opened, if it is possible to do this in a \PASCAL\ program.
@^system dependencies@>

This routine might be called after string memory has overflowed, hence
we dare not use `|str_room|'.

@p function make_name_string:str_number;
var k:1..file_name_size; {index into |name_of_file|}
begin if (pool_ptr+name_length>pool_size)or(str_ptr=max_strings)or
 (cur_length>0) then
  make_name_string:="?"
else  begin for k:=1 to name_length do append_char(xord[name_of_file[k]]);
  make_name_string:=make_string;
  end;
end;
function a_make_name_string(var f:alpha_file):str_number;
begin a_make_name_string:=make_name_string;
end;
function b_make_name_string(var f:byte_file):str_number;
begin b_make_name_string:=make_name_string;
end;
function w_make_name_string(var f:word_file):str_number;
begin w_make_name_string:=make_name_string;
end;
@y
which simply makes a \TeX\ string from the value of |name_of_file|, should
ideally be changed to deduce the full name of file~|f|, if it is
possible to do this in a \PASCAL\ program.

With the C version, we know that |real_name_of_file|
contains |name_of_file| prepended with the directory name that was found
by path searching.

If |real_name_of_file| starts with |'./'|, we don't use that part of the
name, since {\mc UNIX} users understand that.
@^system dependencies@>

@p function make_name_string:str_number;
var k,@!kstart:1..file_name_size; {index into |name_of_file|}
begin
k:=1;
while (k<file_name_size) and (xord(real_name_of_file[k])<>" ") do
    incr(k);
name_length:=k-1; {the real |name_length|}
str_room(name_length);
if (xord(real_name_of_file[1])=".") and (xord(real_name_of_file[2])="/") then
    kstart:=3
else
    kstart:=1;
for k:=kstart to name_length do append_char(xord(real_name_of_file[k]));
make_name_string:=make_string;
end;

{The X_make_name_string functions are changed to macros in C}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[29.526] scan file name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure scan_file_name;
label done;
begin name_in_progress:=true; begin_name;
@<Get the next non-blank non-call...@>;
loop@+begin if (cur_cmd>other_char)or(cur_chr>127) then {not a character}
    begin back_input; goto done;
    end;
  if not more_name(cur_chr) then goto done;
  get_x_token;
  end;
done: end_name; name_in_progress:=false;
end;
@y
@p procedure scan_file_name;
label done;
begin
  name_in_progress:=true; begin_name;
  @<Get the next non-blank non-call...@>;
  skip_mode:=false;
  loop@+begin
    if ((cur_cmd>other_char) and ((cur_cmd<kanji) or (cur_cmd>other_kchar)))
         or (cur_chr>255) then begin {not a character}
      back_input; goto done;
    end;
    if (cur_cmd>=kanji) and (cur_cmd<=other_kchar) then begin
      str_room(2); append_char(cur_chr);
      get_x_token; append_char(cur_chr);
    end else if not more_name(cur_chr) then goto done;
    get_x_token;
  end;
done:
  end_name; name_in_progress:=false;
  skip_mode:=true;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.534][29.536] Adjust for C string conventions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!months:packed array [1..36] of char; {abbreviations of month names}
@y
@!months:c_char_pointer;
@z

@x
months:='JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC';
@y
months := ' JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC';
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.537] a_open_in of \input file needs path selector
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  if a_open_in(cur_file) then goto done;
  if cur_area="" then
    begin pack_file_name(cur_name,TEX_area,cur_ext);
    if a_open_in(cur_file) then goto done;
    end;
@y
  if a_open_in(cur_file,input_path_spec) then goto done;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [29.537] get rid of return of name to string pool
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if name=str_ptr-1 then {we can conserve string pool space now}
  begin flush_string; name:=cur_name;
  end;
@y
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.544] gk_tag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d no_tag=0 {vanilla character}
@d lig_tag=1 {character has a ligature/kerning program}
@d list_tag=2 {character has a successor in a charlist}
@d ext_tag=3 {character is extensible}
@y
@d no_tag=0 {vanilla character}
@d lig_tag=1 {character has a ligature/kerning program}
@d gk_tag=1 {character has a glue/kerning program}
@d list_tag=2 {character has a successor in a charlist}
@d ext_tag=3 {character is extensible}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[30.549] font_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!font_used:array[internal_font_number] of boolean;
  {has a character from this font actually appeared in the output?}
@!hyphen_char:array[internal_font_number] of integer;
  {current \.{\\hyphenchar} values}
@!skew_char:array[internal_font_number] of integer;
  {current \.{\\skewchar} values}
@y
@!font_dir:array[internal_font_number] of dir_default..dir_tate;
@!font_used:array[internal_font_number] of boolean;
  {has a character from this font actually appeared in the output?}
@!font_num_ext:array[internal_font_number] of halfword;
@!hyphen_char:array[internal_font_number] of integer;
  {current \.{\\hyphenchar} values}
@!skew_char:array[internal_font_number] of integer;
  {current \.{\\skewchar} values}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.550] ctype_base
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!param_base:array[internal_font_number] of integer;
  {base addresses for font parameters}
@y
@!param_base:array[internal_font_number] of integer;
  {base addresses for font parameters}
@!ctype_base:array[internal_font_number] of integer;
  {base addresses for font parameters}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.552] init ctype_base
%p[30.552] init font_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
italic_base[null_font]:=0; lig_kern_base[null_font]:=0;
kern_base[null_font]:=0; exten_base[null_font]:=0;
font_glue[null_font]:=null; font_params[null_font]:=7;
@y
italic_base[null_font]:=0; lig_kern_base[null_font]:=0;
kern_base[null_font]:=0; exten_base[null_font]:=0;
font_glue[null_font]:=null; font_params[null_font]:=7;
ctype_base[null_font]:=0;
for k:=font_base to font_max do font_dir[k]:=dir_default;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.557] glue_kern_start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d lig_kern_start(#)==lig_kern_base[#]+rem_byte {beginning of lig/kern program}
@y
@d glue_kern_base==lig_kern_base

@d lig_kern_start(#)==lig_kern_base[#]+rem_byte {beginning of lig/kern program}
@d glue_kern_start(#)==glue_kern_base[#]+rem_byte {beginning of glue/kern program}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.560] jfm_flag
%p[30.560] jfm_flag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function read_font_info(@!u:pointer;@!nom,@!aire:str_number;
  @!s:scaled):internal_font_number; {input a \.{TFM} file}
label done,bad_tfm,not_found;
var k:0..font_mem_size; {index into |font_info|}
@!file_opened:boolean; {was |tfm_file| successfully opened?}
@y
@p function read_font_info(@!u:pointer;@!nom,@!aire:str_number;
  @!s:scaled):internal_font_number; {input a \.{TFM} file}
label done,bad_tfm,not_found;
var k:0..font_mem_size; {index into |font_info|}
@!file_opened:boolean; {was |tfm_file| successfully opened?}
@!jfm_flag:dir_default..dir_tate;
@!jfm_id,nt:halfword;
@!cx:KANJI_code;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [30.563] opening tfm file: now path searching is done
%j[30.563] jfm_flag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Set temp_int to value of first byte
@x
@ @<Open |tfm_file| for input@>=
file_opened:=false;
if aire="" then pack_file_name(nom,TEX_font_area,".tfm")
else pack_file_name(nom,aire,".tfm");
if not b_open_in(tfm_file) then abort;
file_opened:=true
@y
@ @<Open |tfm_file| for input@>=
file_opened:=false;
jfm_flag:=dir_default;
pack_file_name(nom,aire,".tfm");
if not b_open_in(tfm_file) then abort;
file_opened:=true
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [30.564] reading the tfm file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% As a special case, whenever we open a tfm file, we read its first
% byte into "tfm_temp" right away.  TeX looks at "fbyte" before calling
% "fget", so it ends up seeing every byte.  This is Pascal-like I/O.
@x
@d fget==get(tfm_file)
@d fbyte==tfm_file^
@y
@d fget==tfm_temp:=getc(tfm_file)
@d fbyte==tfm_temp
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.565] read tfm size
%p[30.565] read tfm size
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Read the {\.{TFM}} size fields@>=
begin read_sixteen(lf);
fget; read_sixteen(lh);
fget; read_sixteen(bc);
fget; read_sixteen(ec);
if (bc>ec+1)or(ec>255) then abort;
fget; read_sixteen(nw);
fget; read_sixteen(nh);
fget; read_sixteen(nd);
fget; read_sixteen(ni);
fget; read_sixteen(nl);
fget; read_sixteen(nk);
fget; read_sixteen(ne);
fget; read_sixteen(np);
if lf<>6+lh+(ec-bc+1)+nw+nh+nd+ni+nl+nk+ne+np then abort;
end
@y
@ @d yoko_jfm_id=11 
@d tate_jfm_id=9

@<Read the {\.{TFM}} size fields@>=
  begin
    read_sixteen(jfmid);
    fget; read_sixteen(nt);
    if jfmid = yoko_jfm_id{ JFM_ID=11 } then begin
      jfm_flag:=dir_yoko; fget; read_sixteen(lf); fget; read_sixteen(lh);
    end else if jfmid = tate_jfm_id{ JFM_ID=9 } then begin
      jfm_flag:=dir_tate; fget; read_sixteen(lf); fget; read_sixteen(lh);
    end else begin
      jfm_flag:=dir_default; lf:=jfmid; lh:=nt; nt:=0;
    end;
    fget; read_sixteen(bc);
    fget; read_sixteen(ec);
    if (bc>ec+1)or(ec>255) then abort;
    fget; read_sixteen(nw);
    fget; read_sixteen(nh);
    fget; read_sixteen(nd);
    fget; read_sixteen(ni);
    fget; read_sixteen(nl);
    fget; read_sixteen(nk);
    fget; read_sixteen(ne);
    fget; read_sixteen(np);
    if jfm_flag<>dir_default then begin
      if lf<>7+lh+(ec-bc+1)+nt+nw+nh+nd+ni+nl+nk+ne+np then abort
    end else begin
      if lf<>6+lh+(ec-bc+1)+nw+nh+nd+ni+nl+nk+ne+np then abort
    end
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.566] set font_dir & font_num_ext
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Use size fields to allocate font information@>=
lf:=lf-6-lh; {|lf| words should be loaded into |font_info|}
if np<7 then lf:=lf+7-np; {at least seven parameters will appear}
if (font_ptr=font_max)or(fmem_ptr+lf>font_mem_size) then
  @<Apologize for not loading the font, |goto done|@>;
f:=font_ptr+1;
char_base[f]:=fmem_ptr-bc;
width_base[f]:=char_base[f]+ec+1;
height_base[f]:=width_base[f]+nw;
depth_base[f]:=height_base[f]+nh;
italic_base[f]:=depth_base[f]+nd;
lig_kern_base[f]:=italic_base[f]+ni;
kern_base[f]:=lig_kern_base[f]+nl;
exten_base[f]:=kern_base[f]+nk;
param_base[f]:=exten_base[f]+ne
@y
@<Use size fields to allocate font information@>=
lf:=lf-6-lh; {|lf| words should be loaded into |font_info|}
if jfm_flag<>dir_default then decr(lf);
if np<7 then lf:=lf+7-np; {at least seven parameters will appear}
if (font_ptr=font_max)or(fmem_ptr+lf>font_mem_size) then
  @<Apologize for not loading the font, |goto done|@>;
f:=font_ptr+1;
font_dir[f]:=jfm_flag;
font_num_ext[f]:=nt;
char_base[f]:=fmem_ptr-bc;
width_base[f]:=char_base[f]+ec+1;
height_base[f]:=width_base[f]+nw;
depth_base[f]:=height_base[f]+nh;
italic_base[f]:=depth_base[f]+nd;
lig_kern_base[f]:=italic_base[f]+ni;
kern_base[f]:=lig_kern_base[f]+nl;
exten_base[f]:=kern_base[f]+nk;
ctype_base[f]:=exten_base[f]+ne;
param_base[f]:=ctype_base[f]+nt;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.569] read char_type 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Read character data@>=
for k:=fmem_ptr to width_base[f]-1 do
  begin store_four_quarters(font_info[k].qqqq);
@y
@ @<Read character data@>=
if jfm_flag then
  for k:=ctype_base[f] to param_base[f]-1 do begin
    fget; PutHi(cx,fbyte); fget; PutLo(cx,fbyte);
    font_info[k].hh.rh:=tonum(cx);
    fget; PutHi(cx,fbyte); fget; PutLo(cx,fbyte);
    font_info[k].hh.v.LH:=tonum(cx);
  end;
for k:=fmem_ptr to width_base[f]-1 do
  begin store_four_quarters(font_info[k].qqqq);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.573] read  glue/kern program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Read ligature/kern program@>=
begin for k:=lig_kern_base[f] to kern_base[f]-1 do
  begin store_four_quarters(font_info[k].qqqq);
  check_byte_range(b);
  if c<128 then check_byte_range(d) {check ligature}
  else if d>=nk then abort; {check kern}
  end;
@y
@ @<Read ligature/kern program@>=
begin for k:=lig_kern_base[f] to kern_base[f]-1 do
  begin store_four_quarters(font_info[k].qqqq);
  check_byte_range(b);
  if c<128 then
    if jfm_flag then begin if d>=ne then abort; end
    else check_byte_range(d) {check ligature}
  else if d>=nk then abort; {check kern}
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.574] read jfm exten
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Read extensible character recipes@>=
for k:=exten_base[f] to param_base[f]-1 do
  begin store_four_quarters(font_info[k].qqqq);
  if a<>0 then check_byte_range(a);
  if b<>0 then check_byte_range(b);
  if c<>0 then check_byte_range(c);
  check_byte_range(d);
  end
@y
@ @<Read extensible character recipes@>=
if jfm_flag then
for k:=exten_base[f] to ctype_base[f]-1 do
  store_scaled(font_info[k].sc)
else for k:=exten_base[f] to param_base[f]-1 do
  begin store_four_quarters(font_info[k].qqqq);
  if a<>0 then check_byte_range(a);
  if b<>0 then check_byte_range(b);
  if c<>0 then check_byte_range(c);
  check_byte_range(d);
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.576] adjust ctype_base
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
adjust(char_base); adjust(width_base); adjust(lig_kern_base);
adjust(kern_base); adjust(exten_base);
decr(param_base[f]);
@y
adjust(char_base); adjust(width_base); adjust(lig_kern_base);
adjust(kern_base); adjust(exten_base); adjust(ctype_base);
decr(param_base[f]);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.577] jfont
%p[30.577] tfont
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin @<Get the next non-blank non-call...@>;
if cur_cmd=def_font then f:=cur_font
@y
begin @<Get the next non-blank non-call...@>;
if cur_cmd=def_jfont then f:=cur_jfont
else if cur_cmd=def_tfont then f:=cur_tfont
else if cur_cmd=def_font then f:=cur_font
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[30.581] jchar_worning
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure char_warning(@!f:internal_font_number;@!c:eight_bits);
begin if tracing_lost_chars>0 then
  begin begin_diagnostic;
  print_nl("Missing character: There is no ");
@.Missing character@>
  print_ASCII(c); print(" in font ");
  print(font_name[f]); print_char("!"); end_diagnostic(false);
  end;
end;
@y
@p procedure char_warning(@!f:internal_font_number;@!c:eight_bits);
begin if tracing_lost_chars>0 then
  begin begin_diagnostic;
  print_nl("Missing character: There is no ");
@.Missing character@>
  print_ASCII(c); print(" in font ");
  print(font_name[f]); print_char("!"); end_diagnostic(false);
  end;
end;

procedure jchar_warning(@!f:internal_font_number;@!jc:KANJI_code);
begin if tracing_lost_chars>0 then
  begin begin_diagnostic;
  print_nl("Missing character: There is no ");
@.Missing character@>
  print_char(Hi(jc)); print_char(Lo(jc));
  print(" in font ");
  print(font_name[f]); print_char("!"); end_diagnostic(false);
  end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[31.586] define set2 put2
%p[31.586] define dirchg
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @d set_char_0=0 {typeset character 0 and move right}
@d set1=128 {typeset a character and move right}
@d set_rule=132 {typeset a rule and move right}
@d put1=133 {typeset a character}
@d put_rule=137 {typeset a rule}
@d nop=138 {no operation}
@d bop=139 {beginning of page}
@d eop=140 {ending of page}
@d push=141 {save the current positions}
@d pop=142 {restore previous positions}
@d right1=143 {move right}
@d w0=147 {move right by |w|}
@d w1=148 {move right and set |w|}
@d x0=152 {move right by |x|}
@d x1=153 {move right and set |x|}
@d down1=157 {move down}
@d y0=161 {move down by |y|}
@d y1=162 {move down and set |y|}
@d z0=166 {move down by |z|}
@d z1=167 {move down and set |z|}
@d fnt_num_0=171 {set current font to 0}
@d fnt1=235 {set current font}
@d xxx1=239 {extension to \.{DVI} primitives}
@d xxx4=242 {potentially long extension to \.{DVI} primitives}
@d fnt_def1=243 {define the meaning of a font number}
@d pre=247 {preamble}
@d post=248 {postamble beginning}
@d post_post=249 {postamble ending}
@y
@ @d set_char_0=0 {typeset character 0 and move right}
@d set1=128 {typeset a character and move right}
@d set2=129 {typeset a character and move right}
@d set_rule=132 {typeset a rule and move right}
@d put1=133 {typeset a character}
@d put2=134 {typeset a character}
@d put_rule=137 {typeset a rule}
@d nop=138 {no operation}
@d bop=139 {beginning of page}
@d eop=140 {ending of page}
@d push=141 {save the current positions}
@d pop=142 {restore previous positions}
@d right1=143 {move right}
@d w0=147 {move right by |w|}
@d w1=148 {move right and set |w|}
@d x0=152 {move right by |x|}
@d x1=153 {move right and set |x|}
@d down1=157 {move down}
@d y0=161 {move down by |y|}
@d y1=162 {move down and set |y|}
@d z0=166 {move down by |z|}
@d z1=167 {move down and set |z|}
@d fnt_num_0=171 {set current font to 0}
@d fnt1=235 {set current font}
@d xxx1=239 {extension to \.{DVI} primitives}
@d xxx4=242 {potentially long extension to \.{DVI} primitives}
@d fnt_def1=243 {define the meaning of a font number}
@d pre=247 {preamble}
@d post=248 {postamble beginning}
@d post_post=249 {postamble ending}
@d dirchg=255 {direction change}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.590] ex_id_byte: This dvi is extended!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The last part of the postamble, following the |post_post| byte that
signifies the end of the font definitions, contains |q|, a pointer to the
|post| command that started the postamble.  An identification byte, |i|,
comes next; this currently equals~2, as in the preamble.
@y
@ The last part of the postamble, following the |post_post| byte that
signifies the end of the font definitions, contains |q|, a pointer to the
|post| command that started the postamble.

The |i| byte identifies \.{DVI} format.
If not extended, this equals~2; this is compatible with \TeX 82's \.{DVI}.
If extended, this is set to 3.
@z

@x
postamble, are ``frills'' that are handy but not absolutely necessary.)
@y
postamble, are ``frills'' that are handy but not absolutely necessary.)

@d ex_id_byte=3
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.592] dir_used: Is this dvi extended?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!last_bop:integer; {location of previous |bop| in the \.{DVI} output}
@!dead_cycles:integer; {recent outputs that didn't ship anything out}
@y
@!last_bop:integer; {location of previous |bop| in the \.{DVI} output}
@!dir_used:boolean; {Is this dvi extended?}
@!dead_cycles:integer; {recent outputs that didn't ship anything out}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.593] dir_used: Is this dvi extended?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Set init...@>=
total_pages:=0; max_v:=0; max_h:=0; max_push:=0; last_bop:=-1;
doing_leaders:=false; dead_cycles:=0; cur_s:=-1;
@y
@ @<Set init...@>=
total_pages:=0; max_v:=0; max_h:=0; max_push:=0; last_bop:=-1;
doing_leaders:=false; dead_cycles:=0; cur_s:=-1;
dir_used:=false;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [32.597] write_dvi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The actual output of |dvi_buf[a..b]| to |dvi_file| is performed by calling
|write_dvi(a,b)|. For best results, this procedure should be optimized to
run as fast as possible on each particular system, since it is part of
\TeX's inner loop. It is safe to assume that |a| and |b+1| will both be
multiples of 4 when |write_dvi(a,b)| is called; therefore it is possible on
many machines to use efficient methods to pack four bytes per word and to
output an array of words with one system call.
@^system dependencies@>
@^inner loop@>
@^defecation@>

@p procedure write_dvi(@!a,@!b:dvi_index);
var k:dvi_index;
begin for k:=a to b do write(dvi_file,dvi_buf[k]);
end;
@y
@ In C, we use a macro to call fwrite() or write() directly, writing all
the bytes to be written in one shot.  Much better even than writing four
bytes at a time.
@^system dependencies@>
@^inner loop@>
@^defecation@>
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.616] sync DVIreader's think and TeX's think: direction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!dvi_h,@!dvi_v:scaled; {a \.{DVI} reader program thinks we are here}
@!cur_h,@!cur_v:scaled; {\TeX\ thinks we are here}
@!dvi_f:internal_font_number; {the current font}
@!cur_s:integer; {current depth of output box nesting, initially $-1$}
@y
@!dvi_h,@!dvi_v:scaled; {a \.{DVI} reader program thinks we are here}
@!dvi_dir:integer; {a \.{DVI} reader program thinks we direct to}
@!cur_h,@!cur_v:scaled; {\TeX\ thinks we are here}
@!cur_dir:integer; {\TeX\ thinks we direct to}
@!dvi_f:internal_font_number; {the current font}
@!cur_s:integer; {current depth of output box nesting, initially $-1$}

@ direction change

@d dvi_yoko=0
@d dvi_tate=1
@d dvi_dtou=3

@p
procedure synch_dir;
var tmp:scaled;
begin
  case cur_dir of
  dir_yoko:
    if dvi_dir<>cur_dir then begin
      synch_h; synch_v; dvi_out(dirchg); dvi_out(dvi_yoko);
      dir_used:=true;
      case dvi_dir of
      dir_tate:
        begin tmp:=cur_h; cur_h:=-cur_v; cur_v:=tmp end;
      dir_dtou:
        begin tmp:=cur_h; cur_h:=cur_v; cur_v:=-tmp end;
      endcases;
      dvi_h:=cur_h; dvi_v:=cur_v; dvi_dir:=cur_dir;
    end;
  dir_tate:
    if dvi_dir<>cur_dir then begin
      synch_h; synch_v; dvi_out(dirchg); dvi_out(dvi_tate);
      dir_used:=true;
      case dvi_dir of
      dir_yoko:
        begin tmp:=cur_h; cur_h:=cur_v; cur_v:=-tmp end;
      dir_dtou:
        begin cur_v:=-cur_v; cur_h:=-cur_h; end;
      endcases;
      dvi_h:=cur_h; dvi_v:=cur_v; dvi_dir:=cur_dir;
    end;
  dir_dtou:
    if dvi_dir<>cur_dir then begin
      synch_h; synch_v; dvi_out(dirchg); dvi_out(dvi_dtou);
      dir_used:=true;
      case dvi_dir of
      dir_yoko:
        begin tmp:=cur_h; cur_h:=-cur_v; cur_v:=tmp end;
      dir_tate:
        begin cur_v:=-cur_v; cur_h:=-cur_h; end;
      endcases;
      dvi_h:=cur_h; dvi_v:=cur_v; dvi_dir:=cur_dir;
    end;
  othercases
    confusion("synch_dir");
  endcases
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.617] Initialize dvi_dir as shipout begins
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Initialize variables as |ship_out| begins@>=
dvi_h:=0; dvi_v:=0; cur_h:=h_offset; dvi_f:=null_font;
ensure_dvi_open;
if total_pages=0 then
  begin dvi_out(pre); dvi_out(id_byte); {output the preamble}
@^preamble of \.{DVI} file@>
@y
@ @<Initialize variables as |ship_out| begins@>=
  dvi_h:=0; dvi_v:=0; dvi_dir:=dir_yoko; dvi_f:=null_font;
  cur_h:=h_offset; cur_dir:=dir_yoko;
  ensure_dvi_open;
  if total_pages=0 then begin
    dvi_out(pre); dvi_out(id_byte); {output the preamble}
@^preamble of \.{DVI} file@>
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.619] dir_out
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure@?vlist_out; forward; {|hlist_out| and |vlist_out| are mutually
  recursive}
@y
@p procedure@?vlist_out; forward; {|hlist_out| and |vlist_out| are mutually
  recursive}
procedure@?hlist_out; forward; {|hlist_out| and |vlist_out| are mutually
  recursive}

procedure dir_out;
var
  @!this_box: pointer; {pointer to containing box}
begin
  this_box:=temp_ptr;
  temp_ptr:=list_ptr(this_box);
  if (type(temp_ptr)<>hlist_node)and(type(temp_ptr)<>vlist_node) then
    confusion("dir_out");
  case box_dir(this_box) of
  dir_yoko:
    case box_dir(temp_ptr) of
    dir_tate: {Tate in Yoko}
      begin cur_v:=cur_v-height(this_box); cur_h:=cur_h+depth(temp_ptr) end;
    dir_dtou: {DtoU in Yoko}
      begin cur_v:=cur_v+depth(this_box); cur_h:=cur_h+height(temp_ptr) end;
    endcases;
  dir_tate:
    case box_dir(temp_ptr) of
    dir_yoko: {Yoko in Tate}
      begin cur_v:=cur_v+depth(this_box); cur_h:=cur_h+height(temp_ptr) end;
    dir_dtou: {DtoU in Tate}
      begin
        cur_v:=cur_v+depth(this_box)-height(temp_ptr);
        cur_h:=cur_h+width(temp_ptr)
      end;
    endcases;
  dir_dtou:
    case box_dir(temp_ptr) of
    dir_yoko: {Yoko in DtoU}
      begin cur_v:=cur_v-height(this_box); cur_h:=cur_h+depth(temp_ptr) end;
    dir_tate: {Tate in DtoU}
      begin
        cur_v:=cur_v+depth(this_box)-height(temp_ptr);
        cur_h:=cur_h+width(temp_ptr)
      end;
    endcases;
  endcases;
  cur_dir:=box_dir(temp_ptr);
  if type(temp_ptr)=vlist_node then vlist_out@+else hlist_out;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[32.619] hlist_out Kanji
%p[32.619] hlist_out disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p @t\4@>@<Declare procedures needed in |hlist_out|, |vlist_out|@>@t@>@/
procedure hlist_out; {output an |hlist_node| box}
label reswitch, move_past, fin_rule, next_p;
var base_line: scaled; {the baseline coordinate for this box}
@!left_edge: scaled; {the left coordinate for this box}
@!save_h,@!save_v: scaled; {what |dvi_h| and |dvi_v| should pop to}
@!this_box: pointer; {pointer to containing box}
@!g_order: glue_ord; {applicable order of infinity for glue}
@!g_sign: normal..shrinking; {selects type of glue}
@!p:pointer; {current position in the hlist}
@!save_loc:integer; {\.{DVI} byte location upon entry}
@!leader_box:pointer; {the leader box being replicated}
@!leader_wd:scaled; {width of leader box being replicated}
@!lx:scaled; {extra space between leader boxes}
@!outer_doing_leaders:boolean; {were we doing leaders?}
@!edge:scaled; {left edge of sub-box, or right edge of leader space}
begin this_box:=temp_ptr; g_order:=glue_order(this_box);
g_sign:=glue_sign(this_box); p:=list_ptr(this_box);
incr(cur_s);
if cur_s>0 then dvi_out(push);
if cur_s>max_push then max_push:=cur_s;
save_loc:=dvi_offset+dvi_ptr; base_line:=cur_v; left_edge:=cur_h;
while p<>null do @<Output node |p| for |hlist_out| and move to the next node,
  maintaining the condition |cur_v=base_line|@>;
prune_movements(save_loc);
if cur_s>0 then dvi_pop(save_loc);
decr(cur_s);
end;
@y
@p @t\4@>@<Declare procedures needed in |hlist_out|, |vlist_out|@>@t@>@/
procedure hlist_out; {output an |hlist_node| box}
label reswitch, move_past, fin_rule, next_p;
var base_line: scaled; {the baseline coordinate for this box}
  @!disp: scaled; {displacement}
  @!left_edge: scaled; {the left coordinate for this box}
  @!save_h,@!save_v: scaled; {what |dvi_h| and |dvi_v| should pop to}
  @!save_dir:eight_bits; {what |dvi_dir| should pop to}
  @!this_box: pointer; {pointer to containing box}
  @!g_order: glue_ord; {applicable order of infinity for glue}
  @!g_sign: normal..shrinking; {selects type of glue}
  @!p:pointer; {current position in the hlist}
  @!k:pointer; {position of |auto_spacing_glue| in the hlist}
  @!save_loc:integer; {\.{DVI} byte location upon entry}
  @!leader_box:pointer; {the leader box being replicated}
  @!leader_wd:scaled; {width of leader box being replicated}
  @!lx:scaled; {extra space between leader boxes}
  @!outer_doing_leaders:boolean; {were we doing leaders?}
  @!edge:scaled; {left edge of sub-box, or right edge of leader space}
  @!jc:KANJI_code;
  @!t:integer;
begin
  this_box:=temp_ptr; g_order:=glue_order(this_box);
  g_sign:=glue_sign(this_box); p:=list_ptr(this_box);
  k:=space_ptr(this_box);
  incr(cur_s);
  if cur_s>0 then dvi_out(push);
  if cur_s>max_push then max_push:=cur_s;
  save_loc:=dvi_offset+dvi_ptr;
  synch_dir;
  base_line:=cur_v; left_edge:=cur_h; disp:=0;
  while p<>null do
    @<Output node |p| for |hlist_out| and move to the next node,
      maintaining the condition |cur_v=base_line|@>;
  prune_movements(save_loc);
  if cur_s>0 then dvi_pop(save_loc);
  decr(cur_s);
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[32.620] dvi output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Output node |p| for |hlist_out|...@>=
reswitch: if is_char_node(p) then
  begin synch_h; synch_v;
  repeat f:=font(p); c:=character(p);
  if f<>dvi_f then @<Change font |dvi_f| to |f|@>;
  if c>=qi(128) then dvi_out(set1);
  dvi_out(qo(c));@/
  cur_h:=cur_h+char_width(f)(char_info(f)(c));
  p:=link(p);
  until not is_char_node(p);
  dvi_h:=cur_h;
  end
else @<Output the non-|char_node| |p| for |hlist_out|
    and move to the next node@>
@y
@<Output node |p| for |hlist_out|...@>=
reswitch:
if is_char_node(p) then begin
  synch_h; synch_v; chain:=false;
  repeat
    f:=font(p); c:=character(p);
    if f<>dvi_f then @<Change font |dvi_f| to |f|@>;
    if font_dir[f]<>dir_default then begin
      if chain then begin
        cur_h:=cur_h+width(k);
        if g_sign<>normal then begin
          if g_sign=stretching then begin
            if stretch_order(k)=g_order then
              cur_h:=cur_h+round(float(glue_set(this_box))*stretch(k));
@^real multiplication@>
          end else begin
            if shrink_order(k)=g_order then
              cur_h:=cur_h-round(float(glue_set(this_box))*shrink(k));
          end;
        end;
        synch_h;
      end else
        chain:=true;
      p:=link(p);
      KANJI(jc):=info(p); t:=tonum(jc);
      dvi_out(set2); KANJI(jc):=SJIStoJIS(t); jc:=tokanji(KANJI(jc));
      dvi_out(Hi(jc)); dvi_out(Lo(jc))
    end else begin
      if c<qi(128) then dvi_out(qo(c))
      else begin dvi_out(set1); dvi_out(qo(c)) end;
      chain:=false;
    end;
    cur_h:=cur_h+char_width(f)(char_info(f)(c));
    dvi_h:=cur_h; p:=link(p);
  until not is_char_node(p);
  chain:=false;
end else
  @<Output the non-|char_node| |p| for |hlist_out| and move to the next node@>
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.622] disp_node, dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Output the non-|char_node| |p| for |hlist_out|...@>=
begin case type(p) of
hlist_node,vlist_node:@<Output a box in an hlist@>;
rule_node: begin rule_ht:=height(p); rule_dp:=depth(p); rule_wd:=width(p);
  goto fin_rule;
  end;
whatsit_node: @<Output the whatsit node |p| in an hlist@>;
glue_node: @<Move right or output leaders@>;
kern_node,math_node:cur_h:=cur_h+width(p);
ligature_node: @<Make node |p| look like a |char_node| and |goto reswitch|@>;
othercases do_nothing
endcases;@/
goto next_p;
fin_rule: @<Output a rule in an hlist@>;
move_past: cur_h:=cur_h+rule_wd;
next_p:p:=link(p);
end
@y
@ @<Output the non-|char_node| |p| for |hlist_out|...@>=
  begin
    case type(p) of
    hlist_node,vlist_node,dir_node:@<Output a box in an hlist@>;
    rule_node:
      begin
        rule_ht:=height(p); rule_dp:=depth(p); rule_wd:=width(p);
        goto fin_rule;
      end;
    whatsit_node: @<Output the whatsit node |p| in an hlist@>;
    disp_node:
      begin
        disp:=disp_dimen(p); cur_v:=base_line+disp;
      end;
    glue_node: @<Move right or output leaders@>;
    kern_node,math_node: cur_h:=cur_h+width(p);
    ligature_node:
      @<Make node |p| look like a |char_node| and |goto reswitch|@>;
    othercases do_nothing
    endcases;@/
    goto next_p;
fin_rule:
    @<Output a rule in an hlist@>;
move_past:
    cur_h:=cur_h+rule_wd;
next_p:
    p:=link(p);
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.623] output a box(and dir_node) with disp
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Output a box in an hlist@>=
if list_ptr(p)=null then cur_h:=cur_h+width(p)
else  begin save_h:=dvi_h; save_v:=dvi_v;
  cur_v:=base_line+shift_amount(p); {shift the box down}
  temp_ptr:=p; edge:=cur_h;
  if type(p)=vlist_node then vlist_out@+else hlist_out;
  dvi_h:=save_h; dvi_v:=save_v;
  cur_h:=edge+width(p); cur_v:=base_line;
  end
@y
@ @<Output a box in an hlist@>=
  if list_ptr(p)=null then cur_h:=cur_h+width(p)
  else begin
    save_h:=dvi_h; save_v:=dvi_v; save_dir:=dvi_dir;
    cur_v:=base_line+disp+shift_amount(p); {shift the box down}
    temp_ptr:=p; edge:=cur_h;
    case type(p) of
      hlist_node:hlist_out;
      vlist_node:vlist_out;
      dir_node:dir_out;
    endcases;
    dvi_h:=save_h; dvi_v:=save_v; dvi_dir:=save_dir;
    cur_h:=edge+width(p); cur_v:=base_line+disp; cur_dir:=save_dir;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.624] Output a rule with disp
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Output a rule in an hlist@>=
if is_running(rule_ht) then rule_ht:=height(this_box);
if is_running(rule_dp) then rule_dp:=depth(this_box);
rule_ht:=rule_ht+rule_dp; {this is the rule thickness}
if (rule_ht>0)and(rule_wd>0) then {we don't output empty rules}
  begin synch_h; cur_v:=base_line+rule_dp; synch_v;
  dvi_out(set_rule); dvi_four(rule_ht); dvi_four(rule_wd);
  cur_v:=base_line; dvi_h:=dvi_h+rule_wd;
  end
@y
@ @<Output a rule in an hlist@>=
  if is_running(rule_ht) then rule_ht:=height(this_box)+disp;
  if is_running(rule_dp) then rule_dp:=depth(this_box)-disp;
  rule_ht:=rule_ht+rule_dp; {this is the rule thickness}
  if (rule_ht>0)and(rule_wd>0) then begin {we don't output empty rules}
    synch_h; cur_v:=base_line+disp+rule_dp; synch_v;
    dvi_out(set_rule); dvi_four(rule_ht); dvi_four(rule_wd);
    cur_v:=base_line+disp; dvi_h:=dvi_h+rule_wd;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.628] Output a leader box(and dir_node) with disp
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Output a leader box at |cur_h|, ...@>=
begin cur_v:=base_line+shift_amount(leader_box); synch_v; save_v:=dvi_v;@/
synch_h; save_h:=dvi_h; temp_ptr:=leader_box;
outer_doing_leaders:=doing_leaders; doing_leaders:=true;
if type(leader_box)=vlist_node then vlist_out@+else hlist_out;
doing_leaders:=outer_doing_leaders;
dvi_v:=save_v; dvi_h:=save_h; cur_v:=save_v;
cur_h:=save_h+leader_wd+lx;
end
@y
@<Output a leader box at |cur_h|, ...@>=
  begin
    cur_v:=base_line+disp+shift_amount(leader_box); synch_v; save_v:=dvi_v;@/
    synch_h; save_h:=dvi_h;
    save_dir:=dvi_dir;
    temp_ptr:=leader_box;
    outer_doing_leaders:=doing_leaders; doing_leaders:=true;
    case type(leader_box) of
      hlist_node:hlist_out;
      vlist_node:vlist_out;
      dir_node:dir_out;
    endcases;
    doing_leaders:=outer_doing_leaders;
    dvi_v:=save_v; dvi_h:=save_h; dvi_dir:=save_dir;
    cur_v:=save_v; cur_h:=save_h+leader_wd+lx; cur_dir:=save_dir;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.629] vlist_out
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure vlist_out; {output a |vlist_node| box}
label move_past, fin_rule, next_p;
var left_edge: scaled; {the left coordinate for this box}
@!top_edge: scaled; {the top coordinate for this box}
@!save_h,@!save_v: scaled; {what |dvi_h| and |dvi_v| should pop to}
@!this_box: pointer; {pointer to containing box}
@!g_order: glue_ord; {applicable order of infinity for glue}
@!g_sign: normal..shrinking; {selects type of glue}
@!p:pointer; {current position in the vlist}
@!save_loc:integer; {\.{DVI} byte location upon entry}
@!leader_box:pointer; {the leader box being replicated}
@!leader_ht:scaled; {height of leader box being replicated}
@!lx:scaled; {extra space between leader boxes}
@!outer_doing_leaders:boolean; {were we doing leaders?}
@!edge:scaled; {bottom boundary of leader space}
begin this_box:=temp_ptr; g_order:=glue_order(this_box);
g_sign:=glue_sign(this_box); p:=list_ptr(this_box);
incr(cur_s);
if cur_s>0 then dvi_out(push);
if cur_s>max_push then max_push:=cur_s;
save_loc:=dvi_offset+dvi_ptr; left_edge:=cur_h; cur_v:=cur_v-height(this_box);
top_edge:=cur_v;
while p<>null do @<Output node |p| for |vlist_out| and move to the next node,
  maintaining the condition |cur_h=left_edge|@>;
prune_movements(save_loc);
if cur_s>0 then dvi_pop(save_loc);
decr(cur_s);
end;
@y
@p
procedure vlist_out; {output a |vlist_node| box}
label move_past, fin_rule, next_p;
var left_edge: scaled; {the left coordinate for this box}
  @!top_edge: scaled; {the top coordinate for this box}
  @!save_h,@!save_v: scaled; {what |dvi_h| and |dvi_v| should pop to}
  @!save_dir:integer; {what |dvi_dir| should pop to}
  @!this_box: pointer; {pointer to containing box}
  @!g_order: glue_ord; {applicable order of infinity for glue}
  @!g_sign: normal..shrinking; {selects type of glue}
  @!p:pointer; {current position in the vlist}
  @!save_loc:integer; {\.{DVI} byte location upon entry}
  @!leader_box:pointer; {the leader box being replicated}
  @!leader_ht:scaled; {height of leader box being replicated}
  @!lx:scaled; {extra space between leader boxes}
  @!outer_doing_leaders:boolean; {were we doing leaders?}
  @!edge:scaled; {bottom boundary of leader space}
begin
  this_box:=temp_ptr; g_order:=glue_order(this_box);
  g_sign:=glue_sign(this_box); p:=list_ptr(this_box);
  incr(cur_s);
  if cur_s>0 then dvi_out(push);
  if cur_s>max_push then max_push:=cur_s;
  save_loc:=dvi_offset+dvi_ptr;
  synch_dir;
  left_edge:=cur_h; cur_v:=cur_v-height(this_box);
  top_edge:=cur_v;
  while p<>null do
    @<Output node |p| for |vlist_out| and move to the next node,
      maintaining the condition |cur_h=left_edge|@>;
  prune_movements(save_loc);
  if cur_s>0 then dvi_pop(save_loc);
  decr(cur_s);
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.631] output non-char-node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Output the non-|char_node| |p| for |vlist_out|@>=
begin case type(p) of
hlist_node,vlist_node:@<Output a box in a vlist@>;
rule_node: begin rule_ht:=height(p); rule_dp:=depth(p); rule_wd:=width(p);
  goto fin_rule;
  end;
whatsit_node: @<Output the whatsit node |p| in a vlist@>;
glue_node: @<Move down or output leaders@>;
kern_node:cur_v:=cur_v+width(p);
othercases do_nothing
endcases;@/
goto next_p;
fin_rule: @<Output a rule in a vlist, |goto next_p|@>;
move_past: cur_v:=cur_v+rule_ht;
end
@y
@ @<Output the non-|char_node| |p| for |vlist_out|@>=
begin
  case type(p) of
    hlist_node,vlist_node,dir_node:
      @<Output a box in a vlist@>;
    rule_node: begin
        rule_ht:=height(p); rule_dp:=depth(p); rule_wd:=width(p);
        goto fin_rule;
      end;
    whatsit_node: @<Output the whatsit node |p| in a vlist@>;
    glue_node: @<Move down or output leaders@>;
    kern_node:cur_v:=cur_v+width(p);
    othercases do_nothing
  endcases;@/
  goto next_p;
  fin_rule: @<Output a rule in a vlist, |goto next_p|@>;
  move_past: cur_v:=cur_v+rule_ht;
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.632] Output a box in a vlist
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Output a box in a vlist@>=
if list_ptr(p)=null then cur_v:=cur_v+height(p)+depth(p)
else  begin cur_v:=cur_v+height(p); synch_v;
  save_h:=dvi_h; save_v:=dvi_v;
  cur_h:=left_edge+shift_amount(p); {shift the box right}
  temp_ptr:=p;
  if type(p)=vlist_node then vlist_out@+else hlist_out;
  dvi_h:=save_h; dvi_v:=save_v;
  cur_v:=save_v+depth(p); cur_h:=left_edge;
  end
@y
@<Output a box in a vlist@>=
  if list_ptr(p)=null then cur_v:=cur_v+height(p)+depth(p)
  else begin
    cur_v:=cur_v+height(p); synch_v;
    save_h:=dvi_h; save_v:=dvi_v; save_dir:=dvi_dir;
    cur_h:=left_edge+shift_amount(p); {shift the box right}
    temp_ptr:=p;
    case type(p) of
      hlist_node:hlist_out;
      vlist_node:vlist_out;
      dir_node:dir_out;
    endcases;
    dvi_h:=save_h; dvi_v:=save_v; dvi_dir:=save_dir;
    cur_v:=save_v+depth(p); cur_h:=left_edge; cur_dir:=save_dir;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.637] Output a leader in a vlist
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Output a leader box at |cur_v|, ...@>=
begin cur_h:=left_edge+shift_amount(leader_box); synch_h; save_h:=dvi_h;@/
cur_v:=cur_v+height(leader_box); synch_v; save_v:=dvi_v;
temp_ptr:=leader_box;
outer_doing_leaders:=doing_leaders; doing_leaders:=true;
if type(leader_box)=vlist_node then vlist_out@+else hlist_out;
doing_leaders:=outer_doing_leaders;
dvi_v:=save_v; dvi_h:=save_h; cur_h:=save_h;
cur_v:=save_v-height(leader_box)+leader_ht+lx;
end
@y
@<Output a leader box at |cur_v|, ...@>=
  begin
    cur_h:=left_edge+shift_amount(leader_box); synch_h; save_h:=dvi_h;@/
    cur_v:=cur_v+height(leader_box); synch_v; save_v:=dvi_v;
    save_dir:=dvi_dir;
    temp_ptr:=leader_box;
    outer_doing_leaders:=doing_leaders; doing_leaders:=true;
    case type(leader_box) of
      hlist_node:hlist_out;
      vlist_node:vlist_out;
      dir_node:dir_out;
    endcases;
    doing_leaders:=outer_doing_leaders;
    dvi_v:=save_v; dvi_h:=save_h; dvi_dir:=save_dir;
    cur_h:=save_h; cur_v:=save_v-height(leader_box)+leader_ht+lx;
    cur_dir:=save_dir;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.638] ship out
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure ship_out(@!p:pointer); {output the box |p|}
label done;
var page_loc:integer; {location of the current |bop|}
@!j,@!k:0..9; {indices to first ten count registers}
@!s:pool_pointer; {index into |str_pool|}
@!old_setting:0..max_selector; {saved |selector| setting}
@y
@p procedure ship_out(@!p:pointer); {output the box |p|}
label done;
var page_loc:integer; {location of the current |bop|}
@!tmp:pointer;
@!j,@!k:0..9; {indices to first ten count registers}
@!s:pool_pointer; {index into |str_pool|}
@!old_setting:0..max_selector; {saved |selector| setting}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[32.640] ship out
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Ship box |p| out@>=
@<Update the values of |max_h| and |max_v|; but if the page is too large,
  |goto done|@>;
@<Initialize variables as |ship_out| begins@>;
page_loc:=dvi_offset+dvi_ptr;
dvi_out(bop);
for k:=0 to 9 do dvi_four(count(k));
dvi_four(last_bop); last_bop:=page_loc;
cur_v:=height(p)+v_offset; temp_ptr:=p;
if type(p)=vlist_node then vlist_out@+else hlist_out;
dvi_out(eop); incr(total_pages); cur_s:=-1;
done:
@y
@ @<Ship box |p| out@>=
  if type(p)=dir_node then begin
    tmp:=p; p:=list_ptr(p);
    delete_glue_ref(space_ptr(tmp));
    delete_glue_ref(xspace_ptr(tmp));
    free_node(tmp,box_node_size);
  end;
  flush_node_list(link(p)); link(p):=null;
  if box_dir(p)<>dir_yoko then
    p:=new_dir_node(p,dir_yoko);
  @<Update the values of |max_h| and |max_v|; but if the page is too large,
    |goto done|@>;
  @<Initialize variables as |ship_out| begins@>;
  page_loc:=dvi_offset+dvi_ptr;
  dvi_out(bop);
  for k:=0 to 9 do dvi_four(count(k));
  dvi_four(last_bop); last_bop:=page_loc;
  cur_v:=height(p)+v_offset;
  temp_ptr:=p;
  case type(p) of
  hlist_node:hlist_out;
  vlist_node:vlist_out;
  dir_node:dir_out;
  endcases;
  dvi_out(eop); incr(total_pages); cur_s:=-1;
done:
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[33.642] postamble's id_byte
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  @<Output the font definitions for all fonts that were used@>;
  dvi_out(post_post); dvi_four(last_bop); dvi_out(id_byte);@/
@y
  @<Output the font definitions for all fonts that were used@>;
  dvi_out(post_post); dvi_four(last_bop);
  if dir_used then dvi_out(ex_id_byte) else dvi_out(id_byte);@/
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[33.647] last_disp
%j[33.647] cur_kanji_skip, cur_xkanji_skip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!adjust_tail:pointer; {tail of adjustment list}
@y
@!adjust_tail:pointer; {tail of adjustment list}
@!last_disp:scaled; {displacement at end of list}
@!cur_kanji_skip:pointer;
@!cur_xkanji_skip:pointer;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[33.648] cur_kanji_skip, cur_xkanji_skip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Set init...@>=adjust_tail:=null;
@y
@ @<Set init...@>=
  adjust_tail:=null;
  cur_kanji_skip:=zero_glue; cur_xkanji_skip:=zero_glue;
  incr(glue_ref_count(cur_kanji_skip));
  incr(glue_ref_count(cur_xkanji_skip));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[33.649] hpack
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function hpack(@!p:pointer;@!w:scaled;@!m:small_number):pointer;
label reswitch, common_ending, exit;
var r:pointer; {the box node that will be returned}
@!q:pointer; {trails behind |p|}
@!h,@!d,@!x:scaled; {height, depth, and natural width}
@!s:scaled; {shift amount}
@!g:pointer; {points to a glue specification}
@!o:glue_ord; {order of infinity}
@!f:internal_font_number; {the font in a |char_node|}
@!i:four_quarters; {font information about a |char_node|}
@!hd:eight_bits; {height and depth indices for a character}
@!b:integer; {badness of the new box}
begin r:=get_node(box_node_size); type(r):=hlist_node;
subtype(r):=min_quarterword; shift_amount(r):=0;
q:=r+list_offset; link(q):=p;@/
h:=0; @<Clear dimensions to zero@>;
while p<>null do @<Examine node |p| in the hlist, taking account of its effect
  on the dimensions of the new box, or moving it to the adjustment list;
  then advance |p| to the next node@>;
if adjust_tail<>null then link(adjust_tail):=null;
height(r):=h; depth(r):=d;@/
@<Determine the value of |width(r)| and the appropriate glue setting;
  then |return| or |goto common_ending|@>;
common_ending: @<Finish issuing a diagnostic message
      for an overfull or underfull hbox@>;
exit: hpack:=r;
end;
@y
@p
function hpack(@!p:pointer;@!w:scaled;@!m:small_number):pointer;
label reswitch, common_ending, exit;
var r:pointer; {the box node that will be returned}
  @!q:pointer; {trails behind |p|}
  @!h,@!d,@!x:scaled; {height, depth, and natural width}
  @!s:scaled; {shift amount}
  @!g:pointer; {points to a glue specification}
  @!k:pointer; {points to a kanji_space specification}
  @!o:glue_ord; {order of infinity}
  @!f:internal_font_number; {the font in a |char_node|}
  @!i:four_quarters; {font information about a |char_node|}
  @!hd:eight_bits; {height and depth indices for a character}
  @!b:integer; {badness of the new box}
  @!disp:scaled; {displacement}
begin
  r:=get_node(box_node_size); type(r):=hlist_node;
  subtype(r):=min_quarterword; shift_amount(r):=0;
  space_ptr(r):=cur_kanji_skip; xspace_ptr(r):=cur_xkanji_skip;
  add_glue_ref(cur_kanji_skip); add_glue_ref(cur_xkanji_skip);
  k:=cur_kanji_skip;
  q:=r+list_offset; link(q):=p;@/
  h:=0; @<Clear dimensions to zero@>;
  disp:=0;
  while p<>null do
    @<Examine node |p| in the hlist, taking account of its effect
      on the dimensions of the new box, or moving it to the adjustment list;
      then advance |p| to the next node@>;
  if adjust_tail<>null then link(adjust_tail):=null;
  height(r):=h; depth(r):=d;@/
  @<Determine the value of |width(r)| and the appropriate glue setting;
    then |return| or |goto common_ending|@>;
common_ending:
  @<Finish issuing a diagnostic message for an overfull or underfull hbox@>;
exit:
  last_disp:=disp; hpack:=r;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[33.651] reset chain
%p[33.651] dir_node, disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Examine node |p| in the hlist, taking account of its effect...@>=
@^inner loop@>
begin reswitch: while is_char_node(p) do
  @<Incorporate character dimensions into the dimensions of
    the hbox that will contain~it, then move to the next node@>;
if p<>null then
  begin case type(p) of
  hlist_node,vlist_node,rule_node,unset_node:
    @<Incorporate box dimensions into the dimensions of
      the hbox that will contain~it@>;
  ins_node,mark_node,adjust_node: if adjust_tail<>null then
    @<Transfer node |p| to the adjustment list@>;
  whatsit_node:@<Incorporate a whatsit node into an hbox@>;
  glue_node:@<Incorporate glue into the horizontal totals@>;
  kern_node,math_node: x:=x+width(p);
  ligature_node: @<Make node |p| look like a |char_node|
    and |goto reswitch|@>;
  othercases do_nothing
  endcases;@/
  p:=link(p);
  end;
end
@y
@ @<Examine node |p| in the hlist, taking account of its effect...@>=
@^inner loop@>
  begin
reswitch:
    chain:=false; while is_char_node(p) do
      @<Incorporate character dimensions into the dimensions of
        the hbox that will contain~it, then move to the next node@>;
    if p<>null then begin
      case type(p) of
      hlist_node,vlist_node,dir_node,rule_node,unset_node:
        @<Incorporate box dimensions into the dimensions of
          the hbox that will contain~it@>;
      ins_node,mark_node,adjust_node:
        if adjust_tail<>null then
          @<Transfer node |p| to the adjustment list@>;
      whatsit_node: @<Incorporate a whatsit node into an hbox@>;
      disp_node: disp:=disp_dimen(p);
      glue_node: @<Incorporate glue into the horizontal totals@>;
      kern_node,math_node: x:=x+width(p);
      ligature_node:
        @<Make node |p| look like a |char_node| and |goto reswitch|@>;
      othercases do_nothing
      endcases;@/
      p:=link(p);
    end;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[33.653] displacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Incorporate box dimensions into the dimensions of the hbox...@>=
begin x:=x+width(p);
if type(p)>=rule_node then s:=0 @+else s:=shift_amount(p);
if height(p)-s>h then h:=height(p)-s;
if depth(p)+s>d then d:=depth(p)+s;
end
@y
@<Incorporate box dimensions into the dimensions of the hbox...@>=
  begin
    x:=x+width(p);
    if type(p)>=rule_node then s:=disp @+else s:=shift_amount(p)+disp;
    if height(p)-s>h then h:=height(p)-s;
    if depth(p)+s>d then d:=depth(p)+s;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[33.654] auto spacing
%p[33.654] displacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Incorporate character dimensions into the dimensions of the hbox...@>=
begin f:=font(p); i:=char_info(f)(character(p)); hd:=height_depth(i);
x:=x+char_width(f)(i);@/
s:=char_height(f)(hd);@+if s>h then h:=s;
s:=char_depth(f)(hd);@+if s>d then d:=s;
p:=link(p);
end
@y
@<Incorporate character dimensions into the dimensions of the hbox...@>=
  begin
    f:=font(p); i:=char_info(f)(character(p)); hd:=height_depth(i);
    x:=x+char_width(f)(i);@/
    s:=char_height(f)(hd)-disp; if s>h then h:=s;
    s:=char_depth(f)(hd)+disp; if s>d then d:=s;
    if font_dir[f]<>dir_default then begin
      p:=link(p);
      if chain then begin
        x:=x+width(k);@/
        o:=stretch_order(k); total_stretch[o]:=total_stretch[o]+stretch(k);
        o:=shrink_order(k); total_shrink[o]:=total_shrink[o]+shrink(k);
      end else chain:=true;
    end else chain:=false;
    p:=link(p);
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[34.668] vpackage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin r:=get_node(box_node_size); type(r):=vlist_node;
subtype(r):=min_quarterword; shift_amount(r):=0;
list_ptr(r):=p;@/
@y
begin r:=get_node(box_node_size); type(r):=vlist_node;
subtype(r):=min_quarterword; shift_amount(r):=0;
space_ptr(r):=zero_glue; xspace_ptr(r):=zero_glue;
add_glue_ref(zero_glue); add_glue_ref(zero_glue);
list_ptr(r):=p;@/
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[33.669] dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Examine node |p| in the vlist, taking account of its effect...@>=
begin if is_char_node(p) then confusion("vpack")
@:this can't happen vpack}{\quad vpack@>
else  case type(p) of
  hlist_node,vlist_node,rule_node,unset_node:
    @<Incorporate box dimensions into the dimensions of
      the vbox that will contain~it@>;
  whatsit_node:@<Incorporate a whatsit node into a vbox@>;
  glue_node: @<Incorporate glue into the vertical totals@>;
  kern_node: begin x:=x+d+width(p); d:=0;
    end;
  othercases do_nothing
  endcases;
p:=link(p);
end
@y
@ @<Examine node |p| in the vlist, taking account of its effect...@>=
  begin
    if is_char_node(p) then confusion("vpack")
@:this can't happen vpack}{\quad vpack@>
    else
      case type(p) of
      hlist_node,vlist_node,dir_node,rule_node,unset_node:
        @<Incorporate box dimensions into the dimensions of
          the vbox that will contain~it@>;
      whatsit_node:@<Incorporate a whatsit node into a vbox@>;
      glue_node: @<Incorporate glue into the vertical totals@>;
      kern_node:
        begin
          x:=x+d+width(p); d:=0;
        end;
      othercases do_nothing
      endcases;
    p:=link(p);
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[34.681] math noad
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d noad_size=4 {number of words in a normal noad}
@d nucleus(#)==#+1 {the |nucleus| field of a noad}
@d supscr(#)==#+2 {the |supscr| field of a noad}
@d subscr(#)==#+3 {the |subscr| field of a noad}
@y
@d noad_size=5 {number of words in a normal noad}
@d nucleus(#)==#+1 {the |nucleus| field of a noad}
@d supscr(#)==#+2 {the |supscr| field of a noad}
@d subscr(#)==#+3 {the |subscr| field of a noad}
@d kcode_noad(#)==#+4
@d math_kcode(#)==info(#+4) {the |kanji character| field of a noad}

@d kcode_noad_nucleus(#)==#+3
@d math_kcode_nucleus(#)==info(#+3)
	{the |kanji character| field offset from nucleus}

@d math_jchar=5
@d math_text_jchar=6
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[34.686] new_noad
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
mem[supscr(p)].hh:=empty_field;
new_noad:=p;
@y
mem[supscr(p)].hh:=empty_field;
mem[kcode_noad(p)].hh:=empty_field;
new_noad:=p;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[35.691] print_fam_and_char
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure print_fam_and_char(@!p:pointer); {prints family and character}
begin print_esc("fam"); print_int(fam(p)); print_char(" ");
print_ASCII(qo(character(p)));
@y
procedure print_fam_and_char(@!p:pointer;@!t:small_number);
					{prints family and character}
var @!cx:KANJI_code;
begin print_esc("fam"); print_int(fam(p)); print_char(" ");
if t=math_char then print_ASCII(qo(character(p)))
  else begin KANJI(cx):=math_kcode_nucleus(p);
    print_char(Hi(cx)); print_char(Lo(cx));
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[35.692] print_subsidiary_data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  math_char: begin print_ln; print_current_string; print_fam_and_char(p);
@y
  math_char, math_jchar: begin print_ln; print_current_string;
    print_fam_and_char(p, math_type(p));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[35.696] print_fam_and_char
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
accent_noad: begin print_esc("accent"); print_fam_and_char(accent_chr(p));
@y
accent_noad: begin print_esc("accent");
  print_fam_and_char(accent_chr(p), math_char);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[35.715] rebox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function rebox(@!b:pointer;@!w:scaled):pointer;
var p:pointer; {temporary register for list manipulation}
@!f:internal_font_number; {font in a one-character box}
@!v:scaled; {width of a character without italic correction}
begin if (width(b)<>w)and(list_ptr(b)<>null) then
  begin if type(b)=vlist_node then b:=hpack(b,natural);
  p:=list_ptr(b);
  if (is_char_node(p))and(link(p)=null) then
    begin f:=font(p); v:=char_width(f)(char_info(f)(character(p)));
    if v<>width(b) then link(p):=new_kern(width(b)-v);
    end;
  free_node(b,box_node_size);
  b:=new_glue(ss_glue); link(b):=p;
  while link(p)<>null do p:=link(p);
  link(p):=new_glue(ss_glue);
  rebox:=hpack(b,w,exactly);
  end
else  begin width(b):=w; rebox:=b;
  end;
end;
@y
@p function rebox(@!b:pointer;@!w:scaled):pointer;
var p:pointer; {temporary register for list manipulation}
  @!f:internal_font_number; {font in a one-character box}
  @!v:scaled; {width of a character without italic correction}
begin
  if (width(b)<>w)and(list_ptr(b)<>null) then begin
    if type(b)<>hlist_node then b:=hpack(b,natural);
    p:=list_ptr(b);
    if is_char_node(p) then
      if font_dir[font(p)]<>dir_default then begin
        if link(link(p))=null then begin
          f:=font(p); v:=char_width(f)(char_info(f)(character(p)));
          if v<>width(b) then link(link(p)):=new_kern(width(b)-v);
        end
      end else if link(p)=null then begin
        f:=font(p); v:=char_width(f)(char_info(f)(character(p)));
        if v<>width(b) then link(p):=new_kern(width(b)-v);
      end;
    delete_glue_ref(space_ptr(b));
    delete_glue_ref(xspace_ptr(b));
    free_node(b,box_node_size);
    b:=new_glue(ss_glue); link(b):=p;
    while link(p)<>null do p:=link(p);
    link(p):=new_glue(ss_glue);
    rebox:=hpack(b,w,exactly);
  end else begin
    width(b):=w; rebox:=b;
  end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.720] clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
function clean_box(@!p:pointer;@!s:small_number):pointer;
label found;
var q:pointer; {beginning of a list to be boxed}
@!save_style:small_number; {|cur_style| to be restored}
@!x:pointer; {box to be returned}
@!r:pointer; {temporary pointer}
begin case math_type(p) of
math_char: begin cur_mlist:=new_noad; mem[nucleus(cur_mlist)]:=mem[p];
  end;
sub_box: begin q:=info(p); goto found;
  end;
sub_mlist: cur_mlist:=info(p);
othercases begin q:=new_null_box; goto found;
  end
endcases;@/
save_style:=cur_style; cur_style:=s; mlist_penalties:=false;@/
mlist_to_hlist; q:=link(temp_head); {recursive call}
cur_style:=save_style; {restore the style}
@<Set up the values of |cur_size| and |cur_mu|, based on |cur_style|@>;
found: if is_char_node(q)or(q=null) then x:=hpack(q,natural)
  else if (link(q)=null)and(type(q)<=vlist_node)and(shift_amount(q)=0) then
    x:=q {it's already clean}
  else x:=hpack(q,natural);
@<Simplify a trivial box@>;
clean_box:=x;
end;
@y
function clean_box(@!p:pointer;@!s:small_number;@!jc:halfword):pointer;
label found;
var q:pointer; {beginning of a list to be boxed}
  @!save_style:small_number; {|cur_style| to be restored}
  @!x:pointer; {box to be returned}
  @!r:pointer; {temporary pointer}
begin
  case math_type(p) of
    math_char,math_jchar:
      begin
        cur_mlist:=new_noad;
        mem[nucleus(cur_mlist)]:=mem[p];
        if math_type(p)=math_jchar then math_kcode(cur_mlist):=jc;
      end;
    sub_box:
      begin q:=info(p); goto found; end;
    sub_mlist: cur_mlist:=info(p);
    othercases begin q:=new_null_box; goto found; end
  endcases;@/
  save_style:=cur_style; cur_style:=s; mlist_penalties:=false;@/
  mlist_to_hlist; q:=link(temp_head); {recursive call}
  cur_style:=save_style; {restore the style}
  @<Set up the values of |cur_size| and |cur_mu|, based on |cur_style|@>;
found:
  if is_char_node(q)or(q=null) then x:=hpack(q,natural)
  else if (link(q)=null)and(type(q)<=dir_node)and(shift_amount(q)=0) then
    x:=q {it's already clean}
  else x:=hpack(q,natural);
@<Simplify a trivial box@>;
  clean_box:=x;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.721] skip 2nd kanji node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Simplify a trivial box@>=
q:=list_ptr(x);
if is_char_node(q) then
  begin r:=link(q);
  if r<>null then if link(r)=null then
   if not is_char_node(r) then if type(r)=kern_node then
@y
@<Simplify a trivial box@>=
q:=list_ptr(x);
if is_char_node(q) then begin
  if font_dir[font(q)]<>dir_default then q:=link(q);
  r:=link(q);
  if r<>null then if link(r)=null then
    if not is_char_node(r) then
      if type(r)=kern_node then
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.722] fetch
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  @<Complain about an undefined family and set |cur_i| null@>
else  begin if (qo(cur_c)>=font_bc[cur_f])and(qo(cur_c)<=font_ec[cur_f]) then
    cur_i:=char_info(cur_f)(cur_c)
@y
  @<Complain about an undefined family and set |cur_i| null@>
else begin
  if font_dir[cur_f]<>dir_default then
    cur_c:=qi(get_jfm_pos(math_kcode_nucleus(a), cur_f));
  if (qo(cur_c)>=font_bc[cur_f])and(qo(cur_c)<=font_ec[cur_f]) then
    cur_i:=char_info(cur_f)(cur_c)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.726] mlist_to_hlist
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
var mlist:pointer; {beginning of the given list}
@!penalties:boolean; {should penalty nodes be inserted?}
@!style:small_number; {the given style}
@y
var mlist:pointer; {beginning of the given list}
@!penalties:boolean; {should penalty nodes be inserted?}
@!style:small_number; {the given style}
@!u:pointer; {temporary register}
@z

@x
@<Make a second pass over the mlist, removing all noads and inserting the
  proper spacing and penalties@>;
end;
@y
@<Make a second pass over the mlist, removing all noads and inserting the
  proper spacing and penalties@>;
  p:=new_null_box; link(p):=link(temp_head);
  adjust_hlist(p, false); link(temp_head):=link(p);
  delete_glue_ref(space_ptr(p));
  delete_glue_ref(xspace_ptr(p));
  free_node(p,box_node_size);
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.727] free box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
free_node(z,box_node_size);
@y
delete_glue_ref(space_ptr(z));
delete_glue_ref(xspace_ptr(z));
free_node(z,box_node_size);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.734] make_over:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  overbar(clean_box(nucleus(q),cramped_style(cur_style)),@|
@y
  overbar(clean_box(nucleus(q),cramped_style(cur_style),math_kcode(q)),@|
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.735] make_under:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin x:=clean_box(nucleus(q),cur_style);
@y
begin x:=clean_box(nucleus(q),cur_style,math_kcode(q));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.736] make_under:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure make_vcenter(@!q:pointer);
var v:pointer; {the box that should be centered vertically}
@!delta:scaled; {its height plus depth}
begin v:=info(nucleus(q));
if type(v)<>vlist_node then confusion("vcenter");
@:this can't happen vcenter}{\quad vcenter@>
delta:=height(v)+depth(v);
height(v):=axis_height(cur_size)+half(delta);
depth(v):=delta-height(v);
end;
@y
procedure make_vcenter(@!q:pointer);
var v:pointer; {the box that should be centered vertically}
  @!delta:scaled; {its height plus depth}
begin
  v:=info(nucleus(q));
  if type(v)=dir_node then begin
    if type(list_ptr(v))<>vlist_node then confusion("dircenter")
  end else begin
    if type(v)<>vlist_node then confusion("vcenter")
  end;
@:this can't happen vcenter}{\quad vcenter@>
  delta:=height(v)+depth(v);
  height(v):=axis_height(cur_size)+half(delta);
  depth(v):=delta-height(v);
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.737] make_radical:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin x:=clean_box(nucleus(q),cramped_style(cur_style));
@y
begin x:=clean_box(nucleus(q),cramped_style(cur_style),math_kcode(q));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.738] make_math_accent:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  x:=clean_box(nucleus(q),cramped_style(cur_style)); w:=width(x); h:=height(x);
@y
  x:=clean_box(nucleus(q),cramped_style(cur_style),math_kcode(q));
  w:=width(x); h:=height(x);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.742] make_math_accent:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
x:=clean_box(nucleus(q),cur_style); delta:=delta+height(x)-h; h:=height(x);
@y
x:=clean_box(nucleus(q),cur_style,math_kcode(q));
delta:=delta+height(x)-h; h:=height(x);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.744] make_fraction:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
x:=clean_box(numerator(q),num_style(cur_style));
z:=clean_box(denominator(q),denom_style(cur_style));
@y
x:=clean_box(numerator(q),num_style(cur_style),math_kcode(q));
z:=clean_box(denominator(q),denom_style(cur_style),math_kcode(q));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.749] make_op:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  delta:=char_italic(cur_f)(cur_i); x:=clean_box(nucleus(q),cur_style);
@y
  delta:=char_italic(cur_f)(cur_i);
  x:=clean_box(nucleus(q),cur_style,math_kcode(q));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.750] make_op:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin x:=clean_box(supscr(q),sup_style(cur_style));
y:=clean_box(nucleus(q),cur_style);
z:=clean_box(subscr(q),sub_style(cur_style));
@y
begin x:=clean_box(supscr(q),sup_style(cur_style),math_kcode(q));
y:=clean_box(nucleus(q),cur_style,math_kcode(q));
z:=clean_box(subscr(q),sub_style(cur_style),math_kcode(q));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.751] free box node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  begin free_node(x,box_node_size); list_ptr(v):=y;
  end
@y
  begin
    delete_glue_ref(space_ptr(x));
    delete_glue_ref(xspace_ptr(x));
  free_node(x,box_node_size); list_ptr(v):=y;
  end
@z

@x
if math_type(subscr(q))=empty then free_node(z,box_node_size)
@y
if math_type(subscr(q))=empty then begin
  delete_glue_ref(space_ptr(z));
  delete_glue_ref(xspace_ptr(z));
  free_node(z,box_node_size)
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.752] make_ord
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
var a:integer; {address of lig/kern instruction}
@!p:pointer; {temporary register for list manipulation}
@y
var a:integer; {address of lig/kern instruction}
@!gp,@!gq,@!p:pointer; {temporary register for list manipulation}
@!r:halfword;
@z

@x
if (math_type(subscr(q))=empty)and(math_type(supscr(q))=empty)and@|
  (math_type(nucleus(q))=math_char) then
  begin p:=link(q);
  if p<>null then if (type(p)>=ord_noad)and(type(p)<=punct_noad) then
    if math_type(nucleus(p))=math_char then
    if fam(nucleus(p))=fam(nucleus(q)) then
      begin math_type(nucleus(q)):=math_text_char;
@y
if (math_type(subscr(q))=empty)and(math_type(supscr(q))=empty)and@|
  ((math_type(nucleus(q))=math_char)or(math_type(nucleus(q))=math_jchar)) then
  begin p:=link(q);
  if p<>null then if (type(p)>=ord_noad)and(type(p)<=punct_noad) then
    if (math_type(nucleus(p))=math_char)or
      (math_type(nucleus(p))=math_jchar) then
      if fam(nucleus(p))=fam(nucleus(q)) then
        if math_type(nucleus(q))=math_char then
        begin math_type(nucleus(q)):=math_text_char;
@z

@x
        until stop_bit(cur_i)>=stop_flag;
        end;
      end;
  end;
@y
        until stop_bit(cur_i)>=stop_flag;
      end;
    end else begin
      math_type(nucleus(q)):=math_text_jchar;
      fetch(nucleus(p)); a:=cur_c;
      fetch(nucleus(q));
      if char_tag(cur_i)=gk_tag then begin
        cur_c:=a; a:=glue_kern_start(cur_f)(cur_i);
        {cur_c:=qi(get_jfm_pos(math_kcode(p),
                     fam_fnt(fam(nucleus(p))+cur_size)));}
        repeat
          cur_i:=font_info[a].qqqq;
          if next_char(cur_i)=cur_c then
            if op_bit(cur_i)<kern_flag then begin
              gp:=font_glue[cur_f];
              r:=rem_byte(cur_i);
              if gp<>null then begin
                while((type(gp)<>r)and(link(gp)<>null)) do begin
                  gp:=link(gp);
                end;
                gq:=glue_ptr(gp);
              end else begin
                gp:=get_node(small_node_size);
                font_glue[cur_f]:=gp; gq:=null;
              end;
              if gq=null then begin
                type(gp):=r; gq:=new_spec(zero_glue);
                glue_ptr(gp):=gq;
                a:=exten_base[cur_f]+qi((qo(r))*3);
                width(gq):=font_info[a].sc;
                stretch(gq):=font_info[a+1].sc; shrink(gq):=font_info[a+2].sc;
                add_glue_ref(gq); link(gp):=get_node(small_node_size);
                gp:=link(gp); glue_ptr(gp):=null; link(gp):=null;
              end;
              p:=new_glue(gq);
              link(p):=link(q); link(q):=p; return;
            end else begin
              p:=new_kern(char_kern(cur_f)(cur_i));
              link(p):=link(q); link(q):=p; return;
            end;
          incr(a);
        until stop_bit(cur_i)>=stop_flag;
      end;
    end;
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.754] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
math_char, math_text_char:
@y
math_char, math_text_char, math_jchar, math_text_jchar:
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.755] convert math text to KANJI char_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  begin delta:=char_italic(cur_f)(cur_i); p:=new_character(cur_f,qo(cur_c));
  if (math_type(nucleus(q))=math_text_char)and(space(cur_f)<>0) then
    delta:=0; {no italic correction in mid-word of text font}
  if (math_type(subscr(q))=empty)and(delta<>0) then
    begin link(p):=new_kern(delta); delta:=0;
@y
  begin delta:=char_italic(cur_f)(cur_i); p:=new_character(cur_f,qo(cur_c));
  u:=p;
  if font_dir[cur_f]<>dir_default then begin
    link(u):=get_avail; u:=link(u); info(u):=math_kcode(q);
  end;
  if ((math_type(nucleus(q))=math_text_char)or
      (math_type(nucleus(q))=math_text_jchar))and(space(cur_f)<>0) then
    delta:=0; {no italic correction in mid-word of text font}
  if (math_type(subscr(q))=empty)and(delta<>0) then begin
    link(u):=new_kern(delta); delta:=0;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.756] free box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  shift_down:=depth(z)+sub_drop(t);
  free_node(z,box_node_size);
  end;
@y
  shift_down:=depth(z)+sub_drop(t);
  delete_glue_ref(space_ptr(z));
  delete_glue_ref(xspace_ptr(z));
  free_node(z,box_node_size);
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.757] make_scripts:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin x:=clean_box(subscr(q),sub_style(cur_style));
@y
begin x:=clean_box(subscr(q),sub_style(cur_style),math_kcode(q));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.758] make_scripts:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin x:=clean_box(supscr(q),sup_style(cur_style));
@y
begin x:=clean_box(supscr(q),sup_style(cur_style),math_kcode(q));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[36.758] make_scripts:clean_box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin y:=clean_box(subscr(q),sub_style(cur_style));
@y
begin y:=clean_box(subscr(q),sub_style(cur_style),math_kcode(q));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[37.796] call adjust_hlist
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  begin adjust_tail:=cur_tail; u:=hpack(link(head),natural); w:=width(u);
@y
  begin adjust_tail:=cur_tail; adjust_hlist(head, false);
  delete_glue_ref(cur_kanji_skip); delete_glue_ref(cur_xkanji_skip);
  cur_kanji_skip:=space_ptr(head); cur_xkanji_skip:=xspace_ptr(head);
  add_glue_ref(cur_kanji_skip); add_glue_ref(cur_xkanji_skip);
  u:=hpack(link(head),natural); w:=width(u);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[37.799] call adjust_hlist
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  begin p:=hpack(link(head),natural);
@y
  begin adjust_hlist(head, false);
  delete_glue_ref(cur_kanji_skip); delete_glue_ref(cur_xkanji_skip);
  cur_kanji_skip:=space_ptr(head); cur_xkanji_skip:=xspace_ptr(head);
  add_glue_ref(cur_kanji_skip); add_glue_ref(cur_xkanji_skip);
  p:=hpack(link(head),natural);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[37.800] call adjust_hlist
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
var @!p,@!q,@!r,@!s,@!u,@!v: pointer; {registers for the list operations}
@y
var @!p,@!q,@!r,@!s,@!u,@!v,@!z: pointer; {registers for the list operations}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[37.804] call adjust_hlist
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  p:=hpack(preamble,saved(1),saved(0)); overfull_rule:=rule_save;
@y
  z:=new_null_box; link(z):=preamble;
  adjust_hlist(z,false);
  delete_glue_ref(cur_kanji_skip); delete_glue_ref(cur_xkanji_skip);
  cur_kanji_skip:=space_ptr(z); cur_xkanji_skip:=xspace_ptr(z);
  add_glue_ref(cur_kanji_skip); add_glue_ref(cur_xkanji_skip);
  p:=hpack(preamble,saved(1),saved(0)); overfull_rule:=rule_save;
  delete_glue_ref(space_ptr(z));
  delete_glue_ref(xspace_ptr(z));
  free_node(z,box_node_size);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[37.807] unset box -> BOX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Set the unset box |q| and the unset boxes in it@>=
begin if mode=-vmode then
  begin type(q):=hlist_node; width(q):=width(p);
  end
else  begin type(q):=vlist_node; height(q):=height(p);
  end;
glue_order(q):=glue_order(p); glue_sign(q):=glue_sign(p);
glue_set(q):=glue_set(p); shift_amount(q):=o;
r:=link(list_ptr(q)); s:=link(list_ptr(p));
repeat @<Set the glue in node |r| and change it from an unset node@>;
r:=link(link(r)); s:=link(link(s));
until r=null;
end
@y
@<Set the unset box |q| and the unset boxes in it@>=
  begin
    if mode=-vmode then begin
      type(q):=hlist_node; width(q):=width(p);
    end else begin
      type(q):=vlist_node; height(q):=height(p);
    end;
    box_dir(q):=abs(direction);
    glue_order(q):=glue_order(p); glue_sign(q):=glue_sign(p);
    glue_set(q):=glue_set(p); shift_amount(q):=o;
    r:=link(list_ptr(q)); s:=link(list_ptr(p));
    repeat
      @<Set the glue in node |r| and change it from an unset node@>;
      r:=link(link(r)); s:=link(link(s));
    until r=null;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[37.809] unset box -> BOX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
s:=link(s); link(u):=new_null_box; u:=link(u); t:=t+width(s);
if mode=-vmode then width(u):=width(s)@+else
  begin type(u):=vlist_node; height(u):=width(s);
  end
@y
  s:=link(s); link(u):=new_null_box; u:=link(u); t:=t+width(s);
  if mode=-vmode then width(u):=width(s)
  @+else begin type(u):=vlist_node; height(u):=width(s); end;
  box_dir(u):=abs(direction)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[37.810] unset box -> BOX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Make the unset node |r| into an |hlist_node| of width |w|...@>=
begin height(r):=height(q); depth(r):=depth(q);
if t=width(r) then
  begin glue_sign(r):=normal; glue_order(r):=normal;
  set_glue_ratio_zero(glue_set(r));
  end
else if t>width(r) then
  begin glue_sign(r):=stretching;
  if glue_stretch(r)=0 then set_glue_ratio_zero(glue_set(r))
  else glue_set(r):=unfloat((t-width(r))/glue_stretch(r));
@^real division@>
  end
else  begin glue_order(r):=glue_sign(r); glue_sign(r):=shrinking;
  if glue_shrink(r)=0 then set_glue_ratio_zero(glue_set(r))
  else if (glue_order(r)=normal)and(width(r)-t>glue_shrink(r)) then
    set_glue_ratio_one(glue_set(r))
  else glue_set(r):=unfloat((width(r)-t)/glue_shrink(r));
  end;
width(r):=w; type(r):=hlist_node;
end
@y
@ @<Make the unset node |r| into an |hlist_node| of width |w|...@>=
  begin
    height(r):=height(q); depth(r):=depth(q);
    if t=width(r) then begin
      glue_sign(r):=normal; glue_order(r):=normal;
      set_glue_ratio_zero(glue_set(r));
    end else if t>width(r) then begin
      glue_sign(r):=stretching;
      if glue_stretch(r)=0 then set_glue_ratio_zero(glue_set(r))
      else glue_set(r):=unfloat((t-width(r))/glue_stretch(r));
@^real division@>
    end else begin
      glue_order(r):=glue_sign(r); glue_sign(r):=shrinking;
      if glue_shrink(r)=0 then set_glue_ratio_zero(glue_set(r))
      else if (glue_order(r)=normal)and(width(r)-t>glue_shrink(r)) then
        set_glue_ratio_one(glue_set(r))
      else glue_set(r):=unfloat((width(r)-t)/glue_shrink(r));
    end;
    width(r):=w; type(r):=hlist_node;
    box_dir(r):=abs(direction);
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[37.811] unset box -> BOX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Make the unset node |r| into a |vlist_node| of height |w|...@>=
begin width(r):=width(q);
if t=height(r) then
  begin glue_sign(r):=normal; glue_order(r):=normal;
  set_glue_ratio_zero(glue_set(r));
  end
else if t>height(r) then
  begin glue_sign(r):=stretching;
  if glue_stretch(r)=0 then set_glue_ratio_zero(glue_set(r))
  else glue_set(r):=unfloat((t-height(r))/glue_stretch(r));
@^real division@>
  end
else  begin glue_order(r):=glue_sign(r); glue_sign(r):=shrinking;
  if glue_shrink(r)=0 then set_glue_ratio_zero(glue_set(r))
  else if (glue_order(r)=normal)and(height(r)-t>glue_shrink(r)) then
    set_glue_ratio_one(glue_set(r))
  else glue_set(r):=unfloat((height(r)-t)/glue_shrink(r));
  end;
height(r):=w; type(r):=vlist_node;
end
@y
@ @<Make the unset node |r| into a |vlist_node| of height |w|...@>=
  begin
    width(r):=width(q);
    if t=height(r) then begin
      glue_sign(r):=normal; glue_order(r):=normal;
      set_glue_ratio_zero(glue_set(r));
    end else if t>height(r) then begin
      glue_sign(r):=stretching;
      if glue_stretch(r)=0 then set_glue_ratio_zero(glue_set(r))
      else glue_set(r):=unfloat((t-height(r))/glue_stretch(r));
@^real division@>
    end else begin
      glue_order(r):=glue_sign(r); glue_sign(r):=shrinking;
      if glue_shrink(r)=0 then set_glue_ratio_zero(glue_set(r))
      else if (glue_order(r)=normal)and(height(r)-t>glue_shrink(r)) then
        set_glue_ratio_one(glue_set(r))
      else glue_set(r):=unfloat((height(r)-t)/glue_shrink(r));
    end;
    height(r):=w; type(r):=vlist_node;
    box_dir(r):=abs(direction);
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[38.816] init chain
%p[38.816] delete disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
This code assumes that a |glue_node| and a |penalty_node| occupy the
same number of words in |mem|.
@^data structure assumptions@>

@<Get ready...@>=
link(temp_head):=link(head);
if is_char_node(tail) then tail_append(new_penalty(inf_penalty))
else if type(tail)<>glue_node then tail_append(new_penalty(inf_penalty))
@y
This code assumes that a |glue_node| and a |penalty_node| occupy the
same number of words in |mem|.
@^data structure assumptions@>

@<Get ready...@>=
  first_use:=true; chain:=false;
  delete_glue_ref(cur_kanji_skip); delete_glue_ref(cur_xkanji_skip);
  cur_kanji_skip:=space_ptr(head); cur_xkanji_skip:=xspace_ptr(head);
  add_glue_ref(cur_kanji_skip); add_glue_ref(cur_xkanji_skip);
  link(temp_head):=link(head);
  if (not is_char_node(tail)) and (type(tail)=disp_node) then begin
    free_node(tail,small_node_size); tail:=prev_node; link(tail):=null
  end;
  if is_char_node(tail) then tail_append(new_penalty(inf_penalty))
  else if type(tail)<>glue_node then tail_append(new_penalty(inf_penalty))
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[38.828] chain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
feasible solution, |threshold| is set to |tolerance|, |second_pass| is set
|true|, and an attempt is made to hyphenate as many words as possible.

@<Glob...@>=
@!cur_p:pointer; {the current breakpoint under consideration}
@!second_pass:boolean; {is this our second attempt to break this paragraph?}
@!threshold:integer; {maximum badness on feasible lines}
@y
feasible solution, |threshold| is set to |tolerance|, |second_pass| is set
|true|, and an attempt is made to hyphenate as many words as possible.

@<Glob...@>=
@!cur_p:pointer; {the current breakpoint under consideration}
@!second_pass:boolean; {is this our second attempt to break this paragraph?}
@!threshold:integer; {maximum badness on feasible lines}
@!chain:boolean;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[38.830] local vavariable in tray_break
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!save_link:pointer; {temporarily holds value of |link(cur_p)|}
@y
@!save_link:pointer; {temporarily holds value of |link(cur_p)|}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[38.837] add kanji_skip width
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% chain ‚ª^‚Ìê‡AŒã‚ë‚É cur_kanji_skip ‚ª‘}“ü‚³‚ê‚é‚Ì‚ÅA‚±‚±‚Å
% break_width ‚©‚çˆø‚¢‚Ä‚¨‚©‚È‚¯‚ê‚Î‚È‚ç‚È‚¢B
@x
@<Compute the values of |break...@>=
begin no_break_yet:=false; do_all_six(set_break_width_to_background);
s:=cur_p;
if break_type>unhyphenated then if cur_p<>null then
  @<Compute the discretionary |break_width| values@>;
while s<>null do
  begin if is_char_node(s) then goto done;
  case type(s) of
  glue_node:@<Subtract glue from |break_width|@>;
@y
@<Compute the values of |break...@>=
begin no_break_yet:=false; do_all_six(set_break_width_to_background);
s:=cur_p;
if break_type>unhyphenated then if cur_p<>null then
  @<Compute the discretionary |break_width| values@>;
while s<>null do
  begin if is_char_node(s) then
    begin if chain then
      begin break_width[1]:=break_width[1]-width(cur_kanji_skip);
      break_width[2+stretch_order(cur_kanji_skip)]:=
          break_width[2+stretch_order(cur_kanji_skip)]-
            stretch(cur_kanji_skip);
      break_width[6]:=break_width[6]-shrink(cur_kanji_skip);
    end;
    goto done end;
  case type(s) of
  glue_node:@<Subtract glue from |break_width|@>;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[38.841]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Subtract the width of node |v|...@>=
if is_char_node(v) then
  begin f:=font(v);
  break_width[1]:=break_width[1]-char_width(f)(char_info(f)(character(v)));
  end
else  case type(v) of
  ligature_node: begin f:=font(lig_char(v));@/
    break_width[1]:=@|break_width[1]-
      char_width(f)(char_info(f)(character(lig_char(v))));
    end;
  hlist_node,vlist_node,rule_node,kern_node:
    break_width[1]:=break_width[1]-width(v);
  othercases confusion("disc1")
@:this can't happen disc1}{\quad disc1@>
  endcases
@y
@<Subtract the width of node |v|...@>=
  if is_char_node(v) then begin
    f:=font(v);
    break_width[1]:=break_width[1]-char_width(f)(char_info(f)(character(v)));
    if font_dir[f]<>dir_default then v:=link(v);
  end else
    case type(v) of
      ligature_node:
        begin
          f:=font(lig_char(v));@/
          break_width[1]:=@|break_width[1]-
            char_width(f)(char_info(f)(character(lig_char(v))));
        end;
      hlist_node,vlist_node,dir_node,rule_node,kern_node:
        break_width[1]:=break_width[1]-width(v);
      disp_node: do_nothing;
      othercases confusion("disc1")
@:this can't happen disc1}{\quad disc1@>
    endcases
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[38.842] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Add the width of node |s| to |b...@>=
if is_char_node(s) then
  begin f:=font(s);
  break_width[1]:=@|break_width[1]+char_width(f)(char_info(f)(character(s)));
  end
else  case type(s) of
  ligature_node: begin f:=font(lig_char(s));
    break_width[1]:=break_width[1]+
      char_width(f)(char_info(f)(character(lig_char(s))));
    end;
  hlist_node,vlist_node,rule_node:break_width[1]:=break_width[1]+width(s);
  kern_node: if (t=0)and(subtype(s)<>acc_kern) then t:=-1 {discardable}
    else break_width[1]:=break_width[1]+width(s);
  othercases confusion("disc2")
@:this can't happen disc2}{\quad disc2@>
  endcases;
incr(t)
@y
@ @<Add the width of node |s| to |b...@>=
  if is_char_node(s) then begin
    f:=font(s);
    break_width[1]:=@|break_width[1]+char_width(f)(char_info(f)(character(s)));
    if font_dir[f]<>dir_default then s:=link(s);
  end else
    case type(s) of
      ligature_node:
        begin
          f:=font(lig_char(s));
          break_width[1]:=break_width[1]+
            char_width(f)(char_info(f)(character(lig_char(s))));
        end;
      hlist_node,vlist_node,dir_node,rule_node:
        break_width[1]:=break_width[1]+width(s);
      kern_node:
        if (t=0)and(subtype(s)<>acc_kern) then t:=-1 {discardable}
        else break_width[1]:=break_width[1]+width(s);
      disp_node: do_nothing;
      othercases confusion("disc2")
@:this can't happen disc2}{\quad disc2@>
    endcases;
    incr(t)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[39.856] print symbolic feasibe node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if cur_p=null then print_esc("par")
else if type(cur_p)<>glue_node then
  begin if type(cur_p)=penalty_node then print_esc("penalty")
  else if type(cur_p)=disc_node then print_esc("discretionary")
@y
if cur_p=null then print_esc("par")
else if (type(cur_p)<>glue_node) and not is_char_node(cur_p) then
  begin if type(cur_p)=penalty_node then print_esc("penalty")
  else if type(cur_p)=disc_node then print_esc("discretionary")
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [38.859] Fix a C casting/expression evaluation problem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if abs(fit_class-fitness(r))>1 then d:=d+adj_demerits
@y
if abs(toint(fit_class)-toint(fitness(r)))>1 then d:=d+adj_demerits
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[39.862] local k
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!auto_breaking:boolean; {is node |cur_p| outside a formula?}
@!prev_p:pointer; {helps to determine when glue nodes are breakpoints}
@!q,@!r,@!s:pointer; {miscellaneous nodes of temporary interest}
@!f:internal_font_number; {used when calculating character widths}
@y
@!auto_breaking:boolean; {is node |cur_p| outside a formula?}
@!prev_p:pointer; {helps to determine when glue nodes are breakpoints}
@!q,@!r,@!s:pointer; {miscellaneous nodes of temporary interest}
@!f,@!post_f:internal_font_number; {used when calculating character widths}
@!post_p:pointer;
@!cc:ASCII_code;
@!first_use:boolean;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[39.866] dir_node, disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Call |try_break| if |cur_p| is a legal breakpoint...@>=
begin if is_char_node(cur_p) then
  @<Advance \(c)|cur_p| to the node following the present
    string of characters@>;
case type(cur_p) of
hlist_node,vlist_node,rule_node: act_width:=act_width+width(cur_p);
@y
@<Call |try_break| if |cur_p| is a legal breakpoint...@>=
  begin
    if is_char_node(cur_p) then
      @<Advance \(c)|cur_p| to the node following the present
        string of characters@>;
    case type(cur_p) of
      hlist_node,vlist_node,dir_node,rule_node:
        act_width:=act_width+width(cur_p);
@z

@x
mark_node,ins_node,adjust_node: do_nothing;
@y
disp_node,mark_node,ins_node,adjust_node: do_nothing;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[39.867] add kanji char width
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ‚±‚±‚ÅA˜A‘±‚·‚éŠ¿ŽšƒR[ƒhŠÔ‚É cur_kanji_skip ‚ð‘}“ü‚·‚éB
% penalty_node ‚â box_node ‚É‚ÍAadjust_hlist ƒ‹[ƒ`ƒ“‚É‚æ‚Á‚ÄŠù‚ÉŽÀÛ‚Ì
% glue_node ‚ª‘}“ü‚³‚ê‚Ä‚¢‚é‚à‚Ì‚Æ‰¼’è‚µ‚Ä‚¢‚éB
% chain ‚ÍAtry_break ‚Å cur_kanji_skip ‚ÌƒAƒWƒƒƒXƒg‚Ì‚½‚ß‚ÉŽg‚í‚ê‚éB
@x
@<Advance \(c)|cur_p| to the node following the present string...@>=
begin prev_p:=cur_p;
repeat f:=font(cur_p);
act_width:=act_width+char_width(f)(char_info(f)(character(cur_p)));
cur_p:=link(cur_p);
until not is_char_node(cur_p);
end
@y
@<Advance \(c)|cur_p| to the node following the present string...@>=
  begin
    chain:=false;
    if is_char_node(cur_p) then
      if font_dir[font(cur_p)]<>dir_default then begin
        case type(prev_p) of
        hlist_node,vlist_node,dir_node,rule_node,
        ligature_node,disc_node,math_node:
          begin
            cur_p:=prev_p; try_break(0, unhyphenated); cur_p:=link(cur_p);
          end;
        othercases do_nothing;
        endcases;
      end;
    prev_p:=cur_p; post_p:=cur_p; post_f:=font(post_p);
    repeat
      f:=post_f; cc:=character(cur_p);
      act_width:=act_width+char_width(f)(char_info(f)(cc));
      post_p:=link(cur_p);
      if font_dir[f]<>dir_default then begin
        prev_p:=cur_p; cur_p:=post_p; post_p:=link(post_p);
        if is_char_node(post_p) then begin
          post_f:=font(post_p);
          if font_dir[post_f]<>dir_default then chain:=true else chain:=false;
          try_break(0, unhyphenated);
        end else begin
          chain:=false;
          case type(post_p) of
            hlist_node, vlist_node, dir_node, rule_node, ligature_node,
              disc_node, math_node: try_break(0, unhyphenated);
            othercases do_nothing;
          endcases;
        end;
        if chain then begin
          if first_use then begin
            check_shrinkage(cur_kanji_skip);
            first_use:=false;
          end;
          act_width:=act_width+width(cur_kanji_skip);@|
          active_width[2+stretch_order(cur_kanji_skip)]:=@|
            active_width[2+stretch_order(cur_kanji_skip)]+
              stretch(cur_kanji_skip);@/
          active_width[6]:=active_width[6]+shrink(cur_kanji_skip);
        end;
        prev_p:=cur_p;
      end else if is_char_node(post_p) then begin
        post_f:=font(post_p); chain:=false;
        if font_dir[post_f]<>dir_default then try_break(0, unhyphenated);
      end;
      cur_p:=post_p;
    until not is_char_node(cur_p);
    chain:=false;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[39.871] add kanji char width
%p[39.871] add dir_node width, disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Add the width of node |s| to |disc_width|@>=
if is_char_node(s) then
  begin f:=font(s);
  disc_width:=disc_width+char_width(f)(char_info(f)(character(s)));
  end
else  case type(s) of
  ligature_node: begin f:=font(lig_char(s));
    disc_width:=disc_width+
      char_width(f)(char_info(f)(character(lig_char(s))));
    end;
  hlist_node,vlist_node,rule_node,kern_node:
    disc_width:=disc_width+width(s);
  othercases confusion("disc3")
@:this can't happen disc3}{\quad disc3@>
  endcases
@y
@ @<Add the width of node |s| to |disc_width|@>=
  if is_char_node(s) then begin
    f:=font(s);
    disc_width:=disc_width+char_width(f)(char_info(f)(character(s)));
    if font_dir[f]<>dir_default then s:=link(s)
  end else
    case type(s) of
    ligature_node:
      begin
        f:=font(lig_char(s));
        disc_width:=
          disc_width+char_width(f)(char_info(f)(character(lig_char(s))));
      end;
    hlist_node,vlist_node,dir_node,rule_node,kern_node:
      disc_width:=disc_width+width(s);
    disp_node: do_nothing;
    othercases confusion("disc3")
@:this can't happen disc3}{\quad disc3@>
  endcases
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[39.877] last_disp
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
cur_line:=prev_graf+1;
repeat @<Justify the line ending at breakpoint |cur_p|, and append it to the
  current vertical list, together with associated penalties and other
  insertions@>;
@y
cur_line:=prev_graf+1; last_disp:=0;
repeat @<Justify the line ending at breakpoint |cur_p|, and append it to the
  current vertical list, together with associated penalties and other
  insertions@>;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[39.881] |q| may be a |char_node|
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Modify the end of the line...@>=
q:=cur_break(cur_p); disc_break:=false;
if q<>null then {|q| cannot be a |char_node|}
  if type(q)=glue_node then
    begin delete_glue_ref(glue_ptr(q));
    glue_ptr(q):=right_skip;
    subtype(q):=right_skip_code+1; add_glue_ref(right_skip);
    goto done;
    end
  else  begin if type(q)=disc_node then
      @<Change discretionary to compulsory and set
        |disc_break:=true|@>
    else if (type(q)=math_node)or(type(q)=kern_node) then width(q):=0;
    end
else  begin q:=temp_head;
  while link(q)<>null do q:=link(q);
  end;
@<Put the \(r)\.{\\rightskip} glue after node |q|@>;
done:
@y
@<Modify the end of the line...@>=
  q:=cur_break(cur_p); disc_break:=false;
  if q<>null then begin  {|q| may be a |char_node|}
    if not is_char_node(q) then 
      if type(q)=glue_node then begin
        delete_glue_ref(glue_ptr(q));
        glue_ptr(q):=right_skip;
        subtype(q):=right_skip_code+1; add_glue_ref(right_skip);
        goto done;
      end else begin
        if type(q)=disc_node then
          @<Change discretionary to compulsory and set
            |disc_break:=true|@>
        else if (type(q)=math_node)or(type(q)=kern_node) then
          width(q):=0;
      end
  end else begin
    q:=temp_head;
    while link(q)<>null do q:=link(q);
  end;
  @<Put the \(r)\.{\\rightskip} glue after node |q|@>;
done:
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[39.887] disp_node at begin-of-line
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Put the \(l)\.{\\leftskip} glue at the left...@>=
r:=link(q); link(q):=null; q:=link(temp_head); link(temp_head):=r;
if left_skip<>zero_glue then
  begin r:=new_param_glue(left_skip_code);
  link(r):=q; q:=r;
  end
@y
@<Put the \(l)\.{\\leftskip} glue at the left...@>=
  r:=link(q); link(q):=null; q:=link(temp_head); link(temp_head):=r;
  if last_disp<>0 then begin
    r:=get_node(small_node_size);
    type(r):=disp_node; disp_dimen(r):=last_disp;
    link(r):=q; q:=r;
  end;
  if left_skip<>zero_glue then begin
    r:=new_param_glue(left_skip_code);
    link(r):=q; q:=r;
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[40.896] hyphenation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Skip to node |ha|, or |goto done1|...@>=
loop@+  begin if is_char_node(s) then
    begin c:=qo(character(s)); hf:=font(s);
    end
  else if type(s)=ligature_node then
    begin q:=lig_ptr(s); c:=qo(character(q)); hf:=font(q);
    end
  else if (type(s)=kern_node)and(subtype(s)=normal) then c:=128
  else if type(s)=whatsit_node then c:=128
  else goto done1;
  if c<128 then if lc_code(c)<>0 then
    if (lc_code(c)=c)or(uc_hyph>0) then goto done2
    else goto done1;
  s:=link(s);
  end;
done2: hyf_char:=hyphen_char[hf];
if hyf_char<0 then goto done1;
if hyf_char>255 then goto done1;
ha:=s
@y
@<Skip to node |ha|, or |goto done1|...@>=
  loop@+begin
    if is_char_node(s) then begin
      hf:=font(s);
      if font_dir[hf]<>dir_default then goto done1
      else c:=qo(character(s))
    end else if type(s)=ligature_node then begin
      q:=lig_ptr(s); c:=qo(character(q)); hf:=font(q);
    end
    else if (type(s)=kern_node)and(subtype(s)=normal) then c:=128
    else if type(s)=whatsit_node then c:=128
    else goto done1;
    if c<128 then if lc_code(c)<>0 then
      if (lc_code(c)=c)or(uc_hyph>0) then goto done2
      else goto done1;
    s:=link(s);
  end;
done2:
  hyf_char:=hyphen_char[hf];
  if hyf_char<0 then goto done1;
  if hyf_char>255 then goto done1;
  ha:=s
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[40.899] disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
    whatsit_node,glue_node,penalty_node,ins_node,adjust_node,mark_node:
      goto done4;
@y
    whatsit_node,glue_node,penalty_node,ins_node,adjust_node,
    disp_node,mark_node:
      goto done4;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [43.947] Fix a C casting/expression evaluation problem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin h:=abs(trie_c[p]+1009*trie_o[p]+@|
    2718*trie_l[p]+3142*trie_r[p]) mod trie_size;
@y
begin h:=abs(toint(trie_c[p])+1009*toint(trie_o[p])+@|
    2718*toint(trie_l[p])+3142*toint(trie_r[p])) mod trie_size;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[44.968] dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function prune_page_top(@!p:pointer):pointer; {adjust top after page break}
var prev_p:pointer; {lags one step behind |p|}
@!q:pointer; {temporary variable for list manipulation}
begin prev_p:=temp_head; link(temp_head):=p;
while p<>null do
  case type(p) of
  hlist_node,vlist_node,rule_node:@<Insert glue for |split_top_skip|
    and set~|p:=null|@>;
  whatsit_node,mark_node,ins_node: begin prev_p:=p; p:=link(prev_p);
    end;
@y
@p
function prune_page_top(@!p:pointer):pointer; {adjust top after page break}
var prev_p:pointer; {lags one step behind |p|}
  @!q:pointer; {temporary variable for list manipulation}
begin
  prev_p:=temp_head; link(temp_head):=p;
  while p<>null do
    case type(p) of
    hlist_node,vlist_node,dir_node,rule_node:
      @<Insert glue for |split_top_skip| and set~|p:=null|@>;
    whatsit_node,mark_node,ins_node:
      begin prev_p:=p; p:=link(prev_p); end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[44.973] dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Use node |p| to update the current height and depth measurements...@>=
case type(p) of
hlist_node,vlist_node,rule_node: begin@t@>@;@/
  cur_height:=cur_height+prev_dp+height(p); prev_dp:=depth(p);
  goto not_found;
  end;
@y
@ @<Use node |p| to update the current height and depth measurements...@>=
  case type(p) of
    hlist_node,vlist_node,dir_node,rule_node:
      begin@t@>@;@/
        cur_height:=cur_height+prev_dp+height(p); prev_dp:=depth(p);
        goto not_found;
      end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[44.977] free box node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p function vsplit(@!n:eight_bits; @!h:scaled):pointer;
  {extracts a page of height |h| from box |n|}
label exit,done;
var v:pointer; {the box to be split}
p:pointer; {runs through the vlist}
q:pointer; {points to where the break occurs}
begin v:=box(n);
if split_first_mark<>null then
  begin delete_token_ref(split_first_mark); split_first_mark:=null;
  delete_token_ref(split_bot_mark); split_bot_mark:=null;
  end;
@<Dispense with trivial cases of void or bad boxes@>;
q:=vert_break(list_ptr(v),h,split_max_depth);
@<Look at all the marks in nodes before the break, and set the final
  link to |null| at the break@>;
q:=prune_page_top(q); p:=list_ptr(v); free_node(v,box_node_size);
if q=null then box(n):=null {the |eq_level| of the box stays the same}
else box(n):=vpack(q,natural);
vsplit:=vpackage(p,h,exactly,split_max_depth);
exit: end;
@y
@p
function vsplit(@!n:eight_bits; @!h:scaled):pointer;
  {extracts a page of height |h| from box |n|}
label exit,done;
var v:pointer; {the box to be split}
  w:pointer; {dir_node}
  p:pointer; {runs through the vlist}
  q:pointer; {points to where the break occurs}
begin
  v:=box(n);
  if split_first_mark<>null then begin
    delete_token_ref(split_first_mark); split_first_mark:=null;
    delete_token_ref(split_bot_mark); split_bot_mark:=null;
  end;
  @<Dispense with trivial cases of void or bad boxes@>;
  q:=vert_break(list_ptr(v),h,split_max_depth);
  @<Look at all the marks in nodes before the break, and set the final
    link to |null| at the break@>;
  q:=prune_page_top(q); p:=list_ptr(v);
  if q=null then
    box(n):=null {the |eq_level| of the box stays the same}
  else begin
    box(n):=vpack(q,natural);
    box_dir(box(n)):=box_dir(v);
  end;
  q:=vpackage(p,h,exactly,split_max_depth);
  box_dir(q):=box_dir(v);
  delete_glue_ref(space_ptr(v));
  delete_glue_ref(xspace_ptr(v));
  free_node(v,box_node_size);
  vsplit:=q;
exit:
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[44.978] bad box for vsplit
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Dispense with trivial cases of void or bad boxes@>=
if v=null then
  begin vsplit:=null; return;
  end;
if type(v)<>vlist_node then
  begin print_err(""); print_esc("vsplit"); print(" needs a ");
  print_esc("vbox");
@:vsplit_}{\.{\\vsplit needs a \\vbox}@>
  help2("The box you are trying to split is an \hbox.")@/
  ("I can't split such a box, so I'll leave it alone.");
  error; vsplit:=null; return;
  end
@y
@ @<Dispense with trivial cases of void or bad boxes@>=
  if v=null then begin
    vsplit:=null; return;
  end;
  if type(v)=dir_node then begin
    w:=v; v:=list_ptr(v);
    delete_glue_ref(space_ptr(w));
    delete_glue_ref(xspace_ptr(w));
    free_node(w,box_node_size);
  end;
  if type(v)<>vlist_node then begin
    print_err(""); print_esc("vsplit"); print(" needs a ");
    print_esc("vbox");
@:vsplit_}{\.{\\vsplit needs a \\vbox}@>
    help2("The box you are trying to split is an \hbox.")@/
    ("I can't split such a box, so I'll leave it alone.");
    error; vsplit:=null; return;
  end;
  flush_node_list(link(v));
  link(v):=null
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[45.993] ensure_vbox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p procedure ensure_vbox(@!n:eight_bits);
var p:pointer; {the box register contents}
begin p:=box(n);
if p<>null then if type(p)=hlist_node then
  begin print_err("Insertions can only be added to a vbox");
@.Insertions can only...@>
  help3("Tut tut: You're trying to \insert into a")@/
    ("\box register that now contains an \hbox.")@/
    ("Proceed, and I'll discard its present contents.");
  box_error(n);
  end;
end;
@y
@p
procedure ensure_vbox(@!n:eight_bits);
var p:pointer; {the box register contents}
begin
  p:=box(n);
  if p<>null then
    if (type(p)=dir_node) then begin
      p:=list_ptr(p);
      delete_glue_ref(space_ptr(box(n)));
      delete_glue_ref(xspace_ptr(box(n)));
      free_node(box(n),box_node_size);
      box(n):=p
    end;
  if p<>null then begin
    if type(p)<>vlist_node then begin
      print_err("Insertions can only be added to a vbox");
@.Insertions can only...@>
      help3("Tut tut: You're trying to \insert into a")@/
        ("\box register that now contains an \hbox.")@/
        ("Proceed, and I'll discard its present contents.");
      box_error(n)
    end
  end
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[45.1000] dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<If the current page is empty...@>=
case type(p) of
hlist_node,vlist_node,rule_node: if page_contents<box_there then
    @<Initialize the current page, insert the \.{\\topskip} glue
      ahead of |p|, and |goto continue|@>
  else @<Prepare to move a box or rule node to the current page,
    then |goto contribute|@>;
@y
@<If the current page is empty...@>=
  case type(p) of
    hlist_node,vlist_node,dir_node,rule_node:
      if page_contents<box_there then
        @<Initialize the current page, insert the \.{\\topskip} glue
          ahead of |p|, and |goto continue|@>
      else
        @<Prepare to move a box or rule node to the current page,
          then |goto contribute|@>;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[45.1009] ins_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Create a page insertion node...@>=
begin q:=get_node(page_ins_node_size); link(q):=link(r); link(r):=q; r:=q;
subtype(r):=qi(n); type(r):=inserting; ensure_vbox(n);
if box(n)=null then height(r):=0
else height(r):=height(box(n))+depth(box(n));
@y
@<Create a page insertion node...@>=
begin
  q:=get_node(page_ins_node_size); link(q):=link(r); link(r):=q; r:=q;
  subtype(r):=qi(n); type(r):=inserting; ensure_vbox(n);
  if box(n)=null then height(r):=0
  else begin
    if ins_dir(p)<>box_dir(box(n)) then begin
      print_err("Insertions can only be added to a same direction vbox");
@.Insertions can only...@>
      help3("Tut tut: You're trying to \insert into a")@/
        ("\box register that now have a different direction.")@/
        ("Proceed, and I'll discard its present contents.");
      box_error(n)
    end;
    height(r):=height(box(n))+depth(box(n));
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[45.1017] page dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ When the following code is executed, the current page runs from node
|link(page_head)| to node |prev_p|, and the nodes from |p| to |page_tail|
are to be placed back at the front of the contribution list. Furthermore
@y
@ @<Glob...@>=
  @!page_dir:eight_bits;

@ @<Set init...@>=
  page_dir:=dir_yoko;

@ When the following code is executed, the current page runs from node
|link(page_head)| to node |prev_p|, and the nodes from |p| to |page_tail|
are to be placed back at the front of the contribution list. Furthermore
@z

@x
@<Break the current page at node |p|, put it...@>=
if p<>null then
  begin if link(contrib_head)=null then
    if nest_ptr=0 then tail:=page_tail
    else contrib_tail:=page_tail;
  link(page_tail):=link(contrib_head);
  link(contrib_head):=p;
  link(prev_p):=null;
  end;
save_vbadness:=vbadness; vbadness:=inf_bad;
save_vfuzz:=vfuzz; vfuzz:=max_dimen; {inhibit error messages}
box(255):=vpackage(link(page_head),best_size,exactly,page_max_depth);
vbadness:=save_vbadness; vfuzz:=save_vfuzz;
if last_glue<>max_halfword then delete_glue_ref(last_glue);
@<Start a new current page@>; {this sets |last_glue:=max_halfword|}
if q<>hold_head then
  begin link(page_head):=link(hold_head); page_tail:=q;
  end
@y
@<Break the current page at node |p|, put it...@>=
  if p<>null then begin
    if link(contrib_head)=null then
      if nest_ptr=0 then tail:=page_tail
      else contrib_tail:=page_tail;
    link(page_tail):=link(contrib_head);
    link(contrib_head):=p;
    link(prev_p):=null;
  end;
  save_vbadness:=vbadness; vbadness:=inf_bad;
  save_vfuzz:=vfuzz; vfuzz:=max_dimen; {inhibit error messages}
  box(255):=vpackage(link(page_head),best_size,exactly,page_max_depth);
  box_dir(box(255)):=page_dir;
  vbadness:=save_vbadness; vfuzz:=save_vfuzz;
  if last_glue<>max_halfword then delete_glue_ref(last_glue);
  @<Start a new current page@>; {this sets |last_glue:=max_halfword|}
  if q<>hold_head then begin
    link(page_head):=link(hold_head); page_tail:=q;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[45.1020] check ins_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Either insert the material specified by node |p| into...@>=
begin r:=link(page_ins_head);
while subtype(r)<>subtype(p) do r:=link(r);
if best_ins_ptr(r)=null then wait:=true
else  begin wait:=false; s:=ins_ptr(p);
  link(last_ins_ptr(r)):=s; s:=last_ins_ptr(r);
  if best_ins_ptr(r)=p then
    @<Wrap up the box specified by node |r|, splitting node |p| if
    called for; set |wait:=true| if node |p| holds a remainder after
    splitting@>
  else  begin while link(s)<>null do s:=link(s);
    last_ins_ptr(r):=s;
    end;
  end;
@<Either append the insertion node |p| after node |q|, and remove it
  from the current page, or delete |node(p)|@>;
end
@y
@<Either insert the material specified by node |p| into...@>=
begin
  r:=link(page_ins_head);
  while subtype(r)<>subtype(p) do r:=link(r);
  if best_ins_ptr(r)=null then wait:=true
  else begin
    wait:=false; s:=ins_ptr(p); n:=qo(subtype(p));
    case box_dir(box(n)) of
    any_dir:
      if ins_dir(p)<>box_dir(box(n)) then begin
        print_err("Insertions can only be added to a same direction vbox");
@.Insertions can only...@>
        help3("Tut tut: You're trying to \insert into a")@/
          ("\box register that now have a different direction.")@/
          ("Proceed, and I'll discard its present contents.");
        box_error(n);
        box(n):=new_null_box; last_ins_ptr(r):=box(n)+list_offset;
      end;
    othercases
      box_dir(box(n)):=ins_dir(p);
    endcases;
    link(last_ins_ptr(r)):=s; s:=last_ins_ptr(r);
    if best_ins_ptr(r)=p then
      @<Wrap up the box specified by node |r|, splitting node |p| if
        called for; set |wait:=true| if node |p| holds a remainder after
        splitting@>
    else begin
      while link(s)<>null do s:=link(s);
      last_ins_ptr(r):=s;
    end;
  end;
  @<Either append the insertion node |p| after node |q|, and remove it
    from the current page, or delete |node(p)|@>;
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[45.1021] free box node
%p[45.1021] ins_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Wrap up the box specified by node |r|, splitting node |p| if...@>=
begin if type(r)=split_up then
  if (broken_ins(r)=p)and(broken_ptr(r)<>null) then
    begin while link(s)<>broken_ptr(r) do s:=link(s);
    split_top_skip:=split_top_ptr(p);
    ins_ptr(p):=prune_page_top(broken_ptr(r));
    if ins_ptr(p)<>null then
      begin temp_ptr:=vpack(ins_ptr(p),natural);
      height(p):=height(temp_ptr)+depth(temp_ptr);
      free_node(temp_ptr,box_node_size); wait:=true;
      end;
    link(s):=null;
    end;
best_ins_ptr(r):=null;
n:=qo(subtype(r));
temp_ptr:=list_ptr(box(n));
free_node(box(n),box_node_size);
box(n):=vpack(temp_ptr,natural);
end
@y
@ @<Wrap up the box specified by node |r|, splitting node |p| if...@>=
  begin
    if type(r)=split_up then
      if (broken_ins(r)=p)and(broken_ptr(r)<>null) then begin
        while link(s)<>broken_ptr(r) do s:=link(s);
        split_top_skip:=split_top_ptr(p);
        ins_ptr(p):=prune_page_top(broken_ptr(r));
        if ins_ptr(p)<>null then begin
          temp_ptr:=vpack(ins_ptr(p),natural);
          height(p):=height(temp_ptr)+depth(temp_ptr);
          delete_glue_ref(space_ptr(temp_ptr));
          delete_glue_ref(xspace_ptr(temp_ptr));
          free_node(temp_ptr,box_node_size); wait:=true;
        end;
        link(s):=null;
      end;
    best_ins_ptr(r):=null;
    n:=qo(subtype(r));
    temp_ptr:=list_ptr(box(n));
    delete_glue_ref(space_ptr(box(n)));
    delete_glue_ref(xspace_ptr(box(n)));
    flush_node_list(link(box(n)));
    free_node(box(n),box_node_size);
    box(n):=vpack(temp_ptr,natural); box_dir(box(n)):=ins_dir(p);
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[46.1030] main_control
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ We shall concentrate first on the inner loop of |main_control|, deferring
consideration of the other cases until later.

@d big_switch=60 {go here to branch on the next token of input}
@d main_loop=70 {go here to typeset |cur_chr| in the current font}
@d main_loop_1=71 {like |main_loop|, but |(f,c)| = current font and char}
@d main_loop_2=72 {like |main_loop_1|, but |c| is known to be in range}
@d main_loop_3=73 {like |main_loop_2|, but several variables are set up}
@d append_normal_space=74 {go here to append a normal space between words}

@p @t\4@>@<Declare action procedures for use by |main_control|@>@;
@t\4@>@<Declare the procedure called |handle_right_brace|@>@;
procedure main_control; {governs \TeX's activities}
label big_switch,reswitch,main_loop,main_loop_1,main_loop_2,main_loop_3,
  append_normal_space,exit;
var t:integer; {general-purpose temporary variable}
@<Local variables for the inner loop of |main_control|@>@;
begin if every_job<>null then begin_token_list(every_job,every_job_text);
big_switch: get_x_token;@/
reswitch: @<Give diagnostic information, if requested@>;
case abs(mode)+cur_cmd of
hmode+letter,hmode+other_char,hmode+char_given: goto main_loop;
hmode+char_num: begin scan_char_num; cur_chr:=cur_val; goto main_loop;
  end;
hmode+spacer: if space_factor=1000 then goto append_normal_space
  else app_space;
hmode+ex_space,mmode+ex_space: goto append_normal_space;
@t\4@>@<Cases of |main_control| that are not part of the inner loop@>@;
end; {of the big |case| statement}
goto big_switch;
main_loop:@<Append character |cur_chr| and the following characters (if~any)
  to the current hlist in the current font; |goto reswitch| when
  a non-character has been fetched@>;
append_normal_space:@<Append a normal inter-word space to the current list,
  then |goto big_switch|@>;
exit:end;
@y
@ We shall concentrate first on the inner loop of |main_control|, deferring
consideration of the other cases until later.

@d big_switch=60 {go here to branch on the next token of input}
@d main_loop=70 {go here to typeset |cur_chr| in the current font}
@d main_loop_1=71 {like |main_loop|, but |(f,c)| = current font and char}
@d main_loop_2=72 {like |main_loop_1|, but |c| is known to be in range}
@d main_loop_3=73 {like |main_loop_2|, but several variables are set up}
@d append_normal_space=74 {go here to append a normal space between words}
@d main_loop_j=75 {like |main_loop|, but |cur_chr| in the KANJI code}
@d main_loop_j2=77 {like |main_loop_j|}
@d main_loop_j3=78 {like |main_loop_j|, but |(f,c)| = current font and char}
@d insert_glue=79
@d skip_loop=80
@d skip_loop_1=81
@d again_1=82
@d again_2=83

@p
@t\4@>@<Declare action procedures for use by |main_control|@>@;
@t\4@>@<Declare the procedure called |handle_right_brace|@>@;

procedure main_control; {governs \TeX's activities}
label big_switch,reswitch,main_loop,main_loop_1,main_loop_2,main_loop_3,
  append_normal_space,main_loop_j,main_loop_j2,main_loop_j3,
  insert_glue,skip_loop,skip_loop_1,again_1,again_2,exit;
var t:integer; {general-purpose temporary variable}
  @<Local variables for the inner loop of |main_control|@>@;
begin
  if every_job<>null then begin_token_list(every_job,every_job_text);
big_switch:
  get_x_token;@/
reswitch:
  @<Give diagnostic information, if requested@>;
  case abs(mode)+cur_cmd of
  hmode+letter,hmode+other_char: goto main_loop;
  hmode+char_given:
    begin
      if (cur_chr>=0)and(cur_chr<256) then goto main_loop;
      @<Insert post_break_penalty, check char_node@>;
      KANJI(cx):=cur_chr;
      if direction=dir_tate then f:=cur_tfont else f:=cur_jfont;
      goto main_loop_j2;
    end;
  hmode+kanji,hmode+kana,hmode+other_kchar: goto main_loop_j;
  hmode+char_num:
    begin
      scan_char_num;
      if (cur_val>=0)and(cur_val<256) then begin
        cur_chr:=cur_val; goto main_loop;
      end;
      @<Insert post_break_penalty, check char_node@>;
      KANJI(cx):=cur_val;
      if direction=dir_tate then f:=cur_tfont else f:=cur_jfont;
      goto main_loop_j2;
    end;
  hmode+spacer:
    if space_factor=1000 then goto append_normal_space
    else app_space;
  hmode+ex_space,mmode+ex_space:
    goto append_normal_space;
  @t\4@>@<Cases of |main_control| that are not part of the inner loop@>@;
  end; {of the big |case| statement}
  goto big_switch;
main_loop_j:
  @<Append KANJI-character |cur_chr| 
    to the current hlist in the current font; |goto reswitch| when
    a non-character has been fetched@>;
main_loop:
  @<Append character |cur_chr| and the following characters (if~any)
    to the current hlist in the current font; |goto reswitch| when
    a non-character has been fetched@>;
append_normal_space:
  @<Append a normal inter-word space to the current list,
    then |goto big_switch|@>;
exit:
end;

@ @<Append KANJI-character |cur_chr| ...@>=
  @<Insert post_break_penalty, check char_node@>;
  if direction=dir_tate then f:=cur_tfont else f:=cur_jfont;
  l:=qi(0);
  disp:=0;
  if (direction=dir_tate)and(font_dir[f]<>dir_tate) then
    disp:=t_baseline_shift-y_baseline_shift
  else if (direction<>dir_tate)and(font_dir[f]=dir_tate) then
    disp:=y_baseline_shift-t_baseline_shift;
  @<Append |disp_node| at begin of displace area@>;
  goto skip_loop_1;

main_loop_j2:
  if (font_dir[f]=dir_default)or(hbyte=255) then begin
    jchar_warning(f,cx); goto big_switch;
  end;
  ligature_present:=false; l:=qi(get_jfm_pos(KANJI(cx), f)); q:=tail;
  disp:=0;
  if (direction=dir_tate)and(font_dir[f]<>dir_tate) then
    disp:=t_baseline_shift-y_baseline_shift
  else if (direction<>dir_tate)and(font_dir[f]=dir_tate) then
    disp:=y_baseline_shift-t_baseline_shift;
  @<Append |disp_node| at begin of displace area@>;
main_loop_j3:
  space_factor:=1000; cur_jchr:=cx;
  fast_get_avail(p); font(p):=f;
  character(p):=l; link(tail):=p; tail:=p; last_jchr:=tail;
  fast_get_avail(p); info(p):=KANJI(cur_jchr); link(tail):=p; tail:=p;
  @<Insert kinsoku penalty@>;
again_2:
  get_next;
skip_loop_1:
  i:=char_info(f)(l); KANJI(cx):=min_halfword;
  if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then begin
    PutHi(cx,cur_chr); get_next; PutLo(cx,cur_chr); 
    l:=qi(get_jfm_pos(KANJI(cx), f));
  end else if (cur_cmd=letter)or(cur_cmd=other_char)or(cur_cmd=char_given) then
    l:=qi(0)
  else begin
    x_token;
    if (cur_cmd=letter)or(cur_cmd=other_char)or(cur_cmd=char_given) then
      l:=qi(0)
    else if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then begin
      PutHi(cx,cur_chr); get_next; PutLo(cx,cur_chr); 
      l:=qi(get_jfm_pos(KANJI(cx), f));
    end else if cur_cmd=char_num then begin
      scan_char_num;
      if (cur_val>=0)and(cur_val<256) then begin
        l:=qi(0); cur_chr:=cur_val;
      end else begin
        KANJI(cx):=cur_val;
        l:=qi(get_jfm_pos(KANJI(cx), f));
      end;
    end else if cur_cmd=inhibit_glue then begin
      inhibit_glue_flag:=true; goto again_2;
    end else begin
      l:=qi(0); KANJI(cx):=max_halfword;
    end;{goto reswitch;}
  end;
  if KANJI(cx)=min_halfword then begin
    @<Insert pre_break_penalty@>; KANJI(cx):=min_halfword;
  end;
insert_glue:
  @<Look ahead for glue or kerning@>
  if KANJI(cx)=max_halfword then begin
    { Kanji -> cs }
    @<Append |disp_node| at end of displace area@>;
    goto reswitch;
  end else if KANJI(cx)=min_halfword then begin
    { Kanji -> Ascii }
    @<Append |disp_node| at end of displace area@>;
    goto main_loop;
  end else
    { Kanji -> Kanji }
    goto main_loop_j3;

@ @<Append |disp_node| at begin ...@>=
  if disp<>0 then begin
    if (not is_char_node(tail)) and type(tail)=disp_node then begin
      if prev_disp=disp then begin
        free_node(tail,small_node_size);
        tail:=prev_node;
      end else disp_dimen(tail):=disp;
    end else begin
      tail_append(get_node(small_node_size)); type(tail):=disp_node;
      disp_dimen(tail):=disp;
    end;
  end

@ @<Append |disp_node| at end ...@>=
  if disp<>0 then begin
    prev_node:=tail; prev_disp:=disp;
    tail_append(get_node(small_node_size)); type(tail):=disp_node;
    disp_dimen(tail):=0;
  end

@ @<Look ahead for glue or kerning@>=
  q:=tail;
  if not inhibit_glue_flag then begin
    if char_tag(i)=gk_tag then begin
      k:=glue_kern_start(f)(i);
      repeat
        j:=font_info[k].qqqq;
        if next_char(j)=l then
          if op_bit(j)<kern_flag then begin
            gp:=font_glue[f];
            r:=rem_byte(j);
            if gp<>null then begin
              while((type(gp)<>r)and(link(gp)<>null)) do begin
                gp:=link(gp);
              end;
              gq:=glue_ptr(gp);
            end else begin
              gp:=get_node(small_node_size); font_glue[f]:=gp;
              gq:=null;
            end;
            if gq=null then begin
              type(gp):=r; gq:=new_spec(zero_glue);
              glue_ptr(gp):=gq;
              k:=exten_base[f]+qi((qo(r))*3); width(gq):=font_info[k].sc;
              stretch(gq):=font_info[k+1].sc; shrink(gq):=font_info[k+2].sc;
              add_glue_ref(gq); link(gp):=get_node(small_node_size);
              gp:=link(gp); glue_ptr(gp):=null; link(gp):=null;
            end;
            tail_append(new_glue(gq)); subtype(tail):=jfm_skip+1;
            goto skip_loop;
          end else begin
            tail_append(new_kern(char_kern(f)(j)));
            goto skip_loop;
          end;
        incr(k);
      until stop_bit(j)>=stop_flag;
    end;
  end;
skip_loop:
  inhibit_glue_flag:=false;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[46.1032] local cx
%p[46.1032] rotate offset
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!s:integer; {space factor code}
@!ligature_present:boolean; {should a ligature node be made?}
@y
@!s:integer; {space factor code}
@!ligature_present:boolean; {should a ligature node be made?}
@!cx:KANJI_code;
@!kp:pointer; {kinsoku penalty}
@!gp,gq:pointer;
@!disp:scaled; {displacement}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[46.1033] inhibit_glue_flag, lp
%p[46.1033] disp node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Append character |cur_chr| and the following characters...@>=
f:=cur_font; c:=cur_chr;
main_loop_1: if (c<font_bc[f])or(c>font_ec[f]) then
  begin char_warning(f,c); goto big_switch;
  end;
main_loop_2: q:=tail; ligature_present:=false; l:=qi(c);
main_loop_3: @<Adjust \(t)the space factor,
  based on its current value and |c|@>;
@<Append character |l| and the following characters (if any) to the current
  hlist, in font |f|; if |ligature_present|, detach a ligature node
  starting at |link(q)|; if |c| is a hyphen, append a null |disc_node|;
  finally |goto reswitch|@>
@y
@ @<Append character |cur_chr| and the following characters...@>=
  inhibit_glue_flag:=false;
  f:=cur_font; c:=cur_chr;
  if direction=dir_tate then disp:=t_baseline_shift else disp:=y_baseline_shift;
  @<Append |disp_node| at begin of displace area@>;
main_loop_1:
  if (c<font_bc[f])or(c>font_ec[f]) then begin
    char_warning(f,c); goto big_switch;
  end;
main_loop_2:
  q:=tail;
  ligature_present:=false; l:=qi(c);
main_loop_3:
  @<Adjust \(t)the space factor, based on its current value and |c|@>;
  @<Append character |l| and the following characters (if any) to the current
    hlist, in font |f|; if |ligature_present|, detach a ligature node
    starting at |link(q)|; if |c| is a hyphen, append a null |disc_node|;
    finally |goto reswitch|@>
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[46.1036] insert disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Look ahead for ligature...@>=
get_next; {set only |cur_cmd| and |cur_chr|}
if cur_cmd=letter then r:=qi(cur_chr)
else if cur_cmd=other_char then r:=qi(cur_chr)
else if cur_cmd=char_given then r:=qi(cur_chr)
else  begin x_token; {set |cur_cmd|, |cur_chr|, |cur_tok|}
  if (cur_cmd=letter)or(cur_cmd=other_char)or(cur_cmd=char_given) then
    r:=qi(cur_chr)
  else if cur_cmd=char_num then
    begin scan_char_num; r:=qi(cur_val);
    end
  else r:=qi(256); {this flag means that no character follows}
  end;
if char_tag(i)=lig_tag then if r<>qi(256) then
  @<Follow the lig/kern program; |goto main_loop_3| if scoring a hit@>;
@<Make a ligature node, if |ligature_present|; insert a discretionary
  node for an explicit hyphen, if |c| is the current |hyphen_char|@>;
if r=qi(256) then goto reswitch; {|cur_cmd|, |cur_chr|, |cur_tok| are untouched}
c:=qo(r); goto main_loop_1 {|f| is still valid}
@y
@<Look ahead for ligature...@>=
again_1:
  get_next; {set only |cur_cmd| and |cur_chr|}
  KANJI(cur_jchr):=0;
  if cur_cmd=letter then r:=qi(cur_chr)
  else if cur_cmd=other_char then r:=qi(cur_chr)
  else if cur_cmd=char_given then
    if (cur_chr>=0)and(cur_chr<256)then r:=qi(cur_chr)
    else begin
      r:=qi(256); KANJI(cur_jchr):=cur_val;
    end
  else if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then begin
    r:=qi(256); PutHi(cur_jchr,cur_chr); get_next; PutLo(cur_jchr,cur_chr);
  end else begin
    x_token; {set |cur_cmd|, |cur_chr|, |cur_tok|}
    if (cur_cmd=letter)or(cur_cmd=other_char)or(cur_cmd=char_given) then
      r:=qi(cur_chr)
    else if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then begin
      r:=qi(256); PutHi(cur_jchr,cur_chr); get_next; PutLo(cur_jchr,cur_chr);
    end else if cur_cmd=char_num then begin
      scan_char_num;
      if (cur_val>=0)and(cur_val<256) then r:=qi(cur_val)
      else begin r:=qi(256); KANJI(cur_jchr):=cur_val; end;
    end else if cur_cmd=inhibit_glue then begin
      inhibit_glue_flag:=true; goto again_1;
    end else
      r:=qi(256); {this flag means that no character follows}
  end;
  if char_tag(i)=lig_tag then if r<>qi(256) then
    @<Follow the lig/kern program; |goto main_loop_3| if scoring a hit@>;
  @<Make a ligature node, if |ligature_present|; insert a discretionary
    node for an explicit hyphen, if |c| is the current |hyphen_char|@>;
  if r=qi(256) then begin
    if KANJI(cur_jchr)<>0 then begin
      { English -> Kanji }
      @<Insert post_break_penalty, no check@>;
      cx:=cur_jchr;
      if direction=dir_tate then f:=cur_tfont else f:=cur_jfont;
      prev_disp:=disp;
      disp:=0;
      if (direction=dir_tate)and(font_dir[f]<>dir_tate) then
        disp:=t_baseline_shift-y_baseline_shift
      else if (direction<>dir_tate)and(font_dir[f]=dir_tate) then
        disp:=y_baseline_shift-t_baseline_shift;
      if disp<>prev_disp then begin
        tail_append(get_node(small_node_size)); type(tail):=disp_node;
        disp_dimen(tail):=disp;
      end;
      l:=qi(get_jfm_pos(KANJI(cx),f));
      i:=char_info(f)(qi(0)); goto insert_glue
    end else begin
      { English -> cs }
      @<Append |disp_node| at end of displace area@>;
      goto reswitch;
    end;
  end;
  c:=qo(r); goto main_loop_1 {|f| is still valid}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1039] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Make a ligature node,...@>=
if ligature_present then
  begin p:=new_ligature(f,l,link(q)); link(q):=p; tail:=p;
  end;
if c=hyphen_char[f] then if mode=hmode then tail_append(new_disc)
@y
@<Make a ligature node,...@>=
if ligature_present then
  @<Make ligature node and Insert post_break_penalty@>;
if c=hyphen_char[f] then if mode=hmode then tail_append(new_disc)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[46.1041] space
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Append a normal inter-word space...@>=
if space_skip=zero_glue then
  begin @<Find the glue specification, |p|, for
    text spaces in the current font@>;
  q:=new_glue(p);
  end
else q:=new_param_glue(space_skip_code);
link(tail):=q; tail:=q;
goto big_switch
@y
@<Append a normal inter-word space...@>=
  if space_skip=zero_glue then begin
    @<Find the glue specification, |p|, for
      text spaces in the current font@>;
    q:=new_glue(p);
  end else q:=new_param_glue(space_skip_code);
  if (not is_char_node(tail)) and type(tail)=disp_node then begin
    link(prev_node):=q; link(q):=tail; prev_node:=q;
  end else begin
    link(tail):=q; tail:=q;
  end;
  goto big_switch
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[46.1043] space
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure app_space; {handle spaces when |space_factor<>1000|}
var p:pointer; {glue specification}
@!q:pointer; {glue node}
@!f:internal_font_number; {the current font}
@!k:0..font_mem_size; {index into |font_info|}
begin if (space_factor>=2000)and(xspace_skip<>zero_glue) then
  q:=new_param_glue(xspace_skip_code)
else  begin if space_skip<>zero_glue then p:=space_skip
  else @<Find the glue specification...@>;
  p:=new_spec(p);
  @<Modify the glue specification in |p| according to the space factor@>;
  q:=new_glue(p); glue_ref_count(p):=null;
  end;
link(tail):=q; tail:=q;
end;
@y
procedure app_space; {handle spaces when |space_factor<>1000|}
var p:pointer; {glue specification}
  @!q:pointer; {glue node}
  @!f:internal_font_number; {the current font}
  @!k:0..font_mem_size; {index into |font_info|}
begin
  if (space_factor>=2000)and(xspace_skip<>zero_glue) then
    q:=new_param_glue(xspace_skip_code)
  else begin
    if space_skip<>zero_glue then p:=space_skip
    else @<Find the glue specification...@>;
    p:=new_spec(p);
    @<Modify the glue specification in |p| according to the space factor@>;
    q:=new_glue(p); glue_ref_count(p):=null;
  end;
  if (not is_char_node(tail)) and type(tail)=disp_node then
    prev_append(q)
  else tail_append(q);
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% [47.1060] append glue
%%d[47.1060] decr(glue_ref_count())->delete_glue_ref()
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%@x
%tail_append(new_glue(cur_val));
%@y
%  if (not is_char_node(tail)) and type(tail)=disp_node then
%    prev_append(new_glue(cur_val))
%  else
%    tail_append(new_glue(cur_val));
%@z
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1061] append kern
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure append_kern;
var s:quarterword; {|subtype| of the kern node}
begin s:=cur_chr; scan_dimen(s=mu_glue,false,false);
tail_append(new_kern(cur_val)); subtype(tail):=s;
end;
@y
procedure append_kern;
var s:quarterword; {|subtype| of the kern node}
begin
  s:=cur_chr; scan_dimen(s=mu_glue,false,false);
  if (not is_char_node(tail)) and type(tail)=disp_node then begin
    prev_append(new_kern(cur_val)); subtype(prev_node):=s;
  end else begin
    tail_append(new_kern(cur_val)); subtype(tail):=s;
  end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1068] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure handle_right_brace;
var p,@!q:pointer; {for short-term use}
@!d:scaled; {holds |split_max_depth| in |insert_group|}
@!f:integer; {holds |floating_penalty| in |insert_group|}
@y
procedure handle_right_brace;
var p,@!q:pointer; {for short-term use}
  @!r:pointer; {temporaly}
  @!d:scaled; {holds |split_max_depth| in |insert_group|}
  @!f:integer; {holds |floating_penalty| in |insert_group|}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1071] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
primitive("hbox",make_box,vtop_code+hmode);@/
@!@:hbox_}{\.{\\hbox} primitive@>
@y
primitive("hbox",make_box,vtop_code+hmode);@/
@!@:hbox_}{\.{\\hbox} primitive@>

primitive("tate",chg_dir,dir_tate);@/
@!@:tate_}{\.{\\tate} primitive@>
primitive("yoko",chg_dir,dir_yoko);@/
@!@:yoko_}{\.{\\yoko} primitive@>
primitive("dtou",chg_dir,dir_dtou);@/
@!@:dtou_}{\.{\\dtou} primitive@>
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1072] 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  othercases print_esc("hbox")
  endcases;
leader_ship: if chr_code=a_leaders then print_esc("leaders")
@y
      othercases print_esc("hbox")
    endcases;
  chg_dir:
    case chr_code of
    dir_yoko: print_esc("yoko");
    dir_tate: print_esc("tate");
    dir_dtou: print_esc("dtou");
    endcases;
  leader_ship:
    if chr_code=a_leaders then print_esc("leaders")
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1073] \tate, \yoko
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
any_mode(make_box): begin saved(0):=0; begin_box;
  end;
@y
any_mode(make_box):
  begin
    saved(0):=0; begin_box;
  end;
any_mode(chg_dir):
  begin
    if cur_group<>align_group then
      if head=tail then begin
        direction:=cur_chr;
        if mode=vmode then page_dir:=cur_chr;
      end else begin
        print_err("Use `"); print_cmd_chr(cur_cmd,cur_chr);
        print("' at top of list");
        help2("Direction change command is available only while")
        ("current list is null."); error;
      end
    else begin
      print_err("You can't use `"); print_cmd_chr(cur_cmd,cur_chr);
      print("' in an align");
      help2("To change direction in an align,")
      ("you shold use \hbox or \vbox with \tate or \yoko."); error;
    end
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1075] box_end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The |box_end| procedure does the right thing with |cur_box|, if
|saved(0)| represents the context as explained above.

@<Declare act...@>=
procedure box_end;
var p:pointer; {|ord_noad| for new box in math mode}
begin if saved(0)<box_flag then @<Append box |cur_box| to the current list,
    shifted by |saved(0)|@>
else if saved(0)<ship_out_flag then @<Store \(c)|cur_box| in a box register@>
else if cur_box<>null then
  if saved(0)>ship_out_flag then @<Append a new leader node that
      uses |cur_box|@>
  else ship_out(cur_box);
end;
@y
@ The |box_end| procedure does the right thing with |cur_box|, if
|saved(0)| represents the context as explained above.

@<Declare act...@>=
procedure box_end;
var p,q:pointer; {|ord_noad| for new box in math mode}
begin
  if saved(0)<box_flag then
    @<Append box |cur_box| to the current list, shifted by |saved(0)|@>
  else if saved(0)<ship_out_flag then
    @<Store \(c)|cur_box| in a box register@>
  else if cur_box<>null then
    if saved(0)>ship_out_flag then
      @<Append a new leader node that uses |cur_box|@>
    else ship_out(cur_box);
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1076] box_dir adjust
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ The global variable |adjust_tail| will be non-null if and only if the
current box might include adjustments that should be appended to the
current vertical list.

@<Append box |cur_box| to the current...@>=
begin if cur_box<>null then
  begin shift_amount(cur_box):=saved(0);
  if abs(mode)=vmode then
    begin append_to_vlist(cur_box);
    if adjust_tail<>null then
      begin if adjust_head<>adjust_tail then
        begin link(tail):=link(adjust_head); tail:=adjust_tail;
        end;
      adjust_tail:=null;
      end;
    if mode>0 then build_page;
    end
  else  begin if abs(mode)=hmode then space_factor:=1000
    else  begin p:=new_noad;
      math_type(nucleus(p)):=sub_box;
      info(nucleus(p)):=cur_box; cur_box:=p;
      end;
    link(tail):=cur_box; tail:=cur_box;
    end;
  end;
end
@y
@ The global variable |adjust_tail| will be non-null if and only if the
current box might include adjustments that should be appended to the
current vertical list.

@<Append box |cur_box| to the current...@>=
  begin
    if cur_box<>null then begin
      p:=link(cur_box); link(cur_box):=null;
      while p<>null do begin
        q:=p; p:=link(p);
        if box_dir(q)=abs(direction) then begin
          list_ptr(q):=cur_box; cur_box:=q; link(cur_box):=null;
        end else begin
          delete_glue_ref(space_ptr(q));
          delete_glue_ref(xspace_ptr(q));
          free_node(q,box_node_size);
        end;
      end;
      if box_dir(cur_box)<>abs(direction) then
        cur_box:=new_dir_node(cur_box,abs(direction));
      shift_amount(cur_box):=saved(0);
      if abs(mode)=vmode then begin
        append_to_vlist(cur_box);
        if adjust_tail<>null then begin
          if adjust_head<>adjust_tail then begin
            link(tail):=link(adjust_head); tail:=adjust_tail;
          end;
          adjust_tail:=null;
        end;
        if mode>0 then build_page;
      end else begin
        if abs(mode)=hmode then space_factor:=1000
        else begin
          p:=new_noad;
          math_type(nucleus(p)):=sub_box;
          info(nucleus(p)):=cur_box; cur_box:=p;
        end;
        link(tail):=cur_box; tail:=cur_box;
      end;
    end;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1078] box_dir adjust
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Append a new leader node ...@>=
begin @<Get the next non-blank non-relax...@>;
if ((cur_cmd=hskip)and(abs(mode)<>vmode))or@|
   ((cur_cmd=vskip)and(abs(mode)=vmode))or@|
   ((cur_cmd=mskip)and(abs(mode)=mmode)) then
  begin append_glue; subtype(tail):=saved(0)-(leader_flag-a_leaders);
  leader_ptr(tail):=cur_box;
  end
else  begin print_err("Leaders not followed by proper glue");
@.Leaders not followed by...@>
  help3("You should say `\leaders <box or rule><hskip or vskip>'.")@/
  ("I found the <box or rule>, but there's no suitable")@/
  ("<hskip or vskip>, so I'm ignoring these leaders."); back_error;
  flush_node_list(cur_box);
  end;
end
@y
@ @<Append a new leader node ...@>=
  begin
    @<Get the next non-blank non-relax...@>;
    if ((cur_cmd=hskip)and(abs(mode)<>vmode))or@|
        ((cur_cmd=vskip)and(abs(mode)=vmode))or@|
        ((cur_cmd=mskip)and(abs(mode)=mmode)) then begin
      append_glue; subtype(tail):=saved(0)-(leader_flag-a_leaders);
      if type(cur_box)<=dir_node then begin
        p:=link(cur_box); link(cur_box):=null;
        while p<>null do begin
          q:=p; p:=link(p);
          if box_dir(q)=abs(direction) then begin
            list_ptr(q):=cur_box; cur_box:=q; link(cur_box):=null;
          end else begin
            delete_glue_ref(space_ptr(q));
            delete_glue_ref(xspace_ptr(q));
            free_node(q,box_node_size);
          end;
        end;
        if box_dir(cur_box)<>abs(direction) then
          cur_box:=new_dir_node(cur_box,abs(direction));
      end;
      leader_ptr(tail):=cur_box;
    end else begin
      print_err("Leaders not followed by proper glue");
@.Leaders not followed by...@>
      help3("You should say `\leaders <box or rule><hskip or vskip>'.")@/
      ("I found the <box or rule>, but there's no suitable")@/
      ("<hskip or vskip>, so I'm ignoring these leaders."); back_error;
      flush_node_list(cur_box);
    end;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1079] begin_box, last_box: disp_node
%p[47.1079] adjust direction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure begin_box;
label exit, done;
var @!p,@!q:pointer; {run through the current list}
@!m:quarterword; {the length of a replacement list}
@!k:halfword; {0 or |vmode| or |hmode|}
@!n:eight_bits; {a box number}
@y
procedure begin_box;
label exit, done;
var @!p,@!q:pointer; {run through the current list}
  @!m:quarterword; {the length of a replacement list}
  @!k:halfword; {0 or |vmode| or |hmode|}
  @!n:eight_bits; {a box number}
  @!a_dir:eight_bits; {adjust direction}
  @!d:pointer; {last disp_node}
  @!disp,@!pdisp:scaled; {displacement}
  @!pp,pnode:pointer;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [47.1080] check head=tail
%p[47.1080] disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else  begin if not is_char_node(tail) then
    if (type(tail)=hlist_node)or(type(tail)=vlist_node) then
      @<Remove the last box, unless it's part of a discretionary@>;
  end;
@y
  else begin
    if (not is_char_node(tail)) and type(tail)=disp_node then begin
      d:=tail; tail:=prev_node;
    end else d:=null;
    if (not is_char_node(tail))and(head<>tail) then
      if (type(tail)=hlist_node)or(type(tail)=vlist_node)
            or(type(tail)=dir_node) then
        @<Remove the last box, unless it's part of a discretionary@>;
    if d<>null then
      if (not is_char_node(tail)) and type(tail)=disp_node then begin
        prev_node:=pnode; prev_disp:=pdisp;
        if prev_disp=disp_dimen(d) then
          free_node(tail,small_node_size)
        else
          disp_dimen(tail):=disp_dimen(d);
        free_node(d,small_node_size);
      end else tail_append(d);
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1081] disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Remove the last box...@>=
begin q:=head;
repeat p:=q;
if not is_char_node(q) then if type(q)=disc_node then
  begin for m:=1 to replace_count(q) do p:=link(p);
  if p=tail then goto done;
  end;
q:=link(p);
until q=tail;
cur_box:=tail; shift_amount(cur_box):=0;
tail:=p; link(p):=null;
done:end
@y
@ @<Remove the last box...@>=
  begin
    q:=head; disp:=0; pdisp:=0;
    repeat
      p:=q;
      if not is_char_node(q) then
        if type(q)=disc_node then begin
          for m:=1 to replace_count(q) do p:=link(p);
          if p=tail then goto done;
        end else if type(q)=disp_node then begin
          pnode:=pp; pdisp:=disp;
          disp:=disp_dimen(q);
        end;
      pp:=q; q:=link(p);
    until q=tail;
    cur_box:=tail; shift_amount(cur_box):=0;
    tail:=p; link(p):=null;
    if type(cur_box)=dir_node then begin
      link(list_ptr(cur_box)):=cur_box;
      cur_box:=list_ptr(cur_box);
      list_ptr(link(cur_box)):=null;
    end else begin
      if box_dir(cur_box)=dir_default then
        box_dir(cur_box):=abs(direction);
    end;
done:
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1083] adjust_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Initiate the construction of an hbox or vbox, then |return|@>=
begin k:=cur_chr-vtop_code;
incr(save_ptr); scan_spec;
if k=hmode then
  if (saved(-3)<box_flag)and(abs(mode)=vmode) then
    new_save_level(adjusted_hbox_group)
  else new_save_level(hbox_group)
else  begin if k=vmode then new_save_level(vbox_group)
  else  begin new_save_level(vtop_group); k:=vmode;
    end;
  normal_paragraph;
  end;
push_nest; mode:=-k;
if k=vmode then
  begin prev_depth:=ignore_depth;
  if every_vbox<>null then begin_token_list(every_vbox,every_vbox_text);
  end
else  begin space_factor:=1000;
  if every_hbox<>null then begin_token_list(every_hbox,every_hbox_text);
  end;
return;
end
@y
@<Initiate the construction of an hbox or vbox, then |return|@>=
  begin
    k:=cur_chr-vtop_code;
    incr(save_ptr); scan_spec;
    a_dir:=adjust_dir;
    if k=hmode then
      if (saved(-3)<box_flag)and(abs(mode)=vmode) then begin
        a_dir:=abs(direction);
        new_save_level(adjusted_hbox_group)
      end else new_save_level(hbox_group)
    else begin
      if k=vmode then
        new_save_level(vbox_group)
      else begin
        new_save_level(vtop_group); k:=vmode;
      end;
      normal_paragraph;
    end;
    push_nest; mode:=-k; adjust_dir:=a_dir;
    if k=vmode then begin
      prev_depth:=ignore_depth;
      if every_vbox<>null then
        begin_token_list(every_vbox,every_vbox_text);
    end else begin
      space_factor:=1000;
      if every_hbox<>null then begin_token_list(every_hbox,every_hbox_text);
    end;
    return;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1085] end of box, call adjust_hlist
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
hbox_group: package(0);
adjusted_hbox_group: begin adjust_tail:=adjust_head; package(0);
  end;
@y
hbox_group: begin adjust_hlist(head, false); package(0); end;
adjusted_hbox_group: begin adjust_hlist(head, false);
  adjust_tail:=adjust_head; package(0);
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1086] set cur_kanji_skip, cur_xkanji_skip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure package(@!c:small_number);
var h:scaled; {height of box}
@!p:pointer; {first node in a box}
@!d:scaled; {max depth}
begin d:=box_max_depth; unsave; save_ptr:=save_ptr-3;
if mode=-hmode then cur_box:=hpack(link(head),saved(2),saved(1))
else  begin cur_box:=vpackage(link(head),saved(2),saved(1),d);
  if c=vtop_code then @<Readjust the height and depth of |cur_box|,
    for \.{\\vtop}@>;
  end;
pop_nest; box_end;
end;
@y
procedure package(@!c:small_number);
var h:scaled; {height of box}
  @!p:pointer; {first node in a box}
  @!d:scaled; {max depth}
begin
  d:=box_max_depth;
  delete_glue_ref(cur_kanji_skip); delete_glue_ref(cur_xkanji_skip);
  if auto_spacing>0 then cur_kanji_skip:=kanji_skip
  else cur_kanji_skip:=zero_glue;
  if auto_xspacing>0 then cur_xkanji_skip:=xkanji_skip
  else cur_xkanji_skip:=zero_glue;
  add_glue_ref(cur_kanji_skip); add_glue_ref(cur_xkanji_skip);
  unsave; save_ptr:=save_ptr-3;
  if mode=-hmode then begin
    cur_box:=hpack(link(head),saved(2),saved(1));
    box_dir(cur_box):=abs(direction); pop_nest;
  end else begin
    cur_box:=vpackage(link(head),saved(2),saved(1),d);
    box_dir(cur_box):=abs(direction); pop_nest;
    if c=vtop_code then
      @<Readjust the height and depth of |cur_box|, for \.{\\vtop}@>;
  end;
  box_end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1090] apend vmode case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Cases of |main_control| that build...@>=
vmode+start_par: new_graf(cur_chr>0);
vmode+letter,vmode+other_char,vmode+char_num,vmode+char_given,
   vmode+math_shift,vmode+un_hbox,vmode+vrule,
   vmode+accent,vmode+discretionary,vmode+hskip,vmode+valign,
   vmode+ex_space:@t@>@;@/
  begin back_input; new_graf(true);
  end;
@y
@ @<Cases of |main_control| that build...@>=
vmode+start_par: new_graf(cur_chr>0);
vmode+letter,vmode+other_char,vmode+char_num,vmode+char_given,
   vmode+math_shift,vmode+un_hbox,vmode+vrule,
   vmode+accent,vmode+discretionary,vmode+hskip,vmode+valign,
   vmode+kanji,vmode+kana,vmode+other_kchar,vmode+ex_space:@t@>@;@/
  begin back_input; new_graf(true);
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1091] new_graf, adjust direction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure new_graf(@!indented:boolean);
begin prev_graf:=0;
if (mode=vmode)or(head<>tail) then
  tail_append(new_param_glue(par_skip_code));
push_nest; mode:=hmode; space_factor:=1000;
if indented then
  begin tail:=new_null_box; link(head):=tail; width(tail):=par_indent;
  end;
if every_par<>null then begin_token_list(every_par,every_par_text);
if nest_ptr=1 then build_page; {put |par_skip| glue on current page}
end;
@y
procedure new_graf(@!indented:boolean);
begin
  prev_graf:=0;
  if (mode=vmode)or(head<>tail) then
    tail_append(new_param_glue(par_skip_code));
  push_nest; adjust_dir:=abs(direction);
  mode:=hmode; space_factor:=1000;
  if indented then begin
    tail:=new_null_box; link(head):=tail; width(tail):=par_indent;
  end;
  if every_par<>null then begin_token_list(every_par,every_par_text);
  if nest_ptr=1 then build_page; {put |par_skip| glue on current page}
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1096] end_graf, call adjust_hlist
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure end_graf;
begin if mode=hmode then
  begin if head=tail then pop_nest {null paragraphs are ignored}
  else line_break(widow_penalty);
  normal_paragraph;
  error_count:=0;
  end;
end;
@y
procedure end_graf;
begin if mode=hmode then
  begin if head=tail then pop_nest {null paragraphs are ignored}
  else begin adjust_hlist(head, true); line_break(widow_penalty) end;
  normal_paragraph;
  error_count:=0;
  end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1099] insert and adjust
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure begin_insert_or_adjust;
begin if cur_cmd=vadjust then cur_val:=255
else  begin scan_eight_bit_int;
  if cur_val=255 then
    begin print_err("You can't "); print_esc("insert"); print_int(255);
@.You can't \\insert255@>
    help1("I'm changing to \insert0; box 255 is special.");
    error; cur_val:=0;
    end;
  end;
saved(0):=cur_val; incr(save_ptr);
new_save_level(insert_group); scan_left_brace; normal_paragraph;
push_nest; mode:=-vmode; prev_depth:=ignore_depth;
end;
@y
procedure begin_insert_or_adjust;
begin
  if cur_cmd=vadjust then cur_val:=255
  else  begin scan_eight_bit_int;
    if cur_val=255 then
      begin print_err("You can't "); print_esc("insert"); print_int(255);
@.You can't \\insert255@>
      help1("I'm changing to \insert0; box 255 is special.");
      error; cur_val:=0;
    end;
  end;
  saved(0):=cur_val; incr(save_ptr);
  new_save_level(insert_group); scan_left_brace; normal_paragraph;
  push_nest; mode:=-vmode; direction:=adjust_dir; prev_depth:=ignore_depth;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1100] free box node
%p[47.1100] ins_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
insert_group: begin end_graf; q:=split_top_skip; add_glue_ref(q);
  d:=split_max_depth; f:=floating_penalty; unsave; decr(save_ptr);
  {now |saved(0)| is the insertion number, or 255 for |vadjust|}
  p:=vpack(link(head),natural); pop_nest;
  if saved(0)<255 then
    begin tail_append(get_node(ins_node_size));
    type(tail):=ins_node; subtype(tail):=qi(saved(0));
    height(tail):=height(p)+depth(p); ins_ptr(tail):=list_ptr(p);
    split_top_ptr(tail):=q; depth(tail):=d; float_cost(tail):=f;
    end
  else  begin tail_append(get_node(small_node_size));
    type(tail):=adjust_node;@/
    subtype(tail):=0; {the |subtype| is not used}
    adjust_ptr(tail):=list_ptr(p); delete_glue_ref(q);
    end;
  free_node(p,box_node_size);
  if nest_ptr=0 then build_page;
  end;
output_group: @<Resume the page builder...@>;
@y
insert_group:
  begin
    end_graf; q:=split_top_skip; add_glue_ref(q);
    d:=split_max_depth; f:=floating_penalty; unsave; decr(save_ptr);
    {now |saved(0)| is the insertion number, or 255 for |vadjust|}
    p:=vpack(link(head),natural); box_dir(p):=abs(direction); pop_nest;
    if saved(0)<255 then begin
      r:=get_node(ins_node_size);
      type(r):=ins_node; subtype(r):=qi(saved(0));
      height(r):=height(p)+depth(p); ins_ptr(r):=list_ptr(p);
      split_top_ptr(r):=q; depth(r):=d; float_cost(r):=f;
      ins_dir(r):=box_dir(p);
      if (not is_char_node(tail)) and type(tail)=disp_node then
        prev_append(r)
      else tail_append(r);
    end else begin
      if box_dir(p)<>adjust_dir then begin
        print_err("Direction Incompatible.");
        help1("\vadjust's argument and outer vlist must have same direction.");
        error; flush_node_list(list_ptr(p));
      end else begin
        r:=get_node(small_node_size);
        type(r):=adjust_node;@/
        adjust_ptr(r):=list_ptr(p);
        delete_glue_ref(q);
        if (not is_char_node(tail)) and type(tail)=disp_node then
          prev_append(r)
        else tail_append(r);
      end;
    end;
    delete_glue_ref(space_ptr(p));
    delete_glue_ref(xspace_ptr(p));
    free_node(p,box_node_size);
    if nest_ptr=0 then build_page;
  end;
output_group: @<Resume the page builder...@>;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1101] mark_node, prev_append
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure make_mark;
var p:pointer; {new node}
begin p:=scan_toks(false,true); p:=get_node(small_node_size);
type(p):=mark_node; subtype(p):=0; {the |subtype| is not used}
mark_ptr(p):=def_ref; link(tail):=p; tail:=p;
end;
@y
procedure make_mark;
var p:pointer; {new node}
begin
  p:=scan_toks(false,true); p:=get_node(small_node_size);
  type(p):=mark_node; subtype(p):=0; {the |subtype| is not used}
  mark_ptr(p):=def_ref;
  if (not is_char_node(tail)) and type(tail)=disp_node then
    prev_append(p)
  else tail_append(p);
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1103] penalty, prev_append
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure append_penalty;
begin scan_int; tail_append(new_penalty(cur_val));
if mode=vmode then build_page;
end;
@y
procedure append_penalty;
begin
  scan_int;
  if (not is_char_node(tail)) and type(tail)=disp_node then
    prev_append(new_penalty(cur_val))
  else tail_append(new_penalty(cur_val));
  if mode=vmode then build_page;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%D[47.1105] delete_last: disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure delete_last;
label exit;
var @!p,@!q:pointer; {run through the current list}
@!m:quarterword; {the length of a replacement list}
begin if (mode=vmode)and(tail=head) then
  @<Apologize for inability to do the operation now,
    unless \.{\\unskip} follows non-glue@>
else  begin if not is_char_node(tail) then if type(tail)=cur_chr then
    begin q:=head;
    repeat p:=q;
    if not is_char_node(q) then if type(q)=disc_node then
      begin for m:=1 to replace_count(q) do p:=link(p);
      if p=tail then return;
      end;
    q:=link(p);
    until q=tail;
    link(p):=null; flush_node_list(tail); tail:=p;
    end;
  end;
exit:end;
@y
procedure delete_last;
label exit;
var @!p,@!q:pointer; {run through the current list}
  @!d:pointer; {last disp_node}
  @!m:quarterword; {the length of a replacement list}
  @!disp,@!pdisp:scaled; {displacement}
  @!pp,pnode:pointer;
begin
  if (mode=vmode)and(tail=head) then
    @<Apologize for inability to do the operation now,
      unless \.{\\unskip} follows non-glue@>
  else begin
    d:=null;
    if (not is_char_node(tail)) and type(tail)=disp_node then begin
      d:=tail; tail:=prev_node; link(tail):=null;
    end;
    if not is_char_node(tail) then if type(tail)=cur_chr then begin
      q:=head; pp:=null; disp:=0; pdisp:=0;
      repeat
        p:=q;
        if not is_char_node(q) then
          if type(q)=disc_node then begin
            for m:=1 to replace_count(q) do p:=link(p);
            if p=tail then begin
              if d<>null then tail_append(d);
              return
            end
          end else if type(q)=disp_node then begin
            pnode:=pp; pdisp:=disp;
            disp:=disp_dimen(q);
          end;
        pp:=q; q:=link(p);
      until q=tail;
      link(p):=null; flush_node_list(tail); tail:=p;
    end;
    prev_node:=pnode; prev_disp:=pdisp;
    if d<>null then
      if (not is_char_node(tail)) and type(tail)=disp_node then begin
        if prev_disp=disp_dimen(d) then
          free_node(tail,small_node_size)
        else
          disp_dimen(tail):=disp_dimen(d);
        free_node(d,small_node_size)
      end else begin
        prev_node:=tail; prev_disp:=disp;
        tail_append(d)
      end
  end;
exit:
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1110] free box node, delete kanji_skip
%p[47.1110] free box node, delete kanji_skip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure unpackage;
label exit;
var p:pointer; {the box}
@!c:box_code..copy_code; {should we copy?}
begin c:=cur_chr; scan_eight_bit_int; p:=box(cur_val);
if p=null then return;
if (abs(mode)=mmode)or((abs(mode)=vmode)and(type(p)<>vlist_node))or@|
   ((abs(mode)=hmode)and(type(p)<>hlist_node)) then
  begin print_err("Incompatible list can't be unboxed");
@.Incompatible list...@>
  help3("Sorry, Pandora. (You sneaky devil.)")@/
  ("I refuse to unbox an \hbox in vertical mode or vice versa.")@/
  ("And I can't open any boxes in math mode.");@/
  error; return;
  end;
if c=copy_code then link(tail):=copy_node_list(list_ptr(p))
else  begin link(tail):=list_ptr(p); box(cur_val):=null;
  free_node(p,box_node_size);
  end;
while link(tail)<>null do tail:=link(tail);
exit:end;
@y
procedure unpackage;
label exit;
var p:pointer; {the box}
  @!c:box_code..copy_code; {should we copy?}
  @!disp:scaled; {displacement}
begin
  c:=cur_chr; scan_eight_bit_int; p:=box(cur_val);
  if p=null then return;
  if type(p)=dir_node then p:=list_ptr(p);
  if (abs(mode)=mmode)or((abs(mode)=vmode)and(type(p)<>vlist_node))or@|
      ((abs(mode)=hmode)and(type(p)<>hlist_node)) then begin
    print_err("Incompatible list can't be unboxed");
@.Incompatible list...@>
    help3("Sorry, Pandora. (You sneaky devil.)")@/
    ("I refuse to unbox an \hbox in vertical mode or vice versa.")@/
    ("And I can't open any boxes in math mode.");@/
    error; return;
  end;
  case box_dir(p) of
  any_dir:
    if abs(direction)<>box_dir(p) then begin
      print_err("Incompatible direction list can't be unboxed");
      help2("Sorry, Pandora. (You sneaky devil.)")@/
      ("I refuse to unbox a box in differrent direction.");@/
      error; return;
    end;
  endcases;
  disp:=0;
  if c=copy_code then
    link(tail):=copy_node_list(list_ptr(p))
  else begin
    if type(box(cur_val))=dir_node then begin
      delete_glue_ref(space_ptr(box(cur_val)));
      delete_glue_ref(xspace_ptr(box(cur_val)));
      free_node(box(cur_val),box_node_size);
    end;
    flush_node_list(link(p));
    link(tail):=list_ptr(p); box(cur_val):=null;
    delete_glue_ref(space_ptr(p));
    delete_glue_ref(xspace_ptr(p));
    free_node(p,box_node_size);
  end;
  while link(tail)<>null do begin
    p:=tail; tail:=link(tail); 
    if not is_char_node(tail) then
      case type(tail) of
      glue_node :
        if (subtype(tail)=kanji_skip_code+1)
            or(subtype(tail)=xkanji_skip_code+1) then begin
          link(p):=link(tail);
          delete_glue_ref(glue_ptr(tail));
          free_node(tail, small_node_size); tail:=p;
        end;
      penalty_node :
        if subtype(tail)=widow_pena then begin
          link(p):=link(tail); free_node(tail, small_node_size);
          tail:=p;
        end;
      disp_node :
        begin
          prev_disp:=disp; disp:=disp_dimen(tail); prev_node:=p;
        end;
      endcases;
  end;
exit:
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1113] italic correction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure append_italic_correction;
label exit;
var p:pointer; {|char_node| at the tail of the current list}
@!f:internal_font_number; {the font in the |char_node|}
begin if tail<>head then
  begin if is_char_node(tail) then p:=tail
  else if type(tail)=ligature_node then p:=lig_char(tail)
  else return;
  f:=font(p);
  tail_append(new_kern(char_italic(f)(char_info(f)(character(p)))));
  subtype(tail):=explicit;
  end;
exit:end;
@y
procedure append_italic_correction;
label exit;
var p:pointer; {|char_node| at the tail of the current list}
  @!f:internal_font_number; {the font in the |char_node|}
  @!d:pointer; {disp_node}
begin
  if tail<>head then begin
    if (not is_char_node(tail)) and type(tail)=disp_node then begin
      d:=tail; tail:=prev_node;
    end else d:=null;
    if is_char_node(tail) then begin
      p:=tail;
      if last_jchr<>null then
        if link(last_jchr)=tail then p:=last_jchr;
    end else if type(tail)=ligature_node then
      p:=lig_char(tail)
    else return;
    f:=font(p);
    tail_append(new_kern(char_italic(f)(char_info(f)(character(p)))));
    subtype(tail):=explicit;
    if d<>null then tail_append(d);
  end;
exit:
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1120] discretionary with disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Attach list |p| to the current...@>=
begin if (n>0)and(abs(mode)=mmode) then
  begin print_err("Illegal math "); print_esc("discretionary");
@.Illegal math \\disc...@>
  help2("Sorry: The third part of a discretionary break must be")@/
  ("empty, in math formulas. I had to delete your third part.");
  flush_node_list(p); n:=0; error;
  end
else link(tail):=p;
if n<=max_quarterword then replace_count(tail):=n
else  begin print_err("Discretionary list is too long");
@.Discretionary list is too long@>
  help2("Wow---I never thought anybody would tweak me here.")@/
  ("You can't seriously need such a huge discretionary list?");
  error;
  end;
if n>0 then tail:=q;
decr(save_ptr); return;
end
@y
@ @<Attach list |p| to the current...@>=
  begin
    if (n>0)and(abs(mode)=mmode) then begin
      print_err("Illegal math "); print_esc("discretionary");
@.Illegal math \\disc...@>
      help2("Sorry: The third part of a discretionary break must be")@/
      ("empty, in math formulas. I had to delete your third part.");
      flush_node_list(p); n:=0; error;
    end else link(tail):=p;
    if n<=max_quarterword then replace_count(tail):=n
    else begin
      print_err("Discretionary list is too long");
@.Discretionary list is too long@>
      help2("Wow---I never thought anybody would tweak me here.")@/
      ("You can't seriously need such a huge discretionary list?");
      error;
    end;
    if n>0 then tail:=q; decr(save_ptr);
    prev_disp:=0; prev_node:=tail;
    tail_append(get_node(small_node_size));
    type(tail):=disp_node; disp_dimen(tail):=0;
    return;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[47.1121] discretionary with disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Prune the current list, if necessary...@>=
q:=head; p:=link(q); n:=0;
while p<>null do
  begin if not is_char_node(p) then if type(p)>rule_node then
    if type(p)<>kern_node then if type(p)<>ligature_node then
      begin print_err("Improper discretionary list");
@.Improper discretionary list@>
      help1("Discretionary lists must contain only boxes and kerns.");@/
      error;
      begin_diagnostic;
      print_nl("The following discretionary sublist has been deleted:");
@.The following...deleted@>
      show_box(p);
      end_diagnostic(true);
      flush_node_list(p); link(q):=null; goto done;
      end;
  q:=p; p:=link(q); incr(n);
  end;
done:
@y
@<Prune the current list, if necessary...@>=
  q:=head; p:=link(q); n:=0;
  while p<>null do begin
    if not is_char_node(p) then
      if (type(p)>rule_node)and(type(p)<>kern_node)
             and(type(p)<>ligature_node)and(type(p)<>disp_node) then
        if (type(p)=penalty_node)and(subtype(p)<>normal) then begin
          link(q):=link(p); free_node(p,small_node_size); p:=q;
        end else begin
          print_err("Improper discretionary list");
@.Improper discretionary list@>
          help1("Discretionary lists must contain only boxes and kerns.");@/
          error;
          begin_diagnostic;
          print_nl("The following discretionary sublist has been deleted:");
@.The following...deleted@>
          show_box(p);
          end_diagnostic(true);
          flush_node_list(p); link(q):=null; goto done;
        end;
    q:=p; p:=link(q); incr(n);
  end;
done:
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1123] make_accent, Kanji, insert disp_node
%p[47.1123] make_accent, Kanji, insert disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure make_accent;
var s,@!t: real; {amount of slant}
@!p,@!q,@!r:pointer; {character, box, and kern nodes}
@!f:internal_font_number; {relevant font}
@!a,@!h,@!x,@!w,@!delta:scaled; {heights and widths, as explained above}
@!i:four_quarters; {character information}
begin scan_char_num; f:=cur_font; p:=new_character(f,cur_val);
if p<>null then
  begin x:=x_height(f); s:=slant(f)/float_constant(65536);
@^real division@>
  a:=char_width(f)(char_info(f)(character(p)));@/
  do_assignments;@/
  @<Create a character node |q| for the next character,
    but set |q:=null| if problems arise@>;
  if q<>null then @<Append the accent with appropriate kerns,
      then set |p:=q|@>;
  link(tail):=p; tail:=p; space_factor:=1000;
  end;
end;
@y
procedure make_accent;
var s,@!t: real; {amount of slant}
  @!p,@!q,@!r:pointer; {character, box, and kern nodes}
  @!f:internal_font_number; {relevant font}
  @!a,@!h,@!x,@!w,@!delta:scaled; {heights and widths, as explained above}
  @!disp:scaled; {displacement}
  @!i:four_quarters; {character information}
  @!cx:KANJI_code;
begin
  scan_char_num;
  if (cur_val<0)or(cur_val>255) then begin
    KANJI(cx):=cur_val;
    if direction=dir_tate then f:=cur_tfont else f:=cur_jfont;
    p:=new_character(f,get_jfm_pos(KANJI(cx),f));
    {DEBUG if p<>null then ...}
    link(p):=get_avail; info(link(p)):=KANJI(cx);
  end else begin
    f:=cur_font; p:=new_character(f,cur_val);
  end;
  if p<>null then begin
    x:=x_height(f); s:=slant(f)/float_constant(65536);
@^real division@>
    a:=char_width(f)(char_info(f)(character(p)));@/
    do_assignments;@/
    @<Create a character node |q| for the next character,
      but set |q:=null| if problems arise@>;
    if q<>null then
      @<Append the accent with appropriate kerns, then set |p:=q|@>;
    link(tail):=p;
    if link(p)<>null then tail:=link(p) else tail:=p;
    if disp<>0 then begin
      prev_node:=tail; prev_disp:=disp;
      tail_append(get_node(small_node_size)); type(tail):=disp_node;
      disp_dimen(tail):=0;
    end;
    space_factor:=1000;
  end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1124] make_accent Kanji, insert disp_node
%p[47.1124] make_accent Kanji, insert disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Create a character node |q| for the next...@>=
q:=null; f:=cur_font;
if (cur_cmd=letter)or(cur_cmd=other_char)or(cur_cmd=char_given) then
  q:=new_character(f,cur_chr)
else if cur_cmd=char_num then
  begin scan_char_num; q:=new_character(f,cur_val);
  end
else back_input
@y
@ @<Create a character node |q| for the next...@>=
  q:=null; f:=cur_font; KANJI(cx):=empty;
  if (cur_cmd=letter)or(cur_cmd=other_char) then q:=new_character(f,cur_chr)
  else if cur_cmd=char_given then
    if (cur_chr>=0)and(cur_chr<256)then q:=new_character(f,cur_chr)
    else begin
      if direction=dir_tate then f:=cur_tfont else f:=cur_jfont;
      KANJI(cx):=cur_chr
    end
  else if cur_cmd=char_num then begin
    scan_char_num;
    if (cur_chr>=0)and(cur_chr<256)then q:=new_character(f,cur_val)
    else begin
      if direction=dir_tate then f:=cur_tfont else f:=cur_jfont;
      KANJI(cx):=cur_chr
    end
  end else if (cur_cmd=kanji)or(cur_cmd=kana)or(cur_cmd=other_kchar) then begin
    if direction=dir_tate then f:=cur_tfont else f:=cur_jfont;
    PutHi(cx,cur_chr); get_next; PutLo(cx,cur_chr);
  end else back_input;
  if direction=dir_tate then begin
    if font_dir[f]=dir_tate then disp:=0
    else if font_dir[f]=dir_yoko then disp:=t_baseline_shift-y_baseline_shift
    else disp:=t_baseline_shift
  end else begin
    if font_dir[f]=dir_yoko then disp:=0
    else if font_dir[f]=dir_tate then disp:=y_baseline_shift-t_baseline_shift
    else disp:=y_baseline_shift
  end;
  if disp<>0 then
    if not is_char_node(tail) and type(tail)=disp_node then begin
      if prev_disp=disp then begin
        free_node(tail,small_node_size);
        tail:=prev_node;
      end else disp_dimen(tail):=disp;
    end else begin
      tail_append(get_node(small_node_size)); type(tail):=disp_node;
      disp_dimen(tail):=disp;
    end;
  if KANJI(cx)<>empty then begin
    q:=new_character(f,get_jfm_pos(KANJI(cx), f));
    link(q):=get_avail; info(link(q)):=KANJI(cx);
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[47.1125] make_accent Kanji
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
if h<>x then {the accent must be shifted up or down}
  begin p:=hpack(p,natural); shift_amount(p):=x-h;
  end;
@y
if h<>x then begin {the accent must be shifted up or down}
  delete_glue_ref(cur_kanji_skip); delete_glue_ref(cur_xkanji_skip);
  cur_kanji_skip:=zero_glue; cur_xkanji_skip:=zero_glue;
  add_glue_ref(cur_kanji_skip); add_glue_ref(cur_xkanji_skip);
  p:=hpack(p,natural); shift_amount(p):=x-h;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[48.1138] init math : direction < 0 ... math direction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
begin get_token; {|get_x_token| would fail on \.{\\ifmmode}!}
if (cur_cmd=math_shift)and(mode>0) then @<Go into display math mode@>
else  begin back_input; @<Go into ordinary math mode@>;
  end;
end;
@y
begin
  get_token; {|get_x_token| would fail on \.{\\ifmmode}!}
  if (cur_cmd=math_shift)and(mode>0) then
    @<Go into display math mode@>
  else begin
    back_input;
    @<Go into ordinary math mode@>;
  end;
  direction:=-abs(direction);
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1145] Call adjust_hlist at begin of display
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
else  begin line_break(display_widow_penalty);@/
@y
else  begin adjust_hlist(head, true); line_break(display_widow_penalty);@/
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1147] Skip kanji 2nd node
%p[48.1147] dir_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Let |d| be the natural width of node |p|...@>=
reswitch: if is_char_node(p) then
  begin f:=font(p); d:=char_width(f)(char_info(f)(character(p)));
  goto found;
  end;
case type(p) of
hlist_node,vlist_node,rule_node: begin d:=width(p); goto found;
  end;
@y
@ @<Let |d| be the natural width of node |p|...@>=
reswitch:
  if is_char_node(p) then begin
    f:=font(p); d:=char_width(f)(char_info(f)(character(p)));
    if font_dir[f]<>dir_default then p:=link(p);
    goto found;
  end;
  case type(p) of
  hlist_node,vlist_node,dir_node,rule_node:
    begin d:=width(p); goto found; end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1150] scan_math
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  back_input; scan_math(nucleus(tail));
@y
  back_input; scan_math(nucleus(tail),kcode_noad(tail));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1151] scan_math: use Kanji in math_mode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure scan_math(@!p:pointer);
label restart,reswitch,exit;
var c:integer; {math character code}
begin restart:@<Get the next non-blank non-relax...@>;
@y
procedure scan_math(@!p,@!q:pointer);
label restart,reswitch,exit;
var
  c:integer; {math character code}
  cx:KANJI_code;
begin
  KANJI(cx):=0;
restart:
  @<Get the next non-blank non-relax...@>;
@z

@x
letter,other_char,char_given: if cur_chr>=128 then c:=cur_chr
  else  begin c:=ho(math_code(cur_chr));
    if c=@'100000 then
      begin @<Treat |cur_chr| as an active character@>;
      goto restart;
      end;
    end;
@y
  letter,other_char,char_given:
    if (cur_chr>=0)and(cur_chr<=256) then begin
      if cur_chr>=128 then c:=cur_chr
      else begin
        c:=ho(math_code(cur_chr));
        if c=@'100000 then begin
          @<Treat |cur_chr| as an active character@>;
          goto restart;
        end;
      end;
    end else KANJI(cx):=cur_chr;
  kanji,kana,other_kchar:
    begin PutHi(cx,cur_chr); get_next; PutLo(cx,cur_chr); end;
@z

@x
math_type(p):=math_char; character(p):=qi(c mod 256);
if (c>=var_code)and fam_in_range then fam(p):=cur_fam
else fam(p):=(c div 256) mod 16;
exit:end;
@y
  if KANJI(cx)=0 then begin
    math_type(p):=math_char; character(p):=qi(c mod 256);
    if (c>=var_code)and fam_in_range then fam(p):=cur_fam
    else fam(p):=(c div 256) mod 16;
    if font_dir[fam_fnt(fam(p)+cur_size)]<>dir_default then begin
      print_err("Not one-byte family");
      help1("IGNORE.");@/
      error;
    end
  end else begin 
    if q=null then begin
      math_type(p):=sub_mlist; info(p):=new_noad;
      p:=nucleus(info(p)); q:=kcode_noad_nucleus(p);
    end;
    math_type(p):=math_jchar; fam(p):=cur_jfam; character(p):=qi(0);
    info(q):=KANJI(cx);
    if font_dir[fam_fnt(fam(p)+cur_size)]=dir_default then begin
      print_err("Not two-byte family");
      help1("IGNORE.");@/
      error;
    end
  end;
exit:
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1154] math mode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
mmode+letter,mmode+other_char,mmode+char_given: if cur_chr<128 then
    set_math_char(ho(math_code(cur_chr)))
  else set_math_char(cur_chr);
mmode+char_num: begin scan_char_num; cur_chr:=cur_val;
  if cur_chr<128 then set_math_char(ho(math_code(cur_chr)))
  else set_math_char(cur_chr);
@y
mmode+letter,mmode+other_char,mmode+char_given:
  if (cur_chr>=0)and(cur_chr<256) then
    if cur_chr<128 then set_math_char(ho(math_code(cur_chr)))
    else set_math_char(cur_chr)
  else set_math_kchar(cur_chr);
mmode+kanji,mmode+kana,mmode+other_kchar: begin PutHi(cx,cur_chr);
  get_next; PutLo(cx,cur_chr); set_math_kchar(KANJI(cx));
  end;
mmode+char_num: begin scan_char_num;
  if (cur_chr>=0)and(cur_chr<256) then 
  begin cur_chr:=cur_val;
    if cur_chr<128 then set_math_char(ho(math_code(cur_chr)))
    else set_math_char(cur_chr);
  end else set_math_kchar(cur_chr);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1155] set_math_char
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  link(tail):=p; tail:=p;
@y
  link(tail):=p; tail:=p;
  if font_dir[fam_fnt(fam(nucleus(p))+cur_size)]<>dir_default then begin
    print_err("Not one-byte family");
    help1("IGNORE.");@/
    error;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1158] scan_math
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  type(tail):=cur_chr; scan_math(nucleus(tail));
@y
  type(tail):=cur_chr; scan_math(nucleus(tail),kcode_noad(tail));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1163] scan_math
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
scan_delimiter(left_delimiter(tail),true); scan_math(nucleus(tail));
@y
scan_delimiter(left_delimiter(tail),true);
scan_math(nucleus(tail),kcode_noad(tail));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1164] scan_math
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
scan_math(nucleus(tail));
@y
scan_math(nucleus(tail),kcode_noad(tail));
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[48.1164] vcenter : dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Cases of |handle...@>=
vcenter_group: begin end_graf; unsave; save_ptr:=save_ptr-2;
  p:=vpack(link(head),saved(1),saved(0)); pop_nest;
  tail_append(new_noad); type(tail):=vcenter_noad;
  math_type(nucleus(tail)):=sub_box; info(nucleus(tail)):=p;
  end;
@y
@ @<Cases of |handle...@>=
  vcenter_group:
    begin
      end_graf; unsave; save_ptr:=save_ptr-2;
      p:=vpack(link(head),saved(1),saved(0));
      box_dir(p):=abs(direction); pop_nest;
      if box_dir(p)<>abs(direction) then
        p:=new_dir_node(p, abs(direction));
      tail_append(new_noad); type(tail):=vcenter_noad;
      math_type(nucleus(tail)):=sub_box; info(nucleus(tail)):=p;
    end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1176] scan_math
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
scan_math(p);
@y
scan_math(p,null);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1186] copy kanji code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
     if math_type(supscr(p))=empty then
      begin mem[saved(0)].hh:=mem[nucleus(p)].hh;
@y
     if ((math_type(supscr(p))=empty)and(math_kcode(p)=null)) then
      begin mem[saved(0)].hh:=mem[nucleus(p)].hh;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1194] set cur_kanji_skip, cur_xkanji_skip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure after_math;
var l:boolean; {`\.{\\leqno}' instead of `\.{\\eqno}'}
@!danger:boolean; {not enough symbol fonts are present}
@!m:integer; {|mmode| or |-mmode|}
@!p:pointer; {the formula}
@!a:pointer; {box containing equation number}
@<Local variables for finishing a displayed formula@>@;
begin danger:=false;
@<Check that the necessary fonts for math symbols are present;
  if not, flush the current math lists and set |danger:=true|@>;
m:=mode; l:=false; p:=fin_mlist(null); {this pops the nest}
if mode=-m then {end of equation number}
@y
procedure after_math;
var l:boolean; {`\.{\\leqno}' instead of `\.{\\eqno}'}
  @!danger:boolean; {not enough symbol fonts are present}
  @!m:integer; {|mmode| or |-mmode|}
  @!p:pointer; {the formula}
  @!a:pointer; {box containing equation number}
  @!disp:scaled; {displacement}
  @<Local variables for finishing a displayed formula@>@;
begin
  danger:=false;
  @<Check that the necessary fonts for math symbols are present;
    if not, flush the current math lists and set |danger:=true|@>;
  delete_glue_ref(cur_kanji_skip); delete_glue_ref(cur_xkanji_skip);
  if auto_spacing>0 then cur_kanji_skip:=kanji_skip
  else cur_kanji_skip:=zero_glue;
  if auto_xspacing>0 then cur_xkanji_skip:=xkanji_skip
  else cur_xkanji_skip:=zero_glue;
  add_glue_ref(cur_kanji_skip); add_glue_ref(cur_xkanji_skip);
  m:=mode; l:=false; p:=fin_mlist(null); {this pops the nest}
  if mode=-m then {end of equation number}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[48.1196] insert disp_node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Finish math in text@>=
begin tail_append(new_math(math_surround,before));
cur_mlist:=p; cur_style:=text_style; mlist_penalties:=(mode>0); mlist_to_hlist;
link(tail):=link(temp_head);
while link(tail)<>null do tail:=link(tail);
tail_append(new_math(math_surround,after));
space_factor:=1000; unsave;
end
@y
@<Finish math in text@>=
  begin
    if direction=dir_tate then
      disp:=axis_height(text_size)
    else disp:=0;
    if disp<>0 then
      if (not is_char_node(tail)) and type(tail)=disp_node then begin
        if prev_disp=disp then begin
          free_node(tail,small_node_size);
          tail:=prev_node;
        end else disp_dimen(tail):=disp;
      end else begin
        tail_append(get_node(small_node_size)); type(tail):=disp_node;
        disp_dimen(tail):=disp;
      end;
    tail_append(new_math(math_surround,before));
    cur_mlist:=p; cur_style:=text_style;
    mlist_penalties:=(mode>0); mlist_to_hlist;
    link(tail):=link(temp_head);
    while link(tail)<>null do tail:=link(tail);
    tail_append(new_math(math_surround,after));
    if disp<>0 then begin
      prev_node:=tail; prev_disp:=disp;
      tail_append(get_node(small_node_size)); type(tail):=disp_node;
      disp_dimen(tail):=0;
    end;
    space_factor:=1000; unsave;
  end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[48.1200] adjust direction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure resume_after_display;
begin if cur_group<>math_shift_group then confusion("display");
@:this can't happen display}{\quad display@>
unsave; prev_graf:=prev_graf+3;
push_nest; mode:=hmode; space_factor:=1000;
@<Scan an optional space@>;
if nest_ptr=1 then build_page;
end;
@y
procedure resume_after_display;
begin
  if cur_group<>math_shift_group then confusion("display");
@:this can't happen display}{\quad display@>
  unsave; prev_graf:=prev_graf+3;
  push_nest; adjust_dir:=abs(direction);
  mode:=hmode; space_factor:=1000;
  @<Scan an optional space@>;
  if nest_ptr=1 then build_page;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[48.1201] free box node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
   (total_shrink[filll]<>0)) then
  begin free_node(b,box_node_size);
  b:=hpack(p,z-q,exactly);
@y
   (total_shrink[filll]<>0)) then
  begin
  delete_glue_ref(space_ptr(b));
  delete_glue_ref(xspace_ptr(b));
  free_node(b,box_node_size);
  b:=hpack(p,z-q,exactly);
@z

@x
  if w>z then
    begin free_node(b,box_node_size);
    b:=hpack(p,z,exactly);
@y
  if w>z then
    begin
    delete_glue_ref(space_ptr(b));
    delete_glue_ref(xspace_ptr(b));
    free_node(b,box_node_size);
    b:=hpack(p,z,exactly);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[49.1210] set_auto_spacing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ Every prefix, and every command code that might or might not be prefixed,
calls the action procedure |prefixed_command|. This routine accumulates
a sequence of prefixes until coming to a non-prefix, then it carries out
the command.

@<Cases of |main_control| that don't...@>=
any_mode(toks_register),
any_mode(assign_toks),
any_mode(assign_int),
@y
@ Every prefix, and every command code that might or might not be prefixed,
calls the action procedure |prefixed_command|. This routine accumulates
a sequence of prefixes until coming to a non-prefix, then it carries out
the command.

@<Cases of |main_control| that don't...@>=
any_mode(assign_kinsoku),
any_mode(assign_inhibit_xsp_code),
any_mode(set_auto_spacing),
any_mode(toks_register),
any_mode(assign_toks),
any_mode(assign_int),
any_mode(def_jfont),
any_mode(def_tfont),
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1214] dword_define
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d global==(a>=4)
@d define(#)==if global then geq_define(#)@+else eq_define(#)
@d word_define(#)==if global then geq_word_define(#)@+else eq_word_define(#)
@y
@d global==(a>=4)
@d define(#)==if global then geq_define(#)@+else eq_define(#)
@d word_define(#)==if global then geq_word_define(#)@+else eq_word_define(#)
@d dword_define(#)==if global then geq_dword_define(#)@+else eq_dword_define(#)
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[49.1217] select cur font
%p[49.1217] select cur font
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@<Assignments@>=
set_font: define(cur_font_loc,data,cur_chr);

@y
@<Assignments@>=
set_font:
  begin
    if font_dir[cur_chr]=dir_yoko then
      define(cur_jfont_loc,data,cur_chr)
    else if font_dir[cur_chr]=dir_tate then
      define(cur_tfont_loc,data,cur_chr)
    else
      define(cur_font_loc,data,cur_chr)
  end;

@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[49.1228] assign jfam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
assign_int: begin p:=cur_chr; scan_optional_equals; scan_int;
  word_define(p,cur_val);
  end;
@y
assign_int:
  begin
    p:=cur_chr; scan_optional_equals; scan_int;
    if p=int_base+cur_fam_code then begin
      if font_dir[fam_fnt(cur_val)]<>dir_default then
        word_define(p+1, cur_val)
      else word_define(p,cur_val);
    end else word_define(p,cur_val);
  end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[49.1230][49.1231] xspcode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
primitive("catcode",def_code,cat_code_base);
@!@:cat_code_}{\.{\\catcode} primitive@>
@y
primitive("catcode",def_code,cat_code_base);
@!@:cat_code_}{\.{\\catcode} primitive@>
primitive("xspcode",def_code,auto_xsp_code_base);
@!@:auto_xsp_code_}{\.{\\xspcode} primitive@>
@z

@x
def_code: if chr_code=cat_code_base then print_esc("catcode")
  else if chr_code=math_code_base then print_esc("mathcode")
@y
def_code: if chr_code=cat_code_base then print_esc("catcode")
  else if chr_code=auto_xsp_code_base then print_esc("xspcode")
  else if chr_code=math_code_base then print_esc("mathcode")
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p[49.1247] alter_box_dimen : box_dir
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
procedure alter_box_dimen;
var c:small_number; {|width_offset| or |height_offset| or |depth_offset|}
@!b:eight_bits; {box number}
begin c:=cur_chr; scan_eight_bit_int; b:=cur_val; scan_optional_equals;
scan_normal_dimen;
if box(b)<>null then mem[box(b)+c].sc:=cur_val;
end;
@y
procedure alter_box_dimen;
var c:small_number; {|width_offset| or |height_offset| or |depth_offset|}
  @!b:eight_bits; {box number}
  @!p,q:pointer;
begin
  c:=cur_chr; scan_eight_bit_int; b:=cur_val; scan_optional_equals;
  scan_normal_dimen;
  if box(b)<>null then begin
    q:=box(b); p:=link(q);
    while p<>null do begin
      if abs(direction)=box_dir(p) then
        q:=p;
      p:=link(p);
    end;
    if box_dir(q)<>abs(direction) then begin
      q:=new_dir_node(q,abs(direction)); list_ptr(q):=null;
      link(q):=link(box(b)); link(box(b)):=q;
    end;
    mem[q+c].sc:=cur_val;
  end;
end;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[49.1256] def_jfont
%p[49.1256] def_tfont
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
def_font: new_font(a);
@y
def_tfont,def_jfont,def_font: new_font(a);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [49.1275] a_open_in of \read file needs path specifier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
  if a_open_in(read_file[n]) then read_open[n]:=just_open;
@y
  if a_open_in(read_file[n],read_path_spec) then read_open[n]:=just_open;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[49.1289] shift_case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
t:=info(p);
if t<cs_token_flag+single_base then
  begin if t>=cs_token_flag then t:=t-active_base;
@y
t:=info(p);
if t<cs_token_flag+single_base then
  if (t>kanji_token_base)and(t<kanji_token_end) then p:=link(p)
  else begin
    if t>=cs_token_flag then t:=t-active_base;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[49.1291] show_mode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d show_lists=3 { \.{\\showlists} }
@y
@d show_lists=3 { \.{\\showlists} }
@d show_mode=4 { \.{\\showmode} }
@z

@x
primitive("showlists",xray,show_lists);
@!@:show_lists_}{\.{\\showlists} primitive@>
@y
primitive("showlists",xray,show_lists);
@!@:show_lists_}{\.{\\showlists} primitive@>
primitive("showmode",xray,show_mode);
@!@:show_mode_}{\.{\\showmode} primitive@>
@z

@x
  show_lists:print_esc("showlists");
  othercases print_esc("show")
@y
  show_lists:print_esc("showlists");
  show_mode:print_esc("showmode");
  othercases print_esc("show")
@z

@x
show_box_code: @<Show the current contents of a box@>;
show_code: @<Show the current meaning of a token, then |goto common_ending|@>;
@y
show_box_code: @<Show the current contents of a box@>;
show_code: @<Show the current meaning of a token, then |goto common_ending|@>;
show_mode: @<Show the courent japanese prcessing mode@>;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1302] Eliminate unused variable w in |store_fmt_file|
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@!init procedure store_fmt_file;
label found1,found2,done1,done2;
var j,@!k,@!l:integer; {all-purpose indices}
@!p,@!q: pointer; {all-purpose pointers}
@!x: integer; {something to dump}
@!w: four_quarters; {four ASCII codes}
@y
@!init procedure store_fmt_file;
label found1,found2,done1,done2;
var j,@!k,@!l:integer; {all-purpose indices}
@!p,@!q: pointer; {all-purpose pointers}
@!x: integer; {something to dump}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1303] Eliminate unused variable w in |load_fmt_file|
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@p @t\4@>@<Declare the function called |open_fmt_file|@>@;
function load_fmt_file:boolean;
label bad_fmt,exit;
var j,@!k:integer; {all-purpose indices}
@!p,@!q: pointer; {all-purpose pointers}
@!x: integer; {something undumped}
@!w: four_quarters; {four ASCII codes}
@y
@p @t\4@>@<Declare the function called |open_fmt_file|@>@;
function load_fmt_file:boolean;
label bad_fmt,exit;
var j,@!k:integer; {all-purpose indices}
@!p,@!q: pointer; {all-purpose pointers}
@!x: integer; {something undumped}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1305] Fix reading and writing fmt_file for C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@d dump_wd(#)==begin fmt_file^:=#; put(fmt_file);@+end
@d dump_int(#)==begin fmt_file^.int:=#; put(fmt_file);@+end
@d dump_hh(#)==begin fmt_file^.hh:=#; put(fmt_file);@+end
@d dump_qqqq(#)==begin fmt_file^.qqqq:=#; put(fmt_file);@+end
@y
@d dump_wd(#)==put_fmt_word(#)
@d dump_int(#)==put_fmt_int(#)
@d dump_hh(#)==put_fmt_hh(#)
@d dump_qqqq(#)==put_fmt_qqqq(#)
@z

@x
@d undump_wd(#)==begin get(fmt_file); #:=fmt_file^;@+end
@d undump_int(#)==begin get(fmt_file); #:=fmt_file^.int;@+end
@d undump_hh(#)==begin get(fmt_file); #:=fmt_file^.hh;@+end
@d undump_qqqq(#)==begin get(fmt_file); #:=fmt_file^.qqqq;@+end
@y
@d undump_wd(#)==get_fmt_word(#)
@d undump_int(#)==get_fmt_int(#)
@d undump_hh(#)==get_fmt_hh(#)
@d undump_qqqq(#)==get_fmt_qqqq(#)
@z

@x
x:=fmt_file^.int;
@y
get_fmt_int(x);		{This is reading the first word of the fmt file}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1309][50.1310] dump & undump string_pool
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
for k:=0 to str_ptr do dump_int(str_start[k]);
k:=0;
while k+4<pool_ptr do
  begin dump_four_ASCII; k:=k+4;
  end;
k:=pool_ptr-4; dump_four_ASCII;
@y
dump_things(str_start[0], str_ptr+1);
dump_things(str_pool[0], pool_ptr);
@z

@x
for k:=0 to str_ptr do undump(0)(pool_ptr)(str_start[k]);
k:=0;
while k+4<pool_ptr do
  begin undump_four_ASCII; k:=k+4;
  end;
k:=pool_ptr-4; undump_four_ASCII
@y
undump_things(str_start[0], str_ptr+1);
undump_things(str_pool[0], pool_ptr);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1311][50.1312] dump & undump dynamic_memory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
repeat for k:=p to q+1 do dump_wd(mem[k]);
x:=x+q+2-p; var_used:=var_used+q-p;
p:=q+node_size(q); q:=rlink(q);
until q=rover;
var_used:=var_used+lo_mem_max-p; dyn_used:=mem_end+1-hi_mem_min;@/
for k:=p to lo_mem_max do dump_wd(mem[k]);
x:=x+lo_mem_max+1-p;
dump_int(hi_mem_min); dump_int(avail);
for k:=hi_mem_min to mem_end do dump_wd(mem[k]);
@y
repeat
 dump_things(mem[p], q+2-p);
x:=x+q+2-p; var_used:=var_used+q-p;
p:=q+node_size(q); q:=rlink(q);
until q=rover;
var_used:=var_used+lo_mem_max-p; dyn_used:=mem_end+1-hi_mem_min;@/
dump_things(mem[p], lo_mem_max+1-p);
x:=x+lo_mem_max+1-p;
dump_int(hi_mem_min); dump_int(avail);
dump_things(mem[hi_mem_min], mem_end+1-hi_mem_min);
@z

@x
repeat for k:=p to q+1 do undump_wd(mem[k]);
p:=q+node_size(q);
if (p>lo_mem_max)or((q>=rlink(q))and(rlink(q)<>rover)) then goto bad_fmt;
q:=rlink(q);
until q=rover;
for k:=p to lo_mem_max do undump_wd(mem[k]);
@y
repeat
  undump_things(mem[p], q+2-p);
p:=q+node_size(q);
if (p>lo_mem_max)or((q>=rlink(q))and(rlink(q)<>rover)) then goto bad_fmt;
q:=rlink(q);
until q=rover;
undump_things(mem[p], lo_mem_max+1-p);
@z

@x
for k:=hi_mem_min to mem_end do undump_wd(mem[k]);
@y
undump_things(mem[hi_mem_min], mem_end+1-hi_mem_min);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1315]-[50.1317] dump,umdump 1 to 6 of eqtb
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
while k<l do
  begin dump_wd(eqtb[k]); incr(k);
  end;
@y
dump_things(eqtb[k], l-k);
@z

@x
while k<l do
  begin dump_wd(eqtb[k]); incr(k);
  end;
@y
dump_things(eqtb[k], l-k);
@z

@x
for j:=k to k+x-1 do undump_wd(eqtb[j]);
@y
undump_things(eqtb[k], x);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1318][50.1319] dump,umdump hash table
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
for p:=hash_used+1 to undefined_control_sequence-1 do dump_hh(hash[p]);
@y
dump_things(hash[hash_used+1], undefined_control_sequence-1-hash_used);
@z

@x
for p:=hash_used+1 to undefined_control_sequence-1 do undump_hh(hash[p]);
@y
undump_things(hash[hash_used+1], undefined_control_sequence-1-hash_used);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1322][50.1323] dump,umdump font_dir[]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
for k:=0 to fmem_ptr-1 do dump_wd(font_info[k]);
dump_int(font_ptr);
for k:=null_font to font_ptr do
  @<Dump the array info for internal font number |k|@>;
@y
@<Dump the array info for internal font number |k|@>;
@z

@x
for k:=0 to fmem_ptr-1 do undump_wd(font_info[k]);
undump_size(font_base)(font_max)('font max')(font_ptr);
for k:=null_font to font_ptr do
  @<Undump the array info for internal font number |k|@>
@y
@<Undump the array info for internal font number |k|@>;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1322] Writing font info (almost at end of dump stuff)
%j[50.1322] ctype_base[]
%p[50.1322] font_dir[]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Knuth's code writes all the information relevant to a single font
% in the same section of the fmt file.  But it's a lot faster to
% write the arrays of information out, one whole array at a time.
% So that's the way we handle dumping and undumping font info.
@x
@ @<Dump the array info for internal font number |k|@>=
begin dump_qqqq(font_check[k]);
dump_int(font_size[k]);
dump_int(font_dsize[k]);
dump_int(font_params[k]);@/
dump_int(hyphen_char[k]);
dump_int(skew_char[k]);@/
dump_int(font_name[k]);
dump_int(font_area[k]);@/
dump_int(font_bc[k]);
dump_int(font_ec[k]);@/
dump_int(char_base[k]);
dump_int(width_base[k]);
dump_int(height_base[k]);@/
dump_int(depth_base[k]);
dump_int(italic_base[k]);
dump_int(lig_kern_base[k]);@/
dump_int(kern_base[k]);
dump_int(exten_base[k]);
dump_int(param_base[k]);@/
dump_int(font_glue[k]);@/
print_nl("\font"); print_esc(font_id_text(k)); print_char("=");
print_file_name(font_name[k],font_area[k],"");
if font_size[k]<>font_dsize[k] then
  begin print(" at "); print_scaled(font_size[k]); print("pt");
  end;
end
@y
@ @<Dump the array info for internal font number |k|@>=
begin dump_things(font_info[0], fmem_ptr);
dump_int(font_ptr);
dump_things(font_dir[null_font], font_ptr+1-null_font);
dump_things(ctype_base[null_font], font_ptr+1-null_font);
dump_things(font_check[null_font], font_ptr+1-null_font);
dump_things(font_size[null_font], font_ptr+1-null_font);
dump_things(font_dsize[null_font], font_ptr+1-null_font);
dump_things(font_params[null_font], font_ptr+1-null_font);
dump_things(font_num_ext[null_font], font_ptr+1-null_font);
dump_things(hyphen_char[null_font], font_ptr+1-null_font);
dump_things(skew_char[null_font], font_ptr+1-null_font);
dump_things(font_name[null_font], font_ptr+1-null_font);
dump_things(font_area[null_font], font_ptr+1-null_font);
dump_things(font_bc[null_font], font_ptr+1-null_font);
dump_things(font_ec[null_font], font_ptr+1-null_font);
dump_things(char_base[null_font], font_ptr+1-null_font);
dump_things(width_base[null_font], font_ptr+1-null_font);
dump_things(height_base[null_font], font_ptr+1-null_font);
dump_things(depth_base[null_font], font_ptr+1-null_font);
dump_things(italic_base[null_font], font_ptr+1-null_font);
dump_things(lig_kern_base[null_font], font_ptr+1-null_font);
dump_things(kern_base[null_font], font_ptr+1-null_font);
dump_things(exten_base[null_font], font_ptr+1-null_font);
dump_things(param_base[null_font], font_ptr+1-null_font);
dump_things(font_glue[null_font], font_ptr+1-null_font);
for k:=null_font to font_ptr do begin
  print_nl("\font"); print_esc(font_id_text(k)); print_char("=");
  print_file_name(font_name[k],font_area[k],"");
  if font_size[k]<>font_dsize[k] then begin
    print(" at "); print_scaled(font_size[k]); print("pt");
  end;
end;
end
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [50.1322] Reading font info for C (Nearly done with undump stuff)
%j[50.1322] ctype_base[]
%p[50.1322] font_dir[]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ @<Undump the array info for internal font number |k|@>=
begin undump_qqqq(font_check[k]);@/
undump_int(font_size[k]);
undump_int(font_dsize[k]);
undump(min_halfword)(max_halfword)(font_params[k]);@/
undump_int(hyphen_char[k]);
undump_int(skew_char[k]);@/
undump(0)(str_ptr)(font_name[k]);
undump(0)(str_ptr)(font_area[k]);@/
undump(0)(255)(font_bc[k]);
undump(0)(255)(font_ec[k]);@/
undump_int(char_base[k]);
undump_int(width_base[k]);
undump_int(height_base[k]);@/
undump_int(depth_base[k]);
undump_int(italic_base[k]);
undump_int(lig_kern_base[k]);@/
undump_int(kern_base[k]);
undump_int(exten_base[k]);
undump_int(param_base[k]);@/
undump(min_halfword)(lo_mem_max)(font_glue[k]);
end
@y
@  The way this is done in C makes the reference to
the internal font number meaningless, but putting the code
here preserves the association with the WEB modules.

@<Undump the array info for internal font number |k|@>=
begin undump_things(font_info[0], fmem_ptr);
undump_size(font_base)(font_max)('font max')(font_ptr);
undump_things(font_dir[null_font], font_ptr+1-null_font);
undump_things(ctype_base[null_font], font_ptr+1-null_font);
undump_things(font_check[null_font], font_ptr+1-null_font);
undump_things(font_size[null_font], font_ptr+1-null_font);
undump_things(font_dsize[null_font], font_ptr+1-null_font);
undump_things(font_params[null_font], font_ptr+1-null_font);
undump_things(font_num_ext[null_font], font_ptr+1-null_font);
undump_things(hyphen_char[null_font], font_ptr+1-null_font);
undump_things(skew_char[null_font], font_ptr+1-null_font);
undump_things(font_name[null_font], font_ptr+1-null_font);
undump_things(font_area[null_font], font_ptr+1-null_font);
undump_things(font_bc[null_font], font_ptr+1-null_font);
undump_things(font_ec[null_font], font_ptr+1-null_font);
undump_things(char_base[null_font], font_ptr+1-null_font);
undump_things(width_base[null_font], font_ptr+1-null_font);
undump_things(height_base[null_font], font_ptr+1-null_font);
undump_things(depth_base[null_font], font_ptr+1-null_font);
undump_things(italic_base[null_font], font_ptr+1-null_font);
undump_things(lig_kern_base[null_font], font_ptr+1-null_font);
undump_things(kern_base[null_font], font_ptr+1-null_font);
undump_things(exten_base[null_font], font_ptr+1-null_font);
undump_things(param_base[null_font], font_ptr+1-null_font);
undump_things(font_glue[null_font], font_ptr+1-null_font);
end
@z

@x
for k:=0 to trie_max do dump_hh(trie[k]);
dump_int(trie_op_ptr);
for k:=min_quarterword+1 to trie_op_ptr do
  begin dump_int(hyf_distance[k]);
  dump_int(hyf_num[k]);
  dump_int(hyf_next[k]);
  end;
@y
dump_things(trie[0], trie_max+1);
dump_int(trie_op_ptr);
dump_things(hyf_distance[min_quarterword+1], trie_op_ptr-min_quarterword);
dump_things(hyf_num[min_quarterword+1], trie_op_ptr-min_quarterword);
dump_things(hyf_next[min_quarterword+1], trie_op_ptr-min_quarterword);
@z

@x
for k:=0 to trie_max do undump_hh(trie[k]);
undump(min_quarterword)(max_quarterword)(trie_op_ptr);
for k:=min_quarterword+1 to trie_op_ptr do
  begin undump(0)(63)(hyf_distance[k]); {a |small_number|}
  undump(0)(63)(hyf_num[k]);
  undump(min_quarterword)(max_quarterword)(hyf_next[k]);
  end
@y
undump_things(trie[0], trie_max+1);
undump(min_quarterword)(max_quarterword)(trie_op_ptr);
undump_things(hyf_distance[min_quarterword+1], trie_op_ptr-min_quarterword);
undump_things(hyf_num[min_quarterword+1], trie_op_ptr-min_quarterword);
undump_things(hyf_next[min_quarterword+1], trie_op_ptr-min_quarterword);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [51.1332] uexit() call depends on `history'; procedure-ize main prog;
%	Also, add call to set_paths
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
@ Now this is really it: \TeX\ starts and ends here.

The initial test involving |ready_already| should be deleted if the
\PASCAL\ runtime system is smart enough to detect such a ``mistake.''
@y
@ Now this is really it: \TeX\ starts and ends here.

Use the value of |history| to determine what exit-code to use.  We use
1 if |history <> spotless| and 0 otherwise.

@z

@x
@p begin @!{|start_here|}
history:=fatal_error_stop; {in case we quit during initialization}
t_open_out; {open the terminal for output}
@y
@p procedure tex_body;
label @<Labels in the outer block@>@/
var bufindx:0..buf_size; {an index used in a for loop below}
begin @!{|start_here|}
history:=fatal_error_stop; {in case we quit during initialization}
t_open_out; {open the terminal for output}
set_paths; {get default file paths from the Unix environment}
@z

@x
final_end: ready_already:=0;
end.
@y
final_end: do_final_end;
end {tex_body};
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [51.1333] omit call to wake_up_terminal on normal termination
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
wake_up_terminal; @<Finish the \.{DVI} file@>;
@y
@<Finish the \.{DVI} file@>;
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [51.1333] print new line before termination; switch to editor if nec.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@x
    print(log_name); print_char(".");
    end;
  end;
@y
    print(log_name); print_char(".");
    end;
  end;
print_ln;
if (edit_name_start<>0) and (interaction>batch_mode) then
    calledit(str_pool,edit_name_start,edit_name_length,edit_line);
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [52.1338] Core-dump in debugging mode on 0 input
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% In Unix, it's not possible to switch into the debugger while a program
% is running.  The best approximation is to do a core dump, then run
% the debugger on it later.
@x
    begin goto breakpoint;@\ {go to every label at least once}
    breakpoint: m:=0; @{'BREAKPOINT'@}@\
    end
@y
    dump_core {Do something to cause a core dump}
@z

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [54] System-dependent changes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [54.1376] add editor-switch variables to globals
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[54.check_box]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% box_p ‚ÌŽw‚·ƒŠƒXƒg‚ðÄ‹A“I‚ÉƒT[ƒ`‚µ‚ÄA
% ˆóŽš‚·‚é‚à‚Ì‚ª“ü‚Á‚Ä‚¢‚ê‚Î true ‚ð•Ô‚·B
% Å‰‚ÉŒ©‚Â‚¯‚½ˆóŽš‚·‚é‚à‚Ì‚ª•¶Žš‚Å‚ ‚ê‚Î first_char ‚Å‚»‚ê‚ðŽ¦‚µA
% •¶Žš‚Å‚È‚¯‚ê‚Î first_char ‚Í null ‚É‚È‚éB
% ÅŒã‚ÉŒ©‚Â‚¯‚½ˆóŽš‚·‚é‚à‚Ì‚ÉŠÖ‚µ‚Ä‚Í last_charB
%	adjust_hlist ‚©‚çŒÄ‚Î‚ê‚éB
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%j[54.adjust_hlist]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%p ‚ÌŽw‚· hƒŠƒXƒg ‚ÌŠ¿Žš‚Æ‰pŽš‚ÌÚ‚·‚é•”•ª‚ÉA\xkanjiskip ‚ð‘}“ü‚·‚éB
%\kanjiskip ‚ð“ü‚ê‚é‚±‚Æ‚ª’Pƒ‚É”»’f‚Å‚«‚È‚¢•”•ªiƒyƒiƒ‹ƒeƒB‚Ì‘OŒã‚È‚Çj‚É‚ÍA
%‚ ‚ç‚©‚¶‚ß \kanjiskip ‚ð“ü‚ê‚Ä‚¨‚­B
%pf ‚ª true ‚Ìê‡‚ÍAjchar_widow_penalty ‚à‘}“ü‚·‚éB

@x
This section should be replaced, if necessary, by changes to the program
that are necessary to make \TeX\ work at a particular installation.
It is usually best to design your change file so that all changes to
previous sections preserve the section numbering; then everybody's version
will be consistent with the published program. More extensive changes,
which introduce new sections, can be inserted here; then only the index
itself will get a new section number.
@^system dependencies@>
@y
Here is a temporary integer, used as a holder during reading and writing of
TFM files, and a temporary memory_word, used in reading/writing format
files.
Also, the variables used to hold ``switch-to-editor'' information.
@^<system dependencies@>

@<Glob...@>=
@!edit_name_start: pool_pointer;
@!edit_name_length,@!edit_line,@!tfm_temp: integer;

@ The |edit_name_start| will be set to point into |str_pool| somewhere after
its beginning if \TeX\ is supposed to switch to an editor on exit.

@<Set init...@>=
edit_name_start:=0;

@ @d reset_auto_spacing_code=0
@d set_auto_spacing_code=1
@d reset_auto_xspacing_code=2
@d set_auto_xspacing_code=3

@<Put each...@>=
primitive("autospacing",set_auto_spacing,set_auto_spacing_code);
@!@:auto_spacing_}{\.{\\autospacing} primitive@>
primitive("noautospacing",set_auto_spacing,reset_auto_spacing_code);
@!@:no_auto_spacing_}{\.{\\noautospacing} primitive@>
primitive("autoxspacing",set_auto_spacing,set_auto_xspacing_code);
@!@:auto_xspacing_}{\.{\\autoxspacing} primitive@>
primitive("noautoxspacing",set_auto_spacing,reset_auto_xspacing_code);
@!@:no_auto_xspacing_}{\.{\\noautoxspacing} primitive@>

@ @<Assignments@>=
set_auto_spacing:begin
  if cur_chr<2 then p:=auto_spacing_code
  else begin p:=auto_xspacing_code; cur_chr:=(cur_chr mod 2); end;
  define(p, data, cur_chr);
end;

@ @<Cases of |print_cmd_chr|...@>=
set_auto_spacing:begin
  if (chr_code mod 2)=0 then print_esc("noauto") else print_esc("auto");
  if chr_code<2 then print("spacing") else print("xspacing");
end;

@ @<Show the courent japanese prcessing mode@>=
begin print_nl("> ");
if auto_spacing>0 then print("auto spacing mode; ")
  else print("no auto spacing mode; ");
print_nl("> ");
if auto_xspacing>0 then print("auto xspacing mode")
  else print("no auto xspacing mode");
goto common_ending;
end

@ @<Glob...@>=
@!first_char,@!last_char:pointer;
@!find_first:boolean;

@ @<Declare procedures needed in |hlist_out|, |vlist_out|@>=
function check_box(box_p:pointer):boolean;
label done;
var @!p:pointer;
  @!flag:boolean;
begin
  flag:=false; p:=box_p;
  while p <> null do begin
    if is_char_node(p) then
      repeat
        if find_first then begin
          first_char:=p; find_first:=false
        end;
        last_char:=p;
        flag:=true;
        if font_dir[font(p)]<>dir_default then p:=link(p);
        p:=link(p);
        if p=null then goto done;
      until not is_char_node(p);
    case type(p) of
    hlist_node:
      begin
        if shift_amount(p)=0 then begin
          if check_box(list_ptr(p)) then flag:=true;
        end else if find_first then find_first:=false
        else last_char:=null;
        flag:=true;
      end;
    ligature_node:
      if check_box(lig_ptr(p)) then flag:=true;
    penalty_node,mark_node,adjust_node,ins_node,whatsit_node,disp_node:
      do_nothing;
    othercases
      begin
        if find_first then find_first:=false
        else last_char:=null;
        flag:=true;
      end;
    endcases;
    p:=link(p);
  end;
done:
  check_box:=flag;
end;

@ @<Declare procedures needed in |hlist_out|, |vlist_out|@>=
procedure adjust_hlist(p:pointer;pf:boolean);
label done1;
var q,s,t,u,v,x,z:pointer;
  i,k:halfword;
  last:-1..1;
  xsp:0..3;
  j:KANJI_code;
  f:boolean;
begin
  if link(p)=null then goto done1;
  if auto_spacing>0 then begin
    delete_glue_ref(space_ptr(p));
    space_ptr(p):=kanji_skip; add_glue_ref(kanji_skip);
  end;
  if auto_xspacing>0 then begin
    delete_glue_ref(xspace_ptr(p));
    xspace_ptr(p):=xkanji_skip; add_glue_ref(xkanji_skip);
  end;
  s:=xspace_ptr(p); add_glue_ref(s); u:=space_ptr(p); add_glue_ref(u);
  i:=0; last:=0;
  if (not is_char_node(link(p))) {p1.0.9d}
      and(type(link(p))=glue_node)and(subtype(link(p))=jfm_skip+1) then begin
    v:=link(p); link(p):=link(v);
    fast_delete_glue_ref(glue_ptr(v)); free_node(v,small_node_size);
  end;
  p:=link(p); v:=p; q:=p;
  while p<>null do begin
    if is_char_node(p) then begin
      repeat
        @<Insert xkanji_skip@>
      until not is_char_node(p)
    end else begin
      case type(p) of
      hlist_node:
        @<Insert hbox surround spacing@>;
      ligature_node:
        @<Insert ligature surround spacing@>;
      penalty_node, disp_node:
        @<Insert node surround spacing@>;
      math_node,mark_node,adjust_node,ins_node,whatsit_node:
        {These nodes are vanished when typeset is done}
        do_nothing;
      othercases
        last:=0;
      endcases;
      q:=p; p:=link(p);
    end;
  end;
  if (not is_char_node(q))
      and(type(q)=glue_node)and(subtype(q)=jfm_skip+1) then begin
    fast_delete_glue_ref(glue_ptr(q));
    glue_ptr(q):=zero_glue; add_glue_ref(zero_glue);
  end;
  delete_glue_ref(s); delete_glue_ref(u);
  if (v<>null)and(pf) then begin
    @<Seek list and make |t| pointing widow penalty position@>;
    if s<>null then begin
      s:=new_penalty(jchr_widow_penalty); link(s):=link(t); link(t):=s;
      subtype(s):=widow_pena; 
      t:=link(s);
      while(not is_char_node(t)) do begin
        if (type(t)=glue_node)or(type(t)=kern_node) then goto done1;
        t:=link(t);
      end;
      z:=new_glue(u); subtype(z):=kanji_skip_code+1;
      link(z):=link(s); link(s):=z;
    end;
  end;
done1:
end;
  
@ @<Insert xkanji_skip@>=
  if font_dir[font(p)]<>dir_default then begin
    KANJI(j):=info(link(p));
    if last<0 then @<Insert ASCII-KANJI spacing@>;
    last:=1; p:=link(p);
  end else begin
    xsp:=auto_xsp_code(qo(character(p)));
    if (xsp mod 2)=1 then begin
      if last>0 then @<Insert KANJI-ASCII spacing@>;
    end;
    if xsp>=2 then last:=-1 else last:=0;
  end;
  q:=p; p:=link(p); incr(i);
  if (i>5)and(pf) then begin
    if is_char_node(v) then
      if font_dir[font(v)]<>dir_default then v:=link(v);
    v:=link(v);
  end

@ @<Insert hbox surround spacing@>=
  begin
    find_first:=true;
    first_char:=null; last_char:=null;
    if shift_amount(p)=0 then begin
      if check_box(list_ptr(p)) then begin
        if first_char <> null then 
          if font_dir[font(first_char)]<>dir_default then begin
            KANJI(j):=info(link(first_char));
            if last<0 then @<Insert ASCII-KANJI spacing@>;
          end else begin
            if last>0 then
              if (auto_xsp_code(qo(character(first_char))) mod 2)=1 then
                @<Insert KANJI-ASCII spacing@>;
          end;
        if last_char <> null then begin
          if font_dir[font(last_char)]<>dir_default then begin
            last:=1;
            if is_char_node(link(p)) then
              if font_dir[font(link(p))]<>dir_default then begin
                @<Append KANJI-KANJI spacing @>; p:=link(p);
              end;
          end else begin
            if auto_xsp_code(qo(character(last_char)))>=2 then
              last:=-1 else last:=0;
          end;
        end else last:=0;
      end else last:=0;
    end else last:=0;
  end

@ @<Insert ligature surround spacing@>=
  begin
    t:=lig_ptr(p);
    if last>0 then begin
      if is_char_node(t) then
        if (auto_xsp_code(qo(character(t))) mod 2)=1 then
          @<Insert KANJI-ASCII spacing@>;
    end;
    while link(t)<>null do t:=link(t);
    if is_char_node(t) then
      if auto_xsp_code(qo(character(t)))>=2 then last:=-1
      else last:=0;
  end

@ @<Insert node surround spacing@>=
  if is_char_node(link(p)) then begin
    q:=p; p:=link(p);
    if font_dir[font(p)]<>dir_default then begin
      KANJI(j):=info(link(p));
      if last<0 then @<Insert ASCII-KANJI spacing@>
      else if last>0 then @<Insert KANJI-KANJI spacing@>;
      p:=link(p); last:=1;
    end else begin
      xsp:=auto_xsp_code(qo(character(p)));
      if (xsp mod 2)=1 then
        if last>0 then @<Insert KANJI-ASCII spacing@>;
      if xsp>=2 then last:=-1 else last:=0;
    end;
  end

@ @d new_pos=0
@d cur_pos=1
@d no_entry=1000
@d inhibit_both=0
@d inhibit_previous=1
@d inhibit_after=2

@ @<Insert ASCII-KANJI spacing@>=
begin x:=get_inhibit_pos(j, cur_pos);
  if x<>no_entry then
    if (inhibit_xsp_type(x)=inhibit_both)or
        (inhibit_xsp_type(x)=inhibit_previous) then f:=false else f:=true
  else f:=true;
  if f then begin
    z:=new_glue(s); subtype(z):=xkanji_skip_code+1;
    link(z):=link(q); link(q):=z; q:=z;
  end;
end

@ @<Insert KANJI-ASCII spacing@>=
  begin x:=get_inhibit_pos(j, cur_pos);
    if x<>no_entry then
      if (inhibit_xsp_type(x)=inhibit_both)or
          (inhibit_xsp_type(x)=inhibit_after) then f:=false else f:=true
    else f:=true;
    if f then begin
      z:=new_glue(s); subtype(z):=xkanji_skip_code+1;
      link(z):=link(q); link(q):=z; q:=z;
    end;
  end
  
@ @<Insert KANJI-KANJI spacing@>=
  begin
    z:=new_glue(u); subtype(z):=kanji_skip_code+1;
    link(z):=link(q); link(q):=z; q:=z
  end

@ @<Append KANJI-KANJI spacing@>=
  begin
    z:=new_glue(u); subtype(z):=kanji_skip_code+1;
    link(z):=link(p); link(p):=z; p:=link(z); q:=z
  end

@ @<Seek list and make |t| pointing widow penalty position@>=
  q:=v; p:=link(v); s:=null;
  if is_char_node(v) then
    if font_dir[font(v)]<>dir_default then begin
      q:=p; p:=link(p);
    end;
  t:=q;
  while(p<>null) do begin
    if is_char_node(p) then begin
      if font_dir[font(p)]<>dir_default then begin
        KANJI(j):=info(link(p));
        i:=cat_code(Hi(j));
        k:=0;
        if (i=kanji)or(i=kana) then begin t:=q; s:=p; end;
        p:=link(p); q:=p;
      end else begin
        k:=k+1;
        if k>1 then begin q:=p; s:=null; end;
      end;
    end else begin
      case type(p) of
      penalty_node,mark_node,adjust_node,whatsit_node,
      glue_node,kern_node,math_node,disp_node:
        do_nothing;
      othercases
        begin q:=p; s:=null; end;
      endcases;
    end;
    p:=link(p);
  end

@ @d pre_break_penalty_code=1
@d post_break_penalty_code=2

@<Put each...@>=
primitive("prebreakpenalty",assign_kinsoku,pre_break_penalty_code);
@!@:pre_break_penalty_}{\.{\\prebreakpenalty} primitive@>
primitive("postbreakpenalty",assign_kinsoku,post_break_penalty_code);
@!@:psot_break_penalty_}{\.{\\postbreakpenalty} primitive@>
primitive("inhibitxspcode",assign_inhibit_xsp_code,inhibit_xsp_code_base);
@!@:inhibit_xsp_code_}{\.{\\inhibitxspcode} primitive@>
@!@:inhibit_xsp_code_}{\.{\\inhibitxspcode} primitive@>
  
@ @<Cases of |print_cmd_chr|...@>=
  assign_kinsoku: case chr_code of
    pre_break_penalty_code: print_esc("prebreakpenalty");
    post_break_penalty_code: print_esc("postbreakpenalty");
    endcases;
  assign_inhibit_xsp_code: print_esc("inhibitxspcode");
  
@ @<Declare procedures needed in |scan_something|@>=
function get_kinsoku_pos(c:KANJI_code; n:small_number):pointer;
label done, done1;
var p,s:pointer;
begin s:=calc_pos(c); p:=s;
if n=new_pos then begin
  repeat if (kinsoku_type(p)=0)or(kinsoku_code(p)=c) then goto done;
    incr2(p); if p>511 then p:=0;
  until s=p; p:=no_entry;
  end else begin
  repeat if kinsoku_type(p)=0 then goto done1;
    if kinsoku_code(p)=c then goto done;
    incr2(p); if p>511 then p:=0;
  until s=p;
done1: p:=no_entry;
  end;
done: get_kinsoku_pos:=p;
end;
  
@ @<Declare procedures needed in |scan_something|@>=
  function get_inhibit_pos(c:KANJI_code; n:small_number):pointer;
  label done, done1;
  var p,s:pointer;
  begin
    s:=calc_pos(c)/2; p:=s;
    if n=new_pos then begin
      repeat
        if (inhibit_xsp_code(p)=0)or(inhibit_xsp_code(p)=c) then goto done;
        incr(p); if p>255 then p:=0;
      until s=p;
      p:=no_entry;
    end else begin
      repeat
        if inhibit_xsp_code(p)=0 then goto done1;
        if inhibit_xsp_code(p)=c then goto done;
        incr(p); if p>255 then p:=0;
      until s=p;
done1:
    p:=no_entry;
  end;
done:
  get_inhibit_pos:=p;
end;

@ @<Assignments@>=
  assign_kinsoku:
    begin
      p:=cur_chr; scan_int; n:=cur_val; scan_optional_equals; scan_int;
      if check_kanji(n) then begin
        j:=get_kinsoku_pos(tokanji(n), new_pos);
        if j=no_entry then begin
          print_err("KINSOKU table is full!!");
          help1("I'm skip this control sequences.");@/
          error; return;
        end;
        if p=pre_break_penalty_code then
          dword_define(kinsoku_base+j,pre_break_penalty_code,n,cur_val)
        else if p=post_break_penalty_code then
          dword_define(kinsoku_base+j,post_break_penalty_code,n,cur_val)
        else confusion("kinsoku");
      end else begin
        print_err("Invalid KANJI code ("); print_int(n);
@.Invalid KANJI code@>
        help1("I'm skip this control sequences.");@/
        error; return;
      end;
    end;
  assign_inhibit_xsp_code:
    begin
      p:=cur_chr; scan_int; n:=cur_val; scan_optional_equals; scan_int;
      if check_kanji(n) then begin
        j:=get_inhibit_pos(tokanji(n), new_pos);
        if j=no_entry then begin
          print_err("Inhibit table is full!!");
          help1("I'm skip this control sequences.");@/
          error; return;
        end;
        define(inhibit_xsp_code_base+j,cur_val,n);
      end else begin
        print_err("Invalid KANJI code ("); print_int(n);
@.Invalid KANJI code@>
        help1("I'm skip this control sequences.");@/
        error; return;
      end;
    end;

@ @<Fetch breaking penalty from some table@>=
begin scan_int; q:=get_kinsoku_pos(tokanji(cur_val), cur_pos);
  cur_val_level:=int_val; cur_val:=0;
  if q<>no_entry then
    if m=kinsoku_type(q) then scanned_result(kinsoku(q))(int_val)
end
  
@ @<Fetch inhibit type from some table@>=
  begin scan_int; q:=get_inhibit_pos(tokanji(cur_val), cur_pos);
    cur_val_level:=int_val; cur_val:=3;
    if q<>no_entry then
      cur_val:=inhibit_xsp_type(q);
  end

@ @<Insert post_break_penalty, check char_node@>=
  if is_char_node(tail) then begin
    cx:=tokanji(qo(character(tail))); kp:=get_kinsoku_pos(cx, cur_pos);
    if kp<>no_entry then if kinsoku_type(kp)=post_break_penalty_code then begin
      tail_append(new_penalty(kinsoku(kp))); subtype(tail):=kinsoku_pena;
    end
  end;

@ @<Insert post_break_penalty, no check@>=
  begin
    cx:=tokanji(c); kp:=get_kinsoku_pos(cx, cur_pos);
    if kp<>no_entry then
      if kinsoku_type(kp)=post_break_penalty_code then begin
        tail_append(new_penalty(kinsoku(kp))); subtype(tail):=kinsoku_pena;
      end
  end;

@ @<Insert kinsoku penalty@>=
  kp:=get_kinsoku_pos(cur_jchr, cur_pos);
  if kp<>no_entry then begin
    if kinsoku_type(kp)=pre_break_penalty_code then begin
      if (not is_char_node(q))and(type(q)=penalty_node) then
        penalty(q):=penalty(q)+kinsoku(kp)
      else begin
        p:=link(q);
        link(q):=new_penalty(kinsoku(kp)); subtype(link(q)):=kinsoku_pena;
        link(link(q)):=p;
      end;
    end else begin
      tail_append(new_penalty(kinsoku(kp))); subtype(tail):=kinsoku_pena;
    end;
  end;

@ @<Insert pre_break_penalty@>=
  begin cx:=tokanji(cur_chr); kp:=get_kinsoku_pos(cx, cur_pos);
    if kp<>no_entry then
      if kinsoku_type(kp)=pre_break_penalty_code then begin
        if (not is_char_node(tail)) and (type(tail)=penalty_node) then
          penalty(tail):=penalty(tail)+kinsoku(kp)
        else begin
          tail_append(new_penalty(kinsoku(kp))); subtype(tail):=kinsoku_pena;
        end
      end;
  end;

@ @<Make ligature node and Insert post_break_penalty@>=
  begin kp:=get_kinsoku_pos(l, cur_pos);
    p:=new_ligature(f,l,link(q)); link(q):=p;
    if (kp<>no_entry)and(kinsoku_type(kp)=pre_break_penalty_code)then begin
      link(q):=new_penalty(kinsoku(kp)); link(link(q)):=p;
    end;
    tail:=p;
  end;

@ @<Declare act...@>=
procedure set_math_kchar(@!c:integer);
var p:pointer; {the new noad}
begin
  p:=new_noad; math_type(nucleus(p)):=math_jchar;
  character(nucleus(p)):=qi(0);
  math_kcode(p):=c; fam(nucleus(p)):=cur_jfam;
  if font_dir[fam_fnt(fam(nucleus(p))+cur_size)]=dir_default then begin
    print_err("Not two-byte family");
    help1("IGNORE.");@/
    error;
  end;
  type(p):=ord_noad;
  link(tail):=p; tail:=p;
end;

@ @<Local variables for dimension calculations@>=
@!t: eight_bits;

@ @<The KANJI width for |cur_jfont|@>=
  if direction=dir_tate then
    v:=char_width(cur_tfont)(char_info(cur_tfont)(qi(0)))
  else
    v:=char_width(cur_jfont)(char_info(cur_jfont)(qi(0)))

@ @<The KANJI height for |cur_jfont|@>=
  if direction=dir_tate then begin
    t:= height_depth(char_info(cur_tfont)(qi(0)));
    v:=char_height(cur_tfont)(t)+char_depth(cur_tfont)(t);
  end else begin
    t:= height_depth(char_info(cur_jfont)(qi(0)));
    v:=char_height(cur_jfont)(t)+char_depth(cur_jfont)(t);
  end

@ @<set zero glue@>=
  space_ptr(p):=zero_glue;xspace_ptr(p):=zero_glue;
  add_glue_ref(zero_glue);add_glue_ref(zero_glue);

@ @<Global...@>=
  inhibit_glue_flag:boolean;

@ @<Set init...@>=
  inhibit_glue_flag:=false;

@ @<Put each of \TeX's primitives into the hash table@>=
  primitive("inhibitglue",inhibit_glue,0);@/
  @!@:inhibitglue_}{\.{\\inhibitglue} primitive@>

@ @<Cases of |print_cmd_chr| for symbolic printing of primitives@>=
  inhibit_glue: print_esc("inhibitglue");

@ @<Cases of |main_control| that don't...@>=
  any_mode(inhibit_glue): inhibit_glue_flag:=true;
  
@z
